<?xml version="1.0"?>
<doc>
    <assembly>
        "HavokWrapper"
    </assembly>
    <members>
        <member name="D:glm.highp_dquat">
Quaternion of high double-qualifier floating-point numbers using high precision arithmetic in term of ULPs.

@see ext_quaternion_double_precision
</member>
        <member name="D:glm.mediump_dquat">
Quaternion of medium double-qualifier floating-point numbers using high precision arithmetic in term of ULPs.

@see ext_quaternion_double_precision
</member>
        <member name="D:glm.lowp_dquat">
@addtogroup ext_quaternion_double_precision
@{
Quaternion of double-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see ext_quaternion_double_precision
</member>
        <member name="D:glm.dquat">
@addtogroup ext_quaternion_double
@{
Quaternion of double-precision floating-point numbers.
</member>
        <member name="D:glm.highp_quat">
Quaternion of single-precision floating-point numbers using high precision arithmetic in term of ULPs.
</member>
        <member name="D:glm.mediump_quat">
Quaternion of single-precision floating-point numbers using high precision arithmetic in term of ULPs.
</member>
        <member name="D:glm.lowp_quat">
@addtogroup ext_quaternion_float_precision
@{
Quaternion of single-precision floating-point numbers using high precision arithmetic in term of ULPs.
</member>
        <member name="D:glm.quat">
@addtogroup ext_quaternion_float
@{
Quaternion of single-precision floating-point numbers.
</member>
        <member name="P:Havok.HkdWoodFracture.SplinterSplittingData">
Splitting data for breaking a single 'board' into 'splinters'.
</member>
        <member name="P:Havok.HkdWoodFracture.BoardSplittingData">
Splitting data for breaking the original shape into 'boards'.
</member>
        <member name="P:Havok.HkdWoodFracture.RandomSeed">
The seed used for the runtime random number generator.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.FractureNormalShearingRange">
Before splitting some shearing will be applied to the original splitting geometry.
You can use this value to define the amount of distortion along the geometry's z-axis when traversing along the y-axis.
E.g. setting this value to 1 will virtually 'rotate' the splitting geometry up to 45 degrees.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.FractureLineShearingRange">
Before splitting some shearing will be applied to the original splitting geometry.
You can use this value to define the amount of distortion along the geometry's x-axis when traversing along the z-axis.
E.g. setting this value to 1 will virtually 'rotate' the splitting geometry up to 45 degrees.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.SurfaceNormalShearingRange">
Before splitting some shearing will be applied to the original splitting geometry.
You can use this value to define the amount of distortion along the geometry's x-axis when traversing along the y-axis.
E.g. setting this value to 1 will virtually 'rotate' the splitting geometry up to 45 degrees.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.SplitGeomShiftRangeZ">
The splitting geometry will be randomly shifted along its plane.
You can use this value to limit the maximum variance for the shifting along the geometry's z-axis.
This value is defined as percentage of the geometry's extent along its z-axis.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.SplitGeomShiftRangeY">
The splitting geometry will be randomly shifted along its plane.
You can use this value to limit the maximum variance for the shifting along the geometry's y-axis.
This value is defined as percentage of the geometry's extent along its y-axis.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.ScaleRange">
When scaling the splitting geometry the m_scale values will be modified using a random number generator.
The m_scaleRange values define the maximum variation around the original m_scale values.
Using 0.0 will scale the geometry by the exact m_scale values, 2.0 allows for values from 0.5x to 2.0x the original scale.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.Scale">
The splitting geometry will be scaled along it axes by these values.
You can use this to 'zoom into' the splitting geometry before applying it.
Using values of exactly 1.0 will leave the geometry at its original size.
Using values smaller than 1.0 might cause artifacts if the splitting geometry gets smaller than the to-be-split object.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.WidthRange">
The variation of the subpart's width. 0.0 -&gt; no variation, 1.0 -&gt; width can vary between 0.0 and 'double width'.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.NumSubparts">
The number of subparts you would ideally want.
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.RotateSplitGeom">
How to rotate the splitting geometry
</member>
        <member name="F:Havok.HkdWoodFracture.SplittingData.SplittingAxis">
Controls how the orientation of the splitting takes place. If this is set to (0,0,0), the system will try to automatically select the best axis (based on mass distribution/inertia tensor computer calculation).
</member>
        <member name="T:Havok.HkdWoodFracture.SplittingData.Rotation">
How to rotate the splitting geometry
</member>
        <member name="T:Havok.HkdWoodFracture.SplittingData">
Data to control the details of a split
</member>
        <member name="P:Havok.HkdVoronoiFracture.NumIterations">
The number of passes applied to the Voronoi site creation to move them to equidistant positions.
</member>
        <member name="P:Havok.HkdVoronoiFracture.NumSitesToGenerate">
Set this to some number to enable auto-creation of Voronoi sites.
</member>
        <member name="P:Havok.HkdVoronoiFracture.Seed">
The random seed for the Voronoi site auto-creation.
</member>
        <member name="P:Havok.HkdRandomSplitFracture.RandomRange">
The range of the random influence on the possible cut position. 0.0 always chooses the center, 1.0 allows the full range to be used.
</member>
        <member name="P:Havok.HkdRandomSplitFracture.RandomSeed4">
The seed used for the runtime random number generator on the fourth level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.RandomSeed3">
The seed used for the runtime random number generator on the third level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.RandomSeed2">
The seed used for the runtime random number generator on the second level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.RandomSeed1">
The seed used for the runtime random number generator on the first level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.NumObjectsOnLevel4">
The number of objects to produce on the fourth level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.NumObjectsOnLevel3">
The number of objects to produce on the third level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.NumObjectsOnLevel2">
The number of objects to produce on the second level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.NumObjectsOnLevel1">
The number of objects to produce on the first level
</member>
        <member name="P:Havok.HkdRandomSplitFracture.SplitGeometryScale">
This scales the splitting geometry in splitting geometry space
</member>
        <member name="P:Havok.HkdRandomSplitFracture.SplitLargestVolumesFirst">
If set to true, the largest volumes will be split first on each recursion level.
If set to false, a random shape will be chosen for splitting on each recursion level.
</member>
        <member name="P:Havok.HkdDecomposeFracture.ShiftToSmallerCrossSection">
The actual position of the split can be shifted towards (or away from) the physics object (out of the two "connected" parts) with the smaller cross-section. See the user guide for more details on this.
</member>
        <member name="M:Havok.HkTriggerVolume.UpdateOverlaps">
Call this to update the triggerVolume outside the physics step.
triggerEventCallbacks may be fired with types ENTERED_EVENT and LEFT_EVENT.
You may want to re-collide the entities before calling this.
</member>
        <member name="M:HkTriggerVolumeNative.triggerEventCallback(hkpCharacterProxy*,hkpTriggerVolume.EventType)">
Character proxies process their own collisions, so they call this method to inform
the trigger volume that they touched it during the frame.
</member>
        <member name="M:HkTriggerVolumeNative.triggerEventCallback(hkpRigidBody*,hkpTriggerVolume.EventType)">
Subclasses should implement this function to be informed of events involving
rigid bodies (including the bodies of hkpCharacterRigidBodies).
</member>
        <member name="F:Havok.EventType.TriggerBodyLeftEvent">
Fired for any overlapping body when the trigger body leaves the world or is deleted.
</member>
        <member name="M:Havok.HkConvexVerticesShape.GetGeometry(Havok.HkGeometry,VRageMath.Vector3@)">
            <summary>
Gets geometry
</summary>
        </member>
        <member name="M:Havok.HkConvexVerticesShape.GetFaces(System.Collections.Generic.List`1{System.Int32},System.Collections.Generic.List`1{System.Byte})">
            <summary>
Gets faces
</summary>
        </member>
        <member name="P:Havok.HkConvexVerticesShape.Center">
            <summary>
Gets center
</summary>
        </member>
        <member name="M:Havok.HkConvexVerticesShape.GetVertices(System.Collections.Generic.List`1{VRageMath.Vector3})">
            <summary>
Gets vertices
</summary>
        </member>
        <member name="M:Havok.HkCylinderShape.SetNumberOfVirtualSideSegments(System.Int32)">
            <summary>
Input value is rounded down to a multiple of 8. Values between 8 and 128 are accepted.
</summary>
        </member>
        <member name="P:Havok.HkListShape.DebugShapeKeys">
            <summary>
Gets shape keys, for debug purposes, allocates!
</summary>
        </member>
        <member name="M:Havok.hkdMeshMaterial.setColors(hkVector4f!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the color properties of the material
</member>
        <member name="M:Havok.hkdMeshMaterial.getColors(hkVector4f*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVector4f*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the color properties of the material
</member>
        <member name="M:Havok.hkdMeshMaterial.addTexture(hkMeshTexture*)">
Adds a texture to the material
</member>
        <member name="M:Havok.hkdMeshMaterial.getTexture(System.Int32)">
Interface describing the texture at index
</member>
        <member name="M:Havok.hkdMeshMaterial.getNumTextures">
Number of textures used by the material
</member>
        <member name="M:Havok.hkdMeshMaterial.getName">
Gets the name of the material. Returns HK_NULL if the material is not named.
</member>
        <member name="M:Havok.hkdMeshMaterial.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the name of the material.
</member>
        <member name="M:Havok.hkdMeshMaterial.equals(hkMeshMaterial!System.Runtime.CompilerServices.IsConst*)">
Tests whether two materials are equal
</member>
        <member name="M:Havok.hkdMeshMaterial.isCompatible(hkMeshVertexBuffer!System.Runtime.CompilerServices.IsConst*)">
Returns true if this vertex buffer is suitable for this material
</member>
        <member name="M:Havok.hkdMeshMaterial.createCompatibleVertexBuffer(hkMeshVertexBuffer*)">
Constructs a suitable vertex buffer based on the input.
If the input is suitable, may return the input ref'd.
</member>
        <member name="M:Havok.hkdMeshMaterial.createCompatibleVertexFormat(hkVertexFormat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,hkVertexFormat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a vertex buffer format that is compatible with this material
</member>
        <member name="T:Havok.hkdMeshMaterial">

!! IMPORTANT : Use only its id as identifier to our material !!

</member>
        <member name="M:hkpUniformGridShape.getShape(System.Int32,System.Int32,System.Int32,hkpBvCompressedMeshShape**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a shape, returns true if set (inspect poitner to find if shape or empty), returns false if shape was not set.

</member>
        <member name="M:hkpUniformGridShape.#ctor">
Empty constructor, to be called by the shape vtable util on SPU
</member>
        <member name="M:hkpSmartListShape.#ctor">
Empty constructor, to be called by the shape vtable util on SPU
</member>
        <member name="F:hkManagedCheckingMemorySystem.m_allocators">
These forward tagged requests to the checkedAlloc and checkedFree
</member>
        <member name="F:hkManagedCheckingMemorySystem.m_debugAllocator">
We need a stats allocator for call tree nodes in order to keep statistics about
allocations, we can't use the default allocator forwarder behaviour since call tree
nodes get allocated during other allocations. This allocator is usually directly
connected to the raw allocator.
</member>
        <member name="F:hkManagedCheckingMemorySystem.m_paddedAllocator">
Components used to build the base allocator (might not all be valid)
</member>
        <member name="F:hkManagedCheckingMemorySystem.m_baseAllocator">
The allocator we use for most allocations, it will be cooked using the checking memory system configuration
</member>
        <member name="M:hkManagedCheckingMemorySystem.newAllocator(hkFlags&lt;hkManagedCheckingMemorySystem.AllocatorBits,System.UInt32&gt;,System.UInt64)">
Create a new forwarding allocator
</member>
        <member name="M:hkManagedCheckingMemorySystem.leakReportByOwnership">
Report active memory allocations, attempting to report the 'root' allocations first
</member>
        <member name="M:hkManagedCheckingMemorySystem.leakReportByTime">
Report active memory allocations, ordered by time.
</member>
        <member name="T:hkManagedCheckingMemorySystem.Bookmark">
String and timestamp to mark different sections.
This is used in the leak report in addition to the callstack information.
</member>
        <member name="M:hkManagedCheckingMemorySystem.isOk">
Perform an internal consistency check.
</member>
        <member name="D:hkManagedCheckingMemorySystem.OutputStringFunc">
Callback printing function type
</member>
        <member name="T:hkManagedCheckingMemorySystem.AllocatorForwarder">
This allocator forwards requests to a checking memory allocator along with a context.
</member>
        <member name="F:hkManagedCheckingMemorySystem.AllocationContext.peakInUse">
Stats
</member>
        <member name="F:hkManagedCheckingMemorySystem.AllocationContext.curInUse">
Stats
</member>
        <member name="F:hkManagedCheckingMemorySystem.AllocationContext.threadId">
Thread identifier
</member>
        <member name="F:ALLOCATOR_INVALID">
Freeing thread must also be the allocating thread.
</member>
        <member name="F:CHECK_DEFAULT">
Default is everything enabled.
</member>
        <member name="F:CHECK_DELAYED_FREE">
Cache some free blocks to detect use-after-free errors.
</member>
        <member name="F:CHECK_PAD_BLOCK">
Pad each allocation with some canary bytes.
</member>
        <member name="F:CHECK_CALLSTACK">
Store a callstack for each allocation, especially useful for leak checking.
</member>
        <member name="F:CHECK_LEAKS">
Check for matching free for each alloc.
</member>
        <member name="F:CHECK_NONE">
No checks, just forward the request.
</member>
        <member name="T:hkManagedCheckingMemorySystem.CheckBits">
Checks the allocator can perform.
</member>
        <member name="T:hkManagedCheckingMemorySystem">
Debugging memory system checks for some common errors.
It detects memory leaks and some bad memory writes. The default is
to perform a stack trace (if the platform supports it) on every allocation
to pinpoint leaks. This may be disabled for increased speed.

Several other logical errors are detected, such as allocating and freeing
memory with incompatible allocators.

This class owns several proxy allocators which forward requests
back to central methods along with a context indicating where the
request came from.
</member>
        <member name="M:Havok.HkdBreakableBodyFactory.CreateBreakableBody(Havok.HkdShapeInstanceInfo,Havok.HkdCreateBodyInput)">

Make sure that input has set its BreakableBody parent.

</member>
        <member name="T:hkpDestructionBreakOffUtilME">
This utility class is an interface between the physics constraint solver and the Destruction runtime.
For each contact / constraint involving an entity flagged as breakable, the solver queries the entity for the
maximum impulse it can apply to maintain the constraint. The request is forwarded to the Destruction runtime,
which is responsible for returning a proper impulse value back to the solver. 
</member>
        <member name="M:Havok.HkdBreakableBodyListener.afterBreakableBodyControllerOperation(hkdBreakableBody*)">
Called after the breakable body's controller world operation has executed

Called after the breakable body's controller world operation has executed
</member>
        <member name="M:Havok.HkdBreakableBodyListener.beforeBreakableBodyControllerOperation(hkdBreakableBody*)">
Called before the breakable body's controller world operation gets executed

Called before the breakable body's controller world operation gets executed
</member>
        <member name="M:Havok.HkdBreakableBodyListener.afterBreakableBodyReplaced(hkdReplaceBodyEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called after a breakable body is replaced with new bodies.
</member>
        <member name="M:Havok.HkdBreakableBodyListener.beforeBreakableBodyReplaced(hkdReplaceBodyEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called before a breakable body is replaced with new bodies.
</member>
        <member name="P:Havok.HkdFracture.FlattenHierarchy">
Only return leaf shapes. The entire fracture hierarchy will be flattened into a flat list of children
</member>
        <member name="F:Havok.HkdFracture.MaxNumberOfChildNodes">
This is the hard limit on the number of child nodes to create in a breakable shape hierarchy.
It is used to prevent infinite recursion.
</member>
        <member name="T:Havok.HkdFracture.RefitPhysicsType">
Defines how the physics for the broken shapes should be calculated
</member>
        <member name="T:Havok.HkdFracture.Type">
The algorithm type
</member>
        <member name="F:Havok.HkdWorld.m_havokWorld">
Our world
</member>
        <member name="M:Havok.HkdShapeInstanceInfo.#ctor(Havok.HkdBreakableShape,VRageMath.Matrix)">
initializing Ctor
</member>
        <member name="M:Havok.HkdShapeInstanceInfo.#ctor(Havok.HkdBreakableShape,System.Nullable`1{VRageMath.Quaternion},System.Nullable`1{VRageMath.Vector3})">
Ctor which does not initialize anything
initializing Ctor
</member>
        <member name="P:Havok.HkdConnection.ContactArea">
A measure of the strength of a connection. Normally set as the area of the connection
between the shapes. The controller will use this to work out compression and tension
strengths.
</member>
        <member name="M:Havok.HkWorld.GatherContactSounds">
            <summary>
Prepare the list of post-step calculated contact sounds.

This method clear the internal queue of contact sounds and acumulates the values in a managed buffer that is returned.

To accelerate memory cleanup the user may clear the returned buffer it has been processed.
This is not mandatory.
</summary>
        </member>
        <member name="F:Havok.HkWorld.m_world">
Our world
</member>
        <member name="M:hkpAllShapePairCollector.getHits">
Get all the hits
</member>
        <member name="M:hkpAllShapePairCollector.reset">
Resets the early out condition and empties the array of hits.
You must call this function if you want to reuse an object of this class.
</member>
        <member name="M:hkpAllShapePairCollector.#ctor">
Constructor calls reset()
</member>
        <member name="F:hkpRootBodyShapePair.m_shapeB">
The root collidable of object B
The shape of the colliding shape of object B
</member>
        <member name="M:Havok.HkGroupFilter.GetNewSystemGroup">
Creates a new unique identifier for system groups (maximum 65k).
</member>
        <member name="M:Havok.HkGroupFilter.getSubSystemDontCollideWithFromFilterInfo(System.UInt32)">
Extract the subSystemDontCollideWith from a given filterInfo.
</member>
        <member name="M:Havok.HkGroupFilter.GetSubSystemIdFromFilterInfo(System.UInt32)">
Extract the subsystem id from a given filterInfo.
</member>
        <member name="M:Havok.HkGroupFilter.GetSystemGroupFromFilterInfo(System.UInt32)">
Extract the system group from a given filterInfo.
</member>
        <member name="M:Havok.HkGroupFilter.SetLayer(System.UInt32,System.Int32)">
Returns the filter info provided with the layer replaced by newLayer.
</member>
        <member name="M:Havok.HkGroupFilter.GetLayerFromFilterInfo(System.UInt32)">
Extract the layer from a given filterInfo.
</member>
        <member name="M:Havok.HkGroupFilter.CalcFilterInfo(System.Int32,System.Int32)">
Combine the layer and systemGroup information into one 32 bit integer.
This resulting collision filter info can be used in entities and hkEntityCinfo.
</member>
        <member name="M:Havok.HkGroupFilter.DisableCollisionsUsingBitfield(System.UInt32,System.UInt32)">
Disables collisions between the specified collision layers.
See enableCollisionsUsingBitfield for how to use bitfields.
</member>
        <member name="P:Havok.HkCharacterRigidBody.LinearVelocity">
            <summary>
Gets or sets linear velocity of rigid body at center of mass.
</summary>
        </member>
        <member name="P:Havok.HkCharacterRigidBody.Position">
The initial position for the proxy in world space.
</member>
        <member name="M:hkpGridShape.#ctor">
Empty constructor, to be called by the shape vtable util on SPU
</member>
        <member name="M:hkpCharacterStateInAir2.getType">
Return the state type
</member>
        <member name="P:Havok.HkCharacterProxy.LinearVelocity">
            <summary>
Gets or sets linear velocity of rigid body at center of mass.
</summary>
        </member>
        <member name="P:Havok.HkCharacterProxy.Position">
The initial position for the proxy in world space.
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.HardSupportDistance">
A character should keep falling until it is this distance or less from its supporting planes.
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.SupportDistance">
A character is considered supported if it is less than this distance above its supporting planes.
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.MaxSpeedForSimplexSolver">
Set maximal speed for simplex solver
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.UnweldingHeightOffsetFactor">
If the character's shape is a capsule, then this is used to define the height of a region around its center
where we redirect contact point normals. The region extends from above the capsule's upper vertex to below
the lower vertex by this height, expressed as a factor of the capsule's radius.
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.MaxForce">
Set maximal force of character
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.MaxSlope">
Set maximal slope
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Up">
Set up direction
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.AllowedPenetrationDepth">
Set maximal allowed penetration depth.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.MaxLinearVelocity">
Set maximum linear velocity (see hkpRigidBodyCinfo for details). Keep in mind that the maximum linear 
velocity is restricted as well by hkpCharacterContext. Use hkpCharacterContext.setFilterParameters 
to keep both limits in sync when necessary.
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Friction">
Set friction of character.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Mass">
The mass of character.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Rotation">
Initial rotation.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Position">
Initial position.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.Shape">
The shape.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterRigidBodyCinfo.CollisionFilterInfo">
The collision filter info.
See hkpRigidBodyCinfo for details
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.RefreshManifoldInCheckSupport">
This flag determines whether the character controller refreshes the manifold when checkSupport is called.
By default this is set to false, i.e., the manifold is not updated. This leads to a small inaccuracy when
the character controller is hit by a rapidly accelerating body, however it is better to accept this
inaccuracy, as the extra refresh manifold call can be computationally expensive.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.MaxCastIterations">
The number of iterations the character controller will take to resolve an integrate() call.
The character controller will iterate if it hits a surface, and needs to change direction to complete
the integrate for that timestep. The default is 10 iterations.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.PenetrationRecoverySpeed">
When a penetrating plane is added to the manifold we set its velocity so it will push
the character away from the point of penetration. This variable controls the speed
at which this recovery takes place. The velocity applied is proportional to the penetration distance.
This values controls the proportion.
By default this value is set to 1.0
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.MaxSlope">
The maximum slope that the character can walk up. If the character is standing on a slope that
is steeper than this, checkSupport() will return false, and an additional vertical plane will be
added during integrate() that will block the character's movement in the direction of the slope.
This angle is measured in radians from the horizontal.
By default this value is set to PI / 2, i.e., vertical, which disables this feature.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.CharacterMass">
The mass of the character. This value is only used to apply an extra downward force to dynamic
rigid bodies that the character is standing on. By default this value is 0, which means no additional
downward force is applied. It should only be set to a positive value if you do not apply gravity
from your state machine when the character is on the ground.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.CharacterStrength">
The maximum constant force that the character controller can impart onto
moving objects. By default this is HK_REAL_MAX, i.e., the character controller
is infinitely strong.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.MaxCharacterSpeedForSolver">
This value is used to clip the character's velocity when it is being "squeezed" by two
moving planes. When two nearly parallel planes squeeze the character, the resultant velocity
necessary to move the character so that both planes do not penetrate it can be extremely high,
which can cause in the character controller to move at a very fast velocity.
This value defaults to 10 (which is appropriate if your default walking speed is 10).
If this velocity is exceeded by the character solver when solving parallel planes, the
solver solves the planes independently. The result is that instead of moving at a high
velocity, the character may penetrate one of the planes (based on plane priorities).
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.UserPlanes">
The maximum number of extra planes the user may add to the simplex input
during a processConstraints callback.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.ContactAngleSensitivity">
This value is used when deciding which contact points in the manifold are duplicates.
Precisely, it determines when two contact points are found, whether they
are to be treated as the same based on the angle between the normals.
For two contact points which are identical apart from the direction of the normals
the threshold angle A can be calculated from A = acos(1 - (.1/(10* m_contactAngleSensitivity))).
For the default value of 10, contact points with angles less then 2.56 degrees are considered as identical.
If you decrease this to 1, contact points with angles less then 8.1 degrees are considered as identical.
A larger value will increase the number of contact points considered in the manifold, and make for
a more accurate simulation at slightly higher computational expense.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.KeepDistance">
Attempt to keep the character at least this distance from the surface. Used
internally for numerical stability and performance reasons.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.ShapePhantom">
The collision detection representation for this entity.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.ExtraDownStaticFriction">
This parameter has been deprecated. It was intended to limit the maximum slope
on which a character can walk. Now use m_maxSlope instead.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.ExtraUpStaticFriction">
This parameter has been deprecated. It was intended to limit the maximum slope
on which a character can walk. Now use m_maxSlope instead.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.Up">
Friction is split into horizontal and vertical components. This vector is used
to separate the components. In general it should be a normalized, negated version
of gravity.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.KeepContactTolerance">
This parameter is used to determine when a contact point should be considered
as part of the character's contact manifold. The default is 0.1f, which means
that points .1 above the keep distance will be considered as part of the manifold.
This value should be kept at the its default, as changing it from the default
value can have undesirable effects.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.StaticFriction">
Controls the default static friction for surfaces hit.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.DynamicFriction">
Controls the default dynamic friction for surfaces hit. A value of 0
maintains character momentum. A value of 1 clips all momentum against the normal
of the surface hit.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.Velocity">
The initial velocity for the proxy in world space.
</member>
        <member name="P:Havok.HkCharacterProxyCinfo.Position">
The initial position for the proxy in world space.
</member>
        <member name="F:Havok.HkMoppBuildParameters.CachePrimitiveExtents">
            <summary>
Enable faster but more memory-consuming version of the MOPP shape mediator.

By default the MOPP shape mediator recalculates a primitive's maximum/minimum extent on each axis
during each access. By enabling this flag a 20% faster version of the shape mediator will be used
that only calculates the extents once for all axes upfront and caches the results. Note that this
mediator version has an increased memory consumption: for each of the shape's primitive an additional
108 bytes block is allocated.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.EnableInterleavedBuilding">
            <summary>
By default (EnableInterleavedBuilding=true)
the MOPP compiler uses a fixed-sized 2 megabyte buffer for triangle storage. This works well for
large sets of triangles as memory consumption is kept limited. Yet for small sets of triangles
(&lt;4000) it is better to only allocate the actually needed memory size (which is smaller than
the fixed-sized buffer). Set this member to false to disable interleaved building and to make
the compiler allocate the correct memory block needed for all triangles.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.EnableChunkSubdivision">
            <summary>
This tells the MOPP compiler to organize the MOPP code into smaller chunks so it can be processed on the PlayStation(R)3 SPU.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.EnablePrimitiveSplitting">
            <summary>
In typical landscapes, a single very big triangle can cause the tree to become pretty bad.
Therefore by default, the compiler can decide to split a triangle and put in triangle
twice into the tree. If you don't want this behavior, set EnablePrimitiveSplitting to false.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.UseShapeKeys">
            <summary>
By default the MOPP compiler tries to group similar shapekeys into
one node. This helps reducing the code size. However sometimes you want
to reorder your input without changing the tree. In this case you can set
this parameter to false;
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.AbsoluteFitToleranceOfTriangles">
            <summary>
Sets the fit tightness of the bounding volume leaf nodes for each triangle.
This scalar value represents the maximum distance between the extents of a
MOPP bounding volume node for a triangle and the extents of a
perfectly fitting bounding volume node for the same triangle.
Good values range from 1% * average triangle size (near-perfect fit)
to 50% * average triangle size (loose fit).
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.AbsoluteFitToleranceOfInternalNodes">
            <summary>
Sets the minimum fit tolerance of internal nodes.
This parameter has a subtle effect on the MOPP performance.
A good value is about 1/5 of your small object diameter.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.RelativeFitToleranceOfInternalNodes">
            <summary>
Sets the minimum fit tolerance for internal nodes as
a value relative to the size of the node.
This parameter has a subtle effect on the MOPP performance
a default range of [0.3f,0.7f] works well.
</summary>
        </member>
        <member name="F:Havok.HkMoppBuildParameters.AbsoluteFitToleranceOfAxisAlignedTriangles">
            <summary>
Sets the fit tightness of the bounding volume leaf nodes for axis aligned triangles.
If a triangle is coplanar to one of the major axes, this fit
tolerance is used instead of the scalar parameter. There is one value for each axis.
Normally only the axis which is parallel to the gravity should get a very low value.
This parameter is very important for racing games over a flat racing course.
NOTE: if this parameter is uninteresting, each component should be set equal
to the scalar absoluteFitToleranceOfTriangles
</summary>
        </member>
        <member name="T:Havok.HkMoppBuildParameters">
            <summary>
Input arguments to mopp construction.

Default values for this are not the same as a new struct. For that please use the default member.
</summary>
        </member>
        <member name="M:Havok.HkShapeCollection.GetShape(System.UInt32,Havok.HkShapeBuffer)">
            <summary>
Buffer can be null, when shape won't create any triangles
</summary>
        </member>
        <member name="M:Havok.HkStaticCompoundShape.AddInstance(Havok.HkShape,VRageMath.Matrix)">
            <summary>
Add instance, returns instance id
</summary>
        </member>
        <member name="M:Havok.HkStaticCompoundShape.#ctor(Havok.HkReferencePolicy)">
            <summary>
Creates new instance
</summary>
        </member>
        <member name="M:Havok.HkRagdoll.UpdateLocalTransforms">
Updates Ragdoll rigid bodies after the change of the world Matrix
</member>
        <member name="M:Havok.HkRagdoll.SetTransforms(System.Boolean)">
Updates Ragdoll rigid bodies after the change of the world Matrix
</member>
        <member name="T:Havok.HkRigidBodyNamePredicate">
This class is used as predicate to do searches within HkRigidBody lists..
</member>
        <member name="T:Havok.HkRigidBodyPredicate">
This class is used as predicate to do searches within HkRigidBody lists..
</member>
        <member name="M:Havok.HkRagdoll.SetToDynamic(System.Int32)">
Set all rigid bodies to dynamic
</member>
        <member name="M:Havok.HkRagdoll.SetToDynamic">
Set all rigid bodies to dynamic
</member>
        <member name="M:Havok.HkRagdoll.SetToKeyframed(System.Int32)">
Set rigid body to keyframed
</member>
        <member name="M:Havok.HkRagdoll.SetToKeyframed">
Set all rigid bodies to keyframed
</member>
        <member name="M:Havok.HkRagdoll.DisableConstraints">
Disables ragdoll constraints
</member>
        <member name="M:Havok.HkRagdoll.EnableConstraints">
Enables ragdoll constraints
</member>
        <member name="M:Havok.HkRagdoll.Deactivate">
Deactivates the ragdoll physics system
</member>
        <member name="M:Havok.HkRagdoll.Activate">
Activates the ragdoll physics system
</member>
        <member name="M:Havok.HkRagdoll.UpdateWorldMatrixAfterSimulation">
Ragdoll update after simulation

Update's ragdoll transformation after simulation step
</member>
        <member name="M:Havok.HkRagdoll.SetRigidBodyLocalTransform(System.Int32,VRageMath.Matrix)">
Set's the rigid body local transform (related to the whole system)

Set's the rigid body local transform (related to the whole system)
</member>
        <member name="M:Havok.HkRagdoll.GetRigidBodyLocalTransform(System.Int32)">
Returns local rigid body world matrix (related to the whole system)

Returns local rigid body world matrix (related to the whole system)
</member>
        <member name="M:Havok.HkRagdoll.SetWorldMatrix(VRageMath.MatrixD)">
Updates Ragdoll's transformation World Matrix including the keyframed bodies
</member>
        <member name="M:Havok.HkRagdoll.SetWorldMatrix(VRageMath.MatrixD,System.Boolean)">
Updates Ragdoll's transformation World Matrix, if updateBodies is false, it just set's the world matrix, but doesn't transform bodies matrices
</member>
        <member name="M:Havok.HkRagdoll.GenerateRigidBodiesCollisionFilters(System.Int32,System.Int32,System.Int32)">
Generates and sets collision filters on all rigid bodies in the ragdoll system, with the given layer, system group and will start indexing sub system ids with the passed startSubsystemIdsFrom

Generate rigid bodies collision filters - this starts from so startSubsystemIdsFrom, so eventually ID 0 can be used for any other body	
</member>
        <member name="M:Havok.HkRagdoll.FindRigidBodyIndex(System.String)">
Finds the rigidid body index with the given rigid body name
</member>
        <member name="M:Havok.HkRagdoll.FindRigidBody(System.String)">
Finds the rigid body in the ragdoll system with the given name
</member>
        <member name="E:Havok.HkRagdoll.Deleted">
Called after ragdoll (last constraint) was deleted
</member>
        <member name="E:Havok.HkRagdoll.RemovedFromWorld">
Called after ragdoll (last constraint) was removed from the world
</member>
        <member name="E:Havok.HkRagdoll.AddedToWorld">
Called after ragdoll (last constraint) was added to the world 
</member>
        <member name="P:Havok.HkRagdoll.IsKeyframed">
Return's true if whole system was set keyframed
</member>
        <member name="P:Havok.HkRagdoll.Layer">
Ragdoll collision layer
</member>
        <member name="P:Havok.HkRagdoll.InWorld">
Indicates whether all ragdoll parts were in the world
</member>
        <member name="P:Havok.HkRagdoll.IsActive">
Indicates if the ragdoll system is active
</member>
        <member name="P:Havok.HkRagdoll.WorldMatrixInverted">
Ragdoll system world matrix
</member>
        <member name="P:Havok.HkRagdoll.WorldMatrix">
Ragdoll system world matrix
</member>
        <member name="P:Havok.HkRagdoll.Shapes">
Get the list of the shapes
</member>
        <member name="P:Havok.HkRagdoll.Constraints">
Get the list of constraints in the system
</member>
        <member name="P:Havok.HkRagdoll.RagdollConstraintsData">
Get the list of ragdoll constraints data
</member>
        <member name="P:Havok.HkRagdoll.LocalTransforms">
Get the ragdoll bones local transforms - relative to the ragdoll world
</member>
        <member name="P:Havok.HkRagdoll.RigTransforms">
Get the ragdoll bones rig transforms - WorldMatrices of rigid bodies as when they were loaded
</member>
        <member name="M:Havok.HkRagdollConstraintData.SetConeLimitStabilization(System.Boolean)">
Enable/disable cone limit stabilization.
</member>
        <member name="P:Havok.HkConstraintData.InertiaStabilizationFactor">
Gets/Sets the inertia stabilization factor.
Returns HK_FAILURE if stabilization factor is not supported by this constraint.		
</member>
        <member name="P:Havok.HkConstraintData.BreachImpulse">
Sets/Gets the impulse above which the solver fires constraint - impulse - limit breached callbacks.		
</member>
        <member name="M:Havok.HkKeyFrameUtility.ApplyHardKeyFrameAsynchronously(VRageMath.Vector4@,VRageMath.Quaternion@,System.Single,Havok.HkRigidBody)">
This should be used instead of hkpKeyFrameUtility::applyHardKeyFrame() when stepping asynchronously.


This should be used instead of hkpKeyFrameUtility::applyHardKeyFrame() when stepping asynchronously.

</member>
        <member name="M:Havok.HkKeyFrameUtility.ApplyHardKeyFrame(VRageMath.Vector4@,VRageMath.Quaternion@,System.Single,Havok.HkRigidBody)">
Change velocities of body to move to future(position, orientation) in time deltaTime.


Change velocities of body to move to future(position, orientation) in time deltaTime.

</member>
        <member name="M:Havok.HkKeyFrameUtility.ApplySoftKeyFrame(Havok.HkKeyFrameInfo,Havok.HkAccelerationInfo,System.Single,System.Single,Havok.HkRigidBody)">
Change velocities of body to move towards keyframe given acceleration guidelines, in time deltaTime.


Change velocities of body to move towards keyframe given acceleration guidelines, in time deltaTime.

</member>
        <member name="P:Havok.HkAccelerationInfo.MaxAllowedDistance">
If the distance between object and keyframe gets bigger than the max allowed distance, the object is immediately "warped" to the correct keyframe position / orientation, and corresponding velocities.

</member>
        <member name="P:Havok.HkAccelerationInfo.MaxAngularAcceleration">
The maximum angular accelerations(m / sec2).

</member>
        <member name="P:Havok.HkAccelerationInfo.MaxLinearAcceleration">
Maximum linear acceleration.

</member>
        <member name="P:Havok.HkAccelerationInfo.AngularVelocityFactor">
This parameter controls the velocity control of applySoftKeyFrame, its units are 1 / Time.

</member>
        <member name="P:Havok.HkAccelerationInfo.LinearVelocityFactor">
This parameter controls the velocity control of applySoftKeyFrame, its units are 1 / Time.

</member>
        <member name="P:Havok.HkAccelerationInfo.AngularPositionFactor">
This parameter controls the angular stiffness of applySoftKeyFrame, its units are 1 / Time.

</member>
        <member name="P:Havok.HkAccelerationInfo.LinearPositionFactor">
This parameter controls the linear stiffness of applySoftKeyFrame, its units are 1 / Time.

</member>
        <member name="T:Havok.HkAccelerationInfo">
Specifies acceleration details for hkpKeyFrameUtility::applySoftKeyFrame()

</member>
        <member name="P:Havok.HkKeyFrameInfo.AngularVelocity">
The current angular velocity.

</member>
        <member name="P:Havok.HkKeyFrameInfo.LinearVelocity">
The current velocity.

</member>
        <member name="P:Havok.HkKeyFrameInfo.Orientation">
The current orientation.

</member>
        <member name="P:Havok.HkKeyFrameInfo.Position">
The current "centre-of-mass" position of a keyframe.

</member>
        <member name="M:Havok.HkKeyFrameInfo.FastSetUsingPositionOrientationPair(VRageMath.Vector4@,VRageMath.Quaternion@,VRageMath.Vector4@,VRageMath.Quaternion@,System.Single)">
Convenience function for setting velocities if you only have "centre-of-mass" positions and orientations.Uses approximation of angular velocity.

</member>
        <member name="M:Havok.HkKeyFrameInfo.SetUsingPositionOrientationPair(VRageMath.Vector4@,VRageMath.Quaternion@,VRageMath.Vector4@,VRageMath.Quaternion@,System.Single)">
Convenience function for setting velocities if you only have "centre-of-mass" positions and orientations.

</member>
        <member name="T:Havok.HkKeyFrameInfo">
Specifies keyframe details for hkpKeyFrameUtility::applySoftKeyFrame. 
NOTE: All the positions for SOFT keyframes must be "centre-of-mass" positions. To convert a Local position to a "centre-of-mass" position, you must add on rb-&gt;getCentreOfMassLocal() rotated by m_orientation. It contains the current keyframe position, orientation, angular velocity, and linear velocity. It also provides functions for calculating the angular and linear velocities if you only have the current and target positions and orientations.

</member>
        <member name="M:Havok.HkRigidBody.OnReaddedToWorld">
Destruction will sometimes remove entities from world momentarily.
This method exists to fix stuff up after that.

</member>
        <member name="M:Havok.HkRigidBody.GetIslandSize">
            <summary>
Get the number of entities in the simulation island that contains this rigidBody.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyTorque(System.Single,VRageMath.Vector3)">
            <summary>
Applies torque to rigid body.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyForce(System.Single,VRageMath.Vector3,VRageMath.Vector3)">
            <summary>
Applies world force to specific point of rigid body in world space.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyForce(System.Single,VRageMath.Vector3)">
            <summary>
Applies world force to center of mass of rigid body.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyAngularImpulse(VRageMath.Vector3)">
            <summary>
Applies angular impulse to rigid body.
</summary>
            <summary>
Apply an instantaneous change in angular velocity around center of mass.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyPointImpulse(VRageMath.Vector3,VRageMath.Vector3)">
            <summary>
Apply an impulse at the point p in world space.
</summary>
            <summary>
Apply an impulse at the point p in world space.
</summary>
        </member>
        <member name="M:Havok.HkRigidBody.ApplyLinearImpulse(VRageMath.Vector3)">
            <summary>
Applies linear impulse to center of mass of rigid body.
</summary>
            <summary>
Apply an impulse to the center of mass.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Restitution">
            <summary>
Gets or sets restitution of rigid body when coliding.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Friction">
            <summary>
Gets or sets friction of rigid body when coliding.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.AllowedPenetrationDepth">
            <summary />
        </member>
        <member name="P:Havok.HkRigidBody.MaxAngularVelocity">
            <summary>
Gets or sets maximal velocity of rigid body.
The units used here are radians per second.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.MaxLinearVelocity">
            <summary>
Gets or sets maximal velocity of rigid body.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.AngularDamping">
            <summary>
Gets or sets angular damping of rigid body. Default = 0.05
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.LinearDamping">
            <summary>
Gets or sets linear damping of rigid body. Default = 0
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.DeltaAngle">
            <summary>
Gets the value of (angular velocity * dt) which was used in the last integration step.
Can be used to detect if a rigid body is still when constrained (AngularVelocity IS NOT equal to zero in this case)
</summary>
Note: W component is equal to the length of the 3D vector made by X,Y,Z
</member>
        <member name="P:Havok.HkRigidBody.AngularVelocity">
            <summary>
Gets or sets angular velocity of rigid body at center of mass.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.LinearVelocity">
            <summary>
Gets or sets linear velocity of rigid body at center of mass.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.CenterOfMassWorld">
            <summary>
Gets of sets Center of Mass in world space of the rigid body.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.InverseInertiaTensor">
            <summary>
Gets inverse inertia tensor in local space of rigid body
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.InertiaTensor">
            <summary>
Gets inertia tensor in local space of rigid body
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.CenterOfMassLocal">
            <summary>
Gets of sets Center of Mass in local space of the rigid body. Default = 0,0,0
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Mass">
            <summary>
Gets or sets mass of the rigid body. Default = 1
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Motion">
            <summary>
Gets motion, use motion to set velocity, impulse, position and rotation without activating the body
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Position">
            <summary>
Gets of sets position of rigid body.
</summary>
        </member>
        <member name="P:Havok.HkRigidBody.Rotation">
            <summary>
Gets of sets rotation of rigid body.
</summary>
        </member>
        <member name="D:Havok.HkRigidBody.BodyReference">
Internal body reference.

</member>
        <member name="T:Havok.BreakLogicHandler">
            <summary>
Break off logic handler, default behavior is to return UseLimit
</summary>
        </member>
        <member name="F:Havok.HkBreakOffPointInfo.ContactPointDirection">
            <summary>
Either +1 or -1
</summary>
        </member>
        <member name="F:Havok.HkBreakOffPointInfo.BreakingImpulse">
            <summary>
The impulse which caused the breaking.
</summary>
        </member>
        <member name="F:Havok.HkBreakOffPointInfo.IsContact">
            <summary>
If a contact force limit is exceeded, this is set to true, otherwise a constraint impulse limit has been exceeded.
</summary>
        </member>
        <member name="M:Havok.HkContactSoundQueue.getContacts(Havok.HkContactSoundUnmanagedData**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get sound contacts recorded in this queue.

</member>
        <member name="M:Havok.HkContactSoundQueue.report(hkpContactPointEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Report contact.

@return Weather the contact created a new entry or not.

</member>
        <member name="T:Havok.HkContactSoundQueue">
Contact sound queue.

The contact sound queue works by queueing and clustering contacts between bodies.
The queued data is then passed at once to the managed engine where it can be analyzed at once.

The clustering algorithm works by selecting the most energetic contacts around a centroid.

This centroid is the average position of all contacts that are in it's vicinity.
This centroid is recalculated every time an item is included in the cluster, but no point in the cluster
will ever be further from the centroid than it's threshold.

</member>
        <member name="M:glm.unpackHalf2x16(System.UInt32)">
Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values,
interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification,
and converting them to 32-bit floating-point values.
The first component of the vector is obtained from the 16 least-significant bits of v;
the second component is obtained from the 16 most-significant bits of v.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackHalf2x16.xml">GLSL unpackHalf2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packHalf2x16(glm.vec&lt;0x2,System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns an unsigned integer obtained by converting the components of a two-component floating-point vector
to the 16-bit floating-point representation found in the OpenGL Specification,
and then packing these two 16- bit integers into a 32-bit unsigned integer.
The first vector component specifies the 16 least-significant bits of the result;
the second component specifies the 16 most-significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packHalf2x16.xml">GLSL packHalf2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackDouble2x32(System.Double)">
Returns a two-component unsigned integer vector representation of v.
The bit-level representation of v is preserved.
The first component of the vector contains the 32 least significant bits of the double;
the second component consists the 32 most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackDouble2x32.xml">GLSL unpackDouble2x32 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packDouble2x32(glm.vec&lt;0x2,System.UInt32,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a double-qualifier value obtained by packing the components of v into a 64-bit value.
If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating point value is unspecified.
Otherwise, the bit- level representation of v is preserved.
The first vector component specifies the 32 least significant bits;
the second component specifies the 32 most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packDouble2x32.xml">GLSL packDouble2x32 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackSnorm4x8(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackSnorm4x8: clamp(f / 127.0, -1, +1)

The first component of the returned vector will be extracted from the least significant bits of the input;
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm4x8.xml">GLSL unpackSnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackUnorm4x8(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackUnorm4x8: f / 255.0

The first component of the returned vector will be extracted from the least significant bits of the input;
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm4x8.xml">GLSL unpackUnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackSnorm2x16(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackSnorm2x16: clamp(f / 32767.0, -1, +1)

The first component of the returned vector will be extracted from the least significant bits of the input;
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm2x16.xml">GLSL unpackSnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackUnorm2x16(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers.
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackUnorm2x16: f / 65535.0

The first component of the returned vector will be extracted from the least significant bits of the input;
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm2x16.xml">GLSL unpackUnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packSnorm4x8(glm.vec&lt;0x4,System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packSnorm4x8:	round(clamp(c, -1, +1) * 127.0)

The first component of the vector will be written to the least significant bits of the output;
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packUnorm4x8(glm.vec&lt;0x4,System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packUnorm4x8:	round(clamp(c, 0, +1) * 255.0)

The first component of the vector will be written to the least significant bits of the output;
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packSnorm2x16(glm.vec&lt;0x2,System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packSnorm2x16: round(clamp(v, -1, +1) * 32767.0)

The first component of the vector will be written to the least significant bits of the output;
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm2x16.xml">GLSL packSnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packUnorm2x16(glm.vec&lt;0x2,System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@addtogroup core_func_packing
@{
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values.
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packUnorm2x16: round(clamp(c, 0, +1) * 65535.0)

The first component of the vector will be written to the least significant bits of the output;
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm2x16.xml">GLSL packUnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="D:glm.highp_mat2x2">
2 columns of 2 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x2">
2 columns of 2 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x2">
2 columns of 2 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat2">
2 columns of 2 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2">
2 columns of 2 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2">
@addtogroup core_matrix_precision
@{
2 columns of 2 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat2">
2 columns of 2 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat2x2">
@addtogroup core_matrix
@{
2 columns of 2 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat2x2">
2 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x2">
2 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x2">
2 columns of 2 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat2">
2 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2">
2 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2">
@addtogroup core_matrix_precision
@{
2 columns of 2 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat2">
2 columns of 2 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat2x2">
@addtogroup core_matrix
@{
2 columns of 2 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="M:glm.uintBitsToFloat(System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a floating-point value corresponding to a
unsigned integer encoding of a floating-point value.
If an inf or NaN is passed in, it will not signal, and the
resulting floating point value is unspecified. Otherwise,
the bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/uintBitsToFloat.xml">GLSL uintBitsToFloat man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.intBitsToFloat(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a floating-point value corresponding to a signed
integer encoding of a floating-point value.
If an inf or NaN is passed in, it will not signal, and the
resulting floating point value is unspecified. Otherwise,
the bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/intBitsToFloat.xml">GLSL intBitsToFloat man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.floatBitsToUint(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a unsigned integer value representing
the encoding of a floating-point value. The floatingpoint
value's bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToUint.xml">GLSL floatBitsToUint man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.floatBitsToInt(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a signed integer value representing
the encoding of a floating-point value. The floating-point
value's bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToInt.xml">GLSL floatBitsToInt man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="D:glm.highp_mat4x4">
4 columns of 4 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x4">
4 columns of 4 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x4">
4 columns of 4 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat4">
4 columns of 4 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4">
4 columns of 4 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4">
@addtogroup core_matrix_precision
@{
4 columns of 4 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat4">
4 columns of 4 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat4x4">
@ingroup core_matrix
@{
4 columns of 4 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat4x4">
4 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x4">
4 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x4">
4 columns of 4 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat4">
4 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4">
4 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4">
@addtogroup core_matrix_precision
@{
4 columns of 4 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat4">
4 columns of 4 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat4x4">
@addtogroup core_matrix
@{
4 columns of 4 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat4x3">
4 columns of 3 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x3">
4 columns of 3 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x3">
@addtogroup core_matrix_precision
@{
4 columns of 3 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat4x3">
@addtogroup core_matrix
@{
4 columns of 3 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat4x3">
4 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x3">
4 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x3">
@addtogroup core_matrix_precision
@{
4 columns of 3 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat4x3">
@addtogroup core_matrix
@{
4 columns of 3 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat4x2">
4 columns of 2 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x2">
4 columns of 2 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x2">
@addtogroup core_matrix_precision
@{
4 columns of 2 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat4x2">
@addtogroup core_matrix
@{
4 columns of 2 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat4x2">
4 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x2">
4 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x2">
@addtogroup core_matrix_precision
@{
4 columns of 2 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat4x2">
@addtogroup core_matrix
@{
4 columns of 2 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat3x4">
3 columns of 4 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x4">
3 columns of 4 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x4">
@addtogroup core_matrix_precision
@{
3 columns of 4 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat3x4">
@addtogroup core_matrix
@{
3 columns of 4 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat3x4">
3 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x4">
3 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x4">
@addtogroup core_matrix_precision
@{
3 columns of 4 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat3x4">
@addtogroup core_matrix
@{
3 columns of 4 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat3x3">
3 columns of 3 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x3">
3 columns of 3 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x3">
3 columns of 3 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat3">
3 columns of 3 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3">
3 columns of 3 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3">
@addtogroup core_matrix_precision
@{
3 columns of 3 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat3">
3 columns of 3 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat3x3">
@addtogroup core_matrix
@{
3 columns of 3 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat3x3">
3 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x3">
3 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x3">
3 columns of 3 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat3">
3 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3">
3 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3">
@addtogroup core_matrix_precision
@{
3 columns of 3 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat3">
3 columns of 3 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat3x3">
@addtogroup core_matrix
@{
3 columns of 3 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat3x2">
3 columns of 2 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x2">
3 columns of 2 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x2">
@addtogroup core_matrix_precision
@{
3 columns of 2 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat3x2">
@addtogroup core
@{
3 columns of 2 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat3x2">
3 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x2">
3 columns of 2 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x2">
@addtogroup core_matrix_precision
@{
3 columns of 2 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat3x2">
@addtogroup core_matrix
@{
3 columns of 2 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat2x4">
2 columns of 4 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x4">
2 columns of 4 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x4">
@addtogroup core_matrix_precision
@{
2 columns of 4 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat2x4">
@addtogroup core_matrix
@{
2 columns of 4 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat2x4">
2 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x4">
2 columns of 4 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x4">
@addtogroup core_matrix_precision
@{
2 columns of 4 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat2x4">
@addtogroup core_matrix
@{
2 columns of 4 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat2x3">
2 columns of 3 components matrix of single-precision floating-point numbers using high precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x3">
2 columns of 3 components matrix of single-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x3">
@addtogroup core_matrix_precision
@{
2 columns of 3 components matrix of single-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat2x3">
@addtogroup core_matrix
@{
2 columns of 3 components matrix of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat2x3">
2 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x3">
2 columns of 3 components matrix of double-precision floating-point numbers using medium precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x3">
@addtogroup core_matrix_precision
@{
2 columns of 3 components matrix of double-precision floating-point numbers using low precision arithmetic in term of ULPs.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dmat2x3">
@addtogroup core_matrix
@{
2 columns of 3 components matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.lowp_uvec4">
4 components vector of low qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec4">
4 components vector of medium qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec4">
@addtogroup core_vector_precision
@{
4 components vector of high qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.uvec4">
@addtogroup core_vector
@{
4 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_ivec4">
4 components vector of low qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec4">
4 components vector of medium qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec4">
@addtogroup core_vector_precision
@{
4 components vector of high qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.ivec4">
@addtogroup core_vector
@{
4 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_dvec4">
4 components vector of low double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec4">
4 components vector of medium double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec4">
@addtogroup core_vector_precision
@{
4 components vector of high double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dvec4">
@addtogroup core_vector
@{
4 components vector of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_vec4">
4 components vector of low single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_vec4">
4 components vector of medium single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_vec4">
@addtogroup core_vector_precision
@{
4 components vector of high single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.vec4">
@addtogroup core_vector
@{
4 components vector of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_bvec4">
4 components vector of low qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec4">
4 components vector of medium qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec4">
@addtogroup core_vector_precision
@{
4 components vector of high qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.bvec4">
@addtogroup core_vector
@{
4 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_uvec3">
3 components vector of low qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec3">
3 components vector of medium qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec3">
@addtogroup core_vector_precision
@{
3 components vector of high qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.uvec3">
@addtogroup core_vector
@{
3 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_ivec3">
3 components vector of low qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec3">
3 components vector of medium qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec3">
@addtogroup core_vector_precision
@{
3 components vector of high qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.ivec3">
@addtogroup core_vector
@{
3 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_dvec3">
3 components vector of low double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec3">
3 components vector of medium double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec3">
@addtogroup core_vector_precision
@{
3 components vector of high double-qualifier floating-point numbers.
There is no guarantee on the actual qualifier.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dvec3">
@addtogroup core_vector
@{
3 components vector of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_vec3">
3 components vector of low single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_vec3">
3 components vector of medium single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_vec3">
@addtogroup core_vector_precision
@{
3 components vector of high single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.vec3">
@addtogroup core_vector
@{
3 components vector of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_bvec3">
3 components vector of low qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec3">
3 components vector of medium qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec3">
@addtogroup core_vector_precision
@{
3 components vector of high qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.bvec3">
@addtogroup core_vector
@{
3 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_uvec2">
2 components vector of low qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec2">
2 components vector of medium qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec2">
@addtogroup core_vector_precision
@{
2 components vector of high qualifier unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.uvec2">
@addtogroup core_vector
@{
2 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_ivec2">
2 components vector of low qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec2">
2 components vector of medium qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec2">
@addtogroup core_vector_precision
@{
2 components vector of high qualifier signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.ivec2">
@addtogroup core_vector
@{
2 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_dvec2">
2 components vector of low double-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec2">
2 components vector of medium double-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec2">
@addtogroup core_vector_precision
@{
2 components vector of high double-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.dvec2">
@addtogroup core_vector
@{
2 components vector of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_vec2">
2 components vector of low single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_vec2">
2 components vector of medium single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_vec2">
@addtogroup core_vector_precision
@{
2 components vector of high single-qualifier floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.vec2">
@addtogroup core_vector
@{
2 components vector of single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_bvec2">
2 components vector of low qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec2">
2 components vector of medium qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec2">
@addtogroup core_vector_precision
@{
2 components vector of high qualifier bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.bvec2">
@addtogroup core_vector
@{
2 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="T:glm.qualifier">
Qualify GLM types in term of alignment (packed, aligned) and precision in term of ULPs (lowp, mediump, highp)
</member>
        <member name="M:Havok.HkContactPointEvent.UpdateVelocities(System.Int32)">
            <summary>
Call after modifying body velocities
</summary>
        </member>
        <member name="M:Havok.HkContactPointEvent.AccessVelocities(System.Int32)">
            <summary>
Call before modifying body velocities
</summary>
        </member>
        <member name="P:HkContactPoint.Normal">
            <summary>
Points from B to A
</summary>
        </member>
        <member name="P:HkContactPoint.NormalAndDistance">
            <summary>
Points from B to A
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Shape">
            <summary>
The collision detection representation for this entity.
This defaults to NULL, and must be set before constructing a HkpRigidBody.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.AutoRemoveLevel">
            <summary>
This is a user flag which you can set to give you a hint as to which objects to remove from
the simulation if the memory overhead becomes too high. It defaults to 0.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.QualityType">
            <summary>
The quality type, used to specify when to use continuous physics.
This defaults to Invalid.
If you add a hkpRigidBody to the hkpWorld, this type automatically gets converted to either
Fixed, Keyframed or Debris.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.SolverDeactivation">
            <summary>
Allows you to enable an extra single object deactivation schema. 
That means the engine will try to "deactivate" single objects (not just entire islands)
if those objects get very slow.
This does not save CPU, however it can reduce small movements in big stacks of objects dramatically. 
This defaults to Low.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.MotionType">
            <summary>
The initial motion type of the body.
This defaults to HkpMotionType.Dynamic
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.AllowedPenetrationDepth">
            <summary>
The maximum allowed penetration for this object. The default is -1.
This is a hint to the engine to see how much CPU the engine should
invest to keep this object from penetrating. A good choice is 5% - 20% of the
smallest diameter of the object.  Setting the initial value less than zero
allows the penetration depth to be estimated by the RigidBody upon creation.
This estimated value is 1/5th of the smallest dimension of the object's radius. 
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.MaxAngularVelocity">
            <summary>
The maximum angular velocity of the body (in rad/s).
This defaults to 200.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.MaxLinearVelocity">
            <summary>
The maximum linear velocity of the body (in m/s).
This defaults to 200. 
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Restitution">
            <summary>
The initial restitution of the body.
This defaults to 0.4.
If the restitution is not 0.0 the object will need extra CPU
for all new collisions. Try to set restitution to 0 for maximum 
performance (e.g. collapsing buildings)
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Friction">
            <summary>
The initial friction of the body.
This defaults to 0.5.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.AngularDamping">
            <summary>
The initial angular damping of the body.
This defaults to 0.05.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.LinearDamping">
            <summary>
The initial linear damping of the body.
This defaults to 0.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Mass">
            <summary>
The mass of the body.
This defaults to 1.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.CenterOfMass">
            <summary>
The center of mass in the local space of the rigid body.
This defaults to 0,0,0.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.AngularVelocity">
            <summary>
The initial angular velocity of the body.
This defaults to 0,0,0.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.LinearVelocity">
            <summary>
The initial linear velocity of the body.
This defaults to 0,0,0.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Rotation">
            <summary>
The initial rotation of the body.
This defaults to the Identity quaternion.
</summary>
        </member>
        <member name="P:Havok.HkRigidBodyCinfo.Position">
            <summary>
The initial position of the body.
This defaults to 0,0,0.
</summary>
        </member>
        <member name="T:Havok.HkRigidBodyCinfo">
            <remarks>
A class containing all the information needed to construct a rigid body.
</remarks>
        </member>
        <member name="F:Havok.HkResponseModifiers.AdditionalSizeModifiers">
those modifiers which require additional schema size.
</member>
        <member name="F:Havok.HkResponseType.None">
Do nothing, ignore all the results.
</member>
        <member name="F:Havok.HkResponseType.Reporting">
Deprecated. Instead of using this, you can disable contacts from a hkpContactListener.
</member>
        <member name="F:Havok.HkResponseType.SimpleContact">
Do normal collision resolution.
</member>
        <member name="T:Havok.HkSolverDeactivation">
            <summary>
A list of possible solver deactivation settings. This value defines how the
solver deactivates objects. The solver works on a per object basis. 	
Note: Solver deactivation does not save CPU, but reduces creeping of
movable objects in a pile quite dramatically.
</summary>
        </member>
        <member name="F:Havok.HkSolverDeactivation.Max">
            <summary>Very fast deactivation, visible artifacts.</summary>
        </member>
        <member name="F:Havok.HkSolverDeactivation.High">
            <summary>Fast deactivation, visible artifacts.</summary>
        </member>
        <member name="F:Havok.HkSolverDeactivation.Medium">
            <summary>Normal deactivation, no serious visible artifacts in most cases.</summary>
        </member>
        <member name="F:Havok.HkSolverDeactivation.Low">
            <summary>Very conservative deactivation, typically no visible artifacts.</summary>
        </member>
        <member name="F:Havok.HkSolverDeactivation.Off">
            <summary>No solver deactivation.</summary>
        </member>
        <member name="T:Havok.HkCollidableQualityType">
            <summary>
This type is used to specify the quality type for collidables (used by hkpRigidBody)
This is mainly used to identify objects, which require the more expensive
continuous simulation (compared to the faster, Havok2 style discrete) simulation.
See the continuous simulation user guide, of the hkpCollisionDispatcher for more details.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.KeyframedReporting">
            <summary>
Use this for moving objects with infinite mass which should report contact points and TOI-collisions against all other bodies, including other fixed and keyframed bodies.
Note that only non-TOI contact points are reported in collisions against debris-quality objects.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Character">
            <summary>
Use this for rigid body character controllers.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Bullet">
            <summary>
Use this for very fast objects.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Critical">
            <summary>
Use this for all objects, which you cannot afford to tunnel through
the world at all.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Moving">
            <summary>
Use this for moving bodies, which should not leave the world, 
but you rather prefer those objects to tunnel through the world than
dropping frames because the engine.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Debris">
            <summary>
Use this for all you debris objects.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Keyframed">
            <summary>
Use this for moving objects with infinite mass. 
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Fixed">
            <summary>
Use this for fixed bodies.
</summary>
        </member>
        <member name="F:Havok.HkCollidableQualityType.Invalid">
            <summary>
Invalid or unassinged type. If you add a hkpRigidBody to the hkpWorld,
this type automatically gets converted to either
Fixed, Keyframed or Debris.
</summary>
        </member>
        <member name="T:Havok.HkMotionType">
            <summary>
A list of all motion types. The motion type of a hkpRigidBody determines what
happens when the rigid body is simulated. 
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Character">
A specialized motion used for character controllers
</member>
        <member name="F:Havok.HkMotionType.Thin_Box_Inertia">
            <summary>
A box inertia motion which is optimized for thin boxes and has less stability problems.
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Fixed">
            <summary>
This motion type is used for the static elements of a game scene, e.g. the
landscape. Fixed rigid bodies are treated in a special way by the system. They
have the same effect as a rigid body with a motion of type Keyframed
and velocity 0, however they are much faster to use, incurring no simulation
overhead, except in collision with moving bodies.
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Keyframed">
            <summary>
Simulation is not performed as a normal rigid body. During a simulation step,
the velocity of the rigid body is used to calculate the new position of the
rigid body, however the velocity is NOT updated. The user can keyframe a rigid
body by setting the velocity of the rigid body to produce the desired keyframe
positions. The hkpKeyFrameUtility class can be used to simply apply keyframes
in this way. The velocity of a keyframed rigid body is NOT changed by the
application of impulses or forces. The keyframed rigid body has an infinite
mass when viewed by the rest of the system.
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Box_Inertia">
            <summary>
Simulation is performed using a box inertia tensor. The non-diagonal elements
of the inertia tensor are set to zero. This is slower than the
Sphere_Inertia motions, however it can produce more accurate results,
especially for long thin objects.
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Sphere_Inertia">
            <summary>
Simulation is performed using a sphere inertia tensor. (A multiple of the
Identity matrix). The highest value of the diagonal of the rigid body's
inertia tensor is used as the spherical inertia.
</summary>
        </member>
        <member name="F:Havok.HkMotionType.Dynamic">
            <summary>
A fully-simulated, movable rigid body. At construction time the engine checks
the input inertia and selects Sphere_Inertia or Box_Inertia as
appropriate.
</summary>
        </member>
        <member name="F:Havok.HkReferencePolicy.TakeOwnership">
            <summary>
Reference count remains as it was.
</summary>
        </member>
        <member name="F:Havok.HkReferencePolicy.None">
            <summary>
Increments reference count.
</summary>
        </member>
        <member name="M:Havok.HkReferenceBase.Resurrect">
            <summary>
Use this method to keep native object alive. Test IsNativeAlive before calling this method.
Main usage of this method is when you need to keep objects received from Havoc in some handler.
</summary>
        </member>
        <member name="P:Havok.HkReferenceBase.OwnsReference">
            <summary>
Returns true when this object holds active reference to native object and prevents its collection.
When false, it can still be resurrected (when IsNativeAlive is true)
</summary>
        </member>
        <member name="P:Havok.HkReferenceBase.IsNativeAlive">
            <summary>
Returns true when native object is still alive.
When true, Resurrect can be called.
</summary>
        </member>
        <member name="M:Havok.HkReferenceBase.Finalize">
            <summary>
Finalizer, checks whether ownership of native object was released.
Even when not, there's nothing to do, because finalizer cannot release native object (it runs on different thread)
</summary>
        </member>
        <member name="M:Havok.HkReferenceBase.Dispose">
            <summary>
Releases ownership of native object. Native object may or may not be reclaimed.
It depends whether this object held last reference or not.
</summary>
        </member>
        <member name="M:Havok.HkReferenceBase.#ctor(hkReferencedObject*)">
            <summary>
Initializes a new instance of the HkReferenceBase class.
Argument must be derived from ManagedReference!
</summary>
        </member>
        <member name="T:Havok.HkReferenceBase">
            <summary>
Stores native object derived from hkReferenceObject.
Handles object lifetime, object is destroyed when there's no managed and no native references.
It doesn't matter whether managed references are release first or not.
Managed references are released by calling Dispose().
</summary>
        </member>
        <member name="P:Havok.HkBaseSystem.IsOutOfMemory">
            <summary>
Whether the Havok memory system has run out of space in the heap.
</summary>
            <remarks>
When the system runs out of memory the simulation might halt due to not having enough room for the solver state.
</remarks>
        </member>
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_FIXED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_DEBRIS_SIMPLE_TOI'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_MOVING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BodyQualityType.QUALITY_CRITICAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:Havok.HkdBreakableShape.BreakableMaterialStrenght'. -->
    </members>
</doc>