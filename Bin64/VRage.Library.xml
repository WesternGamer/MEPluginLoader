<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage.Library</name>
    </assembly>
    <members>
        <member name="M:VRage.Algorithms.IMyPathEdge`1.GetOtherVertex(`0)">
            <summary>
            Returns the other vertex on this edge.
            Can return null, if the edge is a loop or if the edge is not traversable
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.EstimateDistanceTo(VRage.Algorithms.IMyPathVertex{`0})">
            <summary>
            Heuristic on the shortest path to another vertex. Used for finding the shortest path.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetNeighborCount">
            <summary>
            Returns the number of neighbouring vertices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Algorithms.IMyPathVertex`1.GetNeighbor(System.Int32)" -->
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetEdge(System.Int32)">
            <summary>
            Gets N-th edge of this vertex.
            Must be consistent with the GetNeighbor() function.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.MyPathFindingSystem`1.PrepareTraversal(`0,System.Predicate{`0},System.Predicate{`0},System.Predicate{VRage.Algorithms.IMyPathEdge{`0}})">
            <summary>
            Has to be called before any traversal of the pathfinding system using enumerators.
            
            Several predicates can be supplied to the system that change the behavior of the traversal.
            </summary>
            <param name="startingVertex">The vertex from which the traversal starts</param>
            <param name="vertexFilter">If set, this predicate is applied to the output vertices so that we only get those that we are interested in.</param>
            <param name="vertexTraversable">
                This predicate allows to make vertices of the graph untraversable, blocking the paths through them.
                It is guaranteed to be called only once on every vertex when enumerating the graph or finding reachable vertices, but
                for pathfinding functions, this guarantee is no longer valid.
            </param>
            <param name="edgeTraversable">This predicate allows to make edges untraversable, blocking the paths through them.</param>
        </member>
        <member name="T:VRage.Algorithms.MyUnionFind">
            <summary>
             Fast representation for disjoint sets.
            
            This data structure guarantees virtually constant time operations
            for union and finding the representative element of disjoint sets.
            </summary>
            
            Still wondering weather the iterator makes sense
        </member>
        <member name="T:VRage.Library.Algorithms.SequenceIdGenerator">
            <summary>
            Generates IDs sequentially and reuses old IDs which are returned to pool by calling Return method.
            Protection count and time can be set to protect returned IDs. 
            Protection is useful especially in multiplayer where clients can still have objects with those IDs.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_maxId">
            <summary>
            Max used id, zero is reserved and never used.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_protecionCount">
            <summary>
            Minimal number of items in reuse queue until first item can be taken.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_reuseProtectionTime">
            <summary>
            Minimal time if item spent in reuse queue until it can be returned.
            Units are arbitrary
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_timeFunc">
            <summary>
            Function which returns current time, units are arbitrary and same as reuse protection time.
            </summary>
        </member>
        <member name="P:VRage.Library.Algorithms.SequenceIdGenerator.ReservedCount">
            <summary>
            Number of reserved ids, zero is also reserved, but not counted.
            </summary>
        </member>
        <member name="M:VRage.Library.Algorithms.SequenceIdGenerator.CreateWithStopwatch(System.TimeSpan,System.Int32)">
            <summary>
            Creates new sequence id generator with stopwatch to measure protection time.
            </summary>
            <param name="reuseProtectionTime">Time to protect returned IDs.</param>
            <param name="reuseProtectionCount">Minimum number of IDs in protection queue, before first ID will be reused.</param>
        </member>
        <member name="M:VRage.Library.Algorithms.SequenceIdGenerator.Reserve(System.UInt32)">
            <summary>
            Reserves first several IDs, so it's never returned by generator.
            Zero is never returned, when reservedIdCount is 2, IDs 1 and 2 won't be ever returned.
            </summary>
            <param name="reservedIdCount">Number of reserved IDs which will be never returned by generator.</param>
        </member>
        <member name="M:VRage.Library.Collections.BitReaderWriter.ReadData(VRage.Library.Collections.IBitSerializable,System.Boolean)">
            <summary>
            Returns false when validation was required and failed, otherwise true.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.BitStream">
            <summary>
            Stream which writes data based on bits.
            When writing, buffer must be reset to zero to write values correctly, this is done by ResetWrite() methods or SetPositionAndClearForward()
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.BitStream.ConsistencyChecks">
            <summary>
            Whether data consistency checks are enabled.
            </summary>
            <remarks>This toggle has no effect in non-debug builds since the checks are conditional on the <c>DEBUG</c> flag (to avoid a bandwidth and performance impact). Changing this value at runtime can be dangerous. Always make sure the client and server have it set the same.</remarks>
        </member>
        <member name="T:VRage.Library.Collections.BitStream.PrimitiveType">
            <summary>
            Types of primitives that can be serialized in a bit-stream.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SetBitPositionWrite(System.Int32)">
            <summary>
            Use when you need to overwrite part of the data.
            Sets new bit position and clears everything from min(old position, new position) to end of stream.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteNormalizedSignedFloat(System.Single,System.Int32)">
            <summary>
            Writes uniform-spaced float within -1,1 range with specified number of bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariantSigned(System.Int32)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8 192 to 8 191 (inclusive), 16 bits.
            From -1 048 576 to 1 048 575, 24 bits.
            From -134 217 728 to 134 217 727, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariantSigned(System.Int64)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8192 to 8191 (inclusive), 16 bits.
            From -1048576 to 1048575, 24 bits.
            From -134217728 to 134217727, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariant(System.UInt32)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariant(System.UInt64)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteBytesBlit(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a buffer into the stream to be later reinterpreted as the streams content.
            </summary>
            <param name="bytes"></param>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ReadNormalizedSignedFloat(System.Int32)">
            <summary>
            Reads uniform-spaced float within -1,1 range with specified number of bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ReadPrefixLengthString(System.Char[]@,System.Text.Encoding)">
            <summary>
            Reads prefixed length string, returns number of characters read.
            Passed array is automatically resized when needed.
            </summary>
            <returns>Number of characters read.</returns>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ReadBytesBlit(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a range of bytes from the stream into the provided buffer.
            </summary>
            <param name="bytes">The destination buffer.</param>
            <param name="start">The starting index in the destination buffer.</param>
            <param name="count">The number of bytes to read.</param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BitPosition">
            <summary>
            Read/write bit position in stream.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BitLength">
            <summary>
            Length of valid data (when reading) or buffer (when writing) in bits.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BytePosition">
            <summary>
            Position in stream round up to whole bytes.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.ByteLength">
            <summary>
            Length of valid data (when reading) or buffer (when writing) round up to whole bytes
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.OwnsBuffer">
            <summary>
            Returns true when owns buffers, always true when writing.
            May or may not own buffer when reading.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.Writing">
            <summary>
            True when stream is for writing.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead">
            <summary>
            Resets stream for reading (reads what was written so far).
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead(System.Byte[],System.Int32)">
            <summary>
            Resets stream for reading and copies data.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Resets stream for reading and copies data.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Resets stream for reading.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetWrite">
            <summary>
            Resets stream for writing.
            Uses internal buffer for writing, it's available as DataPointer.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.Int32@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8 192 to 8 191 (inclusive), 16 bits.
            From -1 048 576 to 1 048 575, 24 bits.
            From -134 217 728 to 134 217 727, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.Int64@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8192 to 8191 (inclusive), 16 bits.
            From -1048576 to 1048575, 24 bits.
            From -134217728 to 134217727, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.UInt32@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.UInt64@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.Serialize(System.Char@)">
            <summary>
            Writes char as UTF16, 2-byte value.
            For ASCII or different encoding, use SerializeByte() or SerializeBytes().
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeMemory(System.IntPtr,System.Int32)">
            <summary>
            Serializes fixed size memory region.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeMemory(System.Void*,System.Int32)">
            <summary>
            Serializes fixed size memory region.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixString(System.String@,System.Text.Encoding)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself in defined encoding.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixStringAscii(System.String@)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself encoded with ASCII encoding.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixStringUtf8(System.String@)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself encoded with UTF8 encoding.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixBytes(System.Byte[]@)">
            <summary>
            Serializes byte array length (as UInt32 variant) and bytes.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeBytes(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Serializes fixed-size byte array or it's part (length is NOT serialized).
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.BitReader">
            <summary>
            Lightweight bit reader which works on native pointer.
            Stores bit length and current position.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MonitorEnumerable`2">
            <summary>
            A wrapper for a regular enumerable object that protects it using the provided lock handle.
            </summary>
            <typeparam name="TLockHandle">The type of the lock handle. Value types get boxed and the end result is they are not usable, so only class types are allowed.</typeparam>
            <typeparam name="TItem">The type of the enumerable item.</typeparam>
            <remarks>
            The enumerator protects collection by locking using the provided lock object (via <see cref="M:System.Threading.Monitor.Enter(System.Object)"/>).
            The lock is released once the enumerator is disposed.
            </remarks>
        </member>
        <member name="F:VRage.Library.Collections.Concurrent.MyConcurrentCollectionPool`2.ConstructorCreator">
            <summary>
            Delegate capable of creating instances of the collection with the default comparer.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.Concurrent.MyConcurrentPool`1">
            <summary>
            Simple thread-safe pool.
            Can store external objects by calling return.
            Creates new instances when empty.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.DynamicSerializerDelegate">
            <summary>
            Dynamic object serializer, when writing, serializes object type.
            When reading deserializes object type and creates new instance.
            </summary>
            <param name="stream">Stream to read from or write to.</param>
            <param name="baseType">Hierarchy base type of dynamically serialized object, can be used to select serialization method (e.g. object builders have something special).</param>
            <param name="obj">Object whose type to write or read and instantiate.</param>
        </member>
        <member name="M:VRage.Library.Collections.IBitSerializable.Serialize(VRage.Library.Collections.BitStream,System.Boolean)">
            <summary>
            When reading, returns false when validation was required and failed, otherwise true.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyBucketedPool`1">
            <summary>
            A bucketed pool that allows collections or other objects with variable size to be pooled more efficiently.
            </summary>
            <remarks>
            Using the provided bucketing function this class will separate pooled objects so that whenever
            they are requested we can provide an instance that is large enough for the required use.
            
            In order to support any type of variable size object (and not just collections) the user has
            to provide their own callback to find the sie of an entry.
            </remarks>
            <typeparam name="TElement">The type of the pooled object.</typeparam>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_entries">
            <summary>
            List of cached entries.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_buckets">
            <summary>
            Mapping of entry size to per size buckets.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_sizeToBucket">
            <summary>
            Mapping of element size to bucket key.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_elementSize">
            <summary>
            Function used to retrieve the element size.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_discardCallback">
            <summary>
            Callback invoked when an element is discarded.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_maxSize">
            <summary>
            Maximum buffered size in total element length.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_overflowTolerance">
            <summary>
            Amount by which we can exceed m_maxSize (as long as it's a single item).
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.m_currentSize">
            <summary>
            Current total size of all pooled objects.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyBucketedPool`1.Count">
            <summary>
            The number of entries stored in this pool.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyBucketedPool`1.TotalSize">
            <summary>
            The total size of all entries stored in this pool.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyBucketedPool`1.BucketCount">
            <summary>
            Number of buckets in the pool.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.SetMaxSize(System.Int32,System.Int32)">
            <summary>
            Set the maximum size and tolerance
            </summary>
            <param name="maxSize"></param>
            <param name="tolerance"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.TryPop(System.Int32,`0@,System.Boolean)">
            <summary>
            Try to fetch a pooled item of the given size.
            </summary>
            <param name="length">The minimum item length.</param>
            <param name="element">The cached element if any.</param>
            <param name="borrow">Whether top borrow elements from larger buckets if none can be found within the desired length.</param>
            <returns>True when an element could be found, false otherwise.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.Push(`0)">
            <summary>
            Add an element to the pool. This is a transfer of ownership, the cached data must not be used
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.Clear">
            <summary>
            Clear all pooled data.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.DefaultBucketMapping(System.Int32)">
            <summary>
            Default size to bucket mapping.
            </summary>
            <param name="elementSize">The element's size.</param>
            <returns>The bucket key.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.TryPopBucket(System.Int32,System.Int32,`0@)">
            <summary>
            Try to pop an element from a bucket.
            </summary>
            <param name="bucketIndex">The index of the bucket to look into.</param>
            <param name="requestedSize">The requested size of the element.</param>
            <param name="element">The found element if any.</param>
            <returns>Whether a sizable element could be found.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.Push(System.Int32,`0)">
            <summary>
            Push to a pre-existing bucket.
            </summary>
            <param name="bucketIndex">The index of the bucket to push to.</param>
            <param name="element">The element to push.</param>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.HitBucket(VRage.Library.Collections.MyBucketedPool{`0}.Bucket@)">
            <summary>
            Increment the hit count on a bucket.
            
            This method handles hit count overflows as well.
            </summary>
            <param name="bucket">The bucket to increment hits on.</param>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.HitOverflow">
            <summary>
            Half all hit lengths to avoid an overflow but preserve values.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.Discard(System.Int32)">
            <summary>
            Discard elements until <paramref name="size"/> space is made available in the pool.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.GetSize(`0)">
            <summary>
            Get the size for an element.
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.GetKey(System.Int32)">
            <summary>
            Get a bucket key from an element size.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyBucketedPool`1.Discard(`0)">
            <summary>
            Discard an element.
            </summary>
            <param name="element"></param>
        </member>
        <member name="T:VRage.Library.Collections.MyBucketedPool`1.Entry">
            <summary>
            Entry in the cache.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyBucketedPool`1.Bucket">
            <summary>
            Bucket of similar sized entries.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MyBucketedPool`1.Bucket.Empty">
            <summary>
            Empty bucket.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyCollectionDictionary`3">
            <summary>
            Base class for dictionaries that store multiple elements under a key using some collection.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyCollectionDictionary`3.TryGet(`0,`1@)">
            <summary>
            Try get a collection for the provided key.
            </summary>
            <param name="key"></param>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyCollectionDictionary`3.GetAndRemove(`0)">
            <summary>
            Extract the collection from the dictionary.
            The ownership of the returned collection is transferred to the caller.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyCollectionDictionary`3.Remove(`0,`2,System.Boolean)">
            <summary>
            Remove a value from the collection associated with <paramref name="key"/>.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="removeKey">Whether to remove the key if the associated collection becomes empty.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyFreeList`1.#ctor(`0[],System.Int32,`0)">
            <summary>
            Create a new free list from a pre-allocated buffer.
            
            The buffer is assumed full up to <paramref name="usedCount"/>
            </summary>
            <param name="storage">The internal data.</param>
            <param name="defaultValue">The default value for an empty list entry.</param>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.Item(System.Int32)">
            <summary>
            Return a reference to the free list item at the provided position.
            </summary>
            <remarks>
            The reference may become invalid if items are allocated or freed after it was acquired.
            </remarks>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.UsedLength">
            <summary>
            Length of the internal buffer occupied by a mix of free and empty nodes, data past this length is all free.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.Count">
            <summary>
            Total number of allocated positions.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.Capacity">
            <summary>
            The total capacity of this free list.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyFreeList`1.IsValidKey(System.Int32)">
            <summary>
            Check if the given index is allocated.
            </summary>
            <param name="key">The index in the free list.</param>
            <returns>Whether the index is allocated.</returns>
        </member>
        <member name="T:VRage.Library.Collections.MyHashSetDictionary`2">
            <summary>
            Collection which stores multiple elements under same key by using list.
            Collection does not allow removing single value, only all items with same key.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyHashSetDictionary`2.Add(`0,`1)">
            <summary>
            Add a new element to the collection with the provided key.
            </summary>
            <param name="key">The key for the collection.</param>
            <param name="value">The value to add.</param>
            <returns>Whether the value was added to the collection (true) or not because the collection already contained it (false).</returns>
        </member>
        <member name="T:VRage.Library.Collections.MyIndexArray`1">
            <summary>
            Automatically resizing array when accessing index.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyIndexArray`1.TrimExcess(System.Single,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Trims end of array which contains default elements.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.ITypeList">
            <summary>
            Interface describing a generic type list.
            
            We use these as indices for the type dictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeList">
            <summary>
            Basic type list implementation.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeListWith">
            <summary>
            Type list with a single element added.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeListWithout">
            <summary>
            Type list with a single element added.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyComponentContainerTemplate`1">
            <summary>
            Template for an indexed component container.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:VRage.Library.Collections.ComponentIndex">
            <summary>
            Index for a component container.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.IndexHost">
            <summary>
            Host of static references to indexers.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyIndexedComponentContainer`1">
            <summary>
            Component container that stores the components in a list and uses a shared index for quick access.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Library.Collections.MyIndexedComponentContainer`1.#ctor(VRage.Library.Collections.MyComponentContainerTemplate{`0})">
            Create a component from a template.
        </member>
        <member name="T:VRage.Library.Collections.MyIndexList`1">
            <summary>
            Stores items in list with fixed index (no reordering).
            Null is used as special value and cannot be added into list.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyIndexList`1.NextIndex">
            <summary>
            Returns what will be next index returned by Add operation.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyConcurrentList`1.ListUnsafe">
            <summary>
            Debug only!! Thread unsafe
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyConcurrentList`1.List">
            <summary>
            Manage lock yourself when accesing the list!
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyConcurrentList`1.Lock">
            <summary>
            For accessing unsafe members
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyConcurrentList`1.Unlock">
            <summary>
            For accessing unsafe members
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyConcurrentList`1.Add(`0)">
            <summary>
            Does NOT call sort
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyConcurrentList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a range of items to this list.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:VRage.Library.Collections.MyListDictionary`2">
            <summary>
            Collection which stores multiple elements under same key by using list.
            Collection does not allow removing single value, only all items with same key.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyPNList`1">
            <summary>
            List that can have negative index. 
            </summary>
            <typeparam name="T">Type of the element in the list.</typeparam>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.GetEnumerator">
            <summary>
            Gets enumerator of all elements. Is NOT ordered by index.
            </summary>
            <returns>Enumerator providing all elements of the list.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets enumerator of all elements. Is NOT ordered by index.
            </summary>
            <returns>Enumerator providing all elements of the list.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.GetListMinIdx(`0,System.Int32,System.Int32,System.Collections.Generic.IReadOnlyList{`0})">
            <summary>
            Finds lowest index of a list. Helper method for this[index].
            </summary>
            <param name="value">Value set on list.</param>
            <param name="idx">Current index.</param>
            <param name="startIdx">Start index of search.</param>
            <param name="listToSearch">List to search.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.AddPositive(`0)">
            <summary>
            Adds element at the end of the list.
            </summary>
            <param name="item">Element to add.</param>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.AddNegative(`0)">
            <summary>
            Adds element at the beginning of the list (lowest index)
            </summary>
            <param name="item">Element to add.</param>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.Remove(`0)">
            <summary>
            Removes element from the list.
            </summary>
            <param name="item">Element to remove.</param>
            <returns>True if success.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MyPNList`1.GrowToIndex(System.Int32)">
            <summary>
            Resize internal lists to include given index.
            Zero is assigned to newly allocated fields.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyPNList`1.Count">
            <summary>
            Returns count of all elements on the list.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyPNList`1.CountPositive">
            <summary>
            Returns count of elements on positive index (including 0 index).
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyPNList`1.CountNegative">
            <summary>
            Returns count of elements on negative index (without 0 index).
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyPNList`1.MinIndex">
            <summary>
            Get minimum index. If max index is less than min index, list contains no items.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyPNList`1.MaxIndex">
            <summary>
            Get maximum index. If max index is less than min index, list contains no items.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MySortedList`2">
            <summary>
            A sorted list similar to <see cref="T:System.Collections.Generic.SortedList`2"/>, but with better access of the list contents.
            </summary>
            <typeparam name="TKey">The key to index values by. Must either be <see cref="T:System.Collections.Generic.IComparer`1"/> or a suitable comparer must be provided at construction time.</typeparam>
            <typeparam name="TValue">The type of the objects indexed by the key.</typeparam>
        </member>
        <member name="F:VRage.Library.Collections.MySortedList`2.m_comparer">
            <summary>
            The comparer used with keys.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MySortedList`2.m_keys">
            <summary>
            List of keys.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MySortedList`2.m_values">
            <summary>
            Matching list of values.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MySortedList`2.m_size">
            <summary>
            Current used size.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.MySortedList`2.m_version">
            <summary>
            Collection version, used to invalidate enumerators.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new sorted list with provided base capacity and an appropriate comparer for it's keys.
            </summary>
            <param name="baseCapacity"></param>
            <param name="comparer"></param>
        </member>
        <member name="P:VRage.Library.Collections.MySortedList`2.Capacity">
            <summary>
            Get or set the storage capacity of this collection.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MySortedList`2.Count">
            <summary>
            The number of entries in this list.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MySortedList`2.Item(`0)">
            <summary>
            Direct key value pair accessor.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.Add(`0,`1)">
            <summary>
            Add a key value pair to the sorted list.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value to add.</param>
            <exception cref="T:System.ArgumentException">If the provided key is already contained in the list.</exception>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.Remove(`0)">
            <summary>
            Remove the value associated with the provided key from the list.
            </summary>
            <param name="key">The key to remove.</param>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.FetchRemove(`0)">
            <summary>
            Remove a value and return it, given it's key.
            </summary>
            <param name="key">The key to look for.</param>
            <returns>The value stored under the key, or <c>default(TValue)</c> if the key was not found.</returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.TryGetValue(`0,`1@)">
            <summary>
            Try to get a value given it's key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.FindOrReserve(`0,`1)">
            <summary>
            get the position of a key, or allocate the entry with a default value and return it's position.
            </summary>
            <param name="key">The key to look for.</param>
            <param name="defaultValue">The value to put into the entry in case it needs to be created.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.GetValueAt(System.Int32)">
            <summary>
            Get the value stored at a given position.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.SetValueAt(System.Int32,`1)">
            <summary>
            Update the value stored at a given position.
            </summary>
            <param name="index">The position in the list to set.</param>
            <param name="value">The value to store at the provided position.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.GetKeyAt(System.Int32)">
            <summary>
            Get the key stored at a given position.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.Clear">
            <summary>
            Clear this collection.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.ContainsKey(`0)">
            <summary>
            Whether the list contains a given key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.ContainsValue(`1)">
            <summary>
            Whether the list contains a given value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.IndexOfKey(`0)">
            <summary>
            Find the index of a key.
            </summary>
            <param name="key">The key to look for.</param>
            <returns>The index of the key, or the complement of the position where that value would have to be inserted for the list to remain sorted. </returns>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.IndexOfValue(`1)">
            <summary>
            Locate the position of a value on the list.
            </summary>
            <param name="value">The value to look for.</param>
            <returns>The position of the value if found, -1 otherwise.</returns>
            <remarks>Unlike other search operations in this list, which have complexity O(log_2 n), this method has complexity O(n).</remarks>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.IndexOf(System.Predicate{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Find the index of the first key/value pair that matches the provided user predicate.
            </summary>
            <param name="predicate">The search predicate.</param>
            <returns>The index of the first pair matching the predicate, or -1 if none is found.</returns>
        </member>
        <member name="T:VRage.Library.Collections.MySortedList`2.KeyEnumerator">
            <summary>
            Enumerator for the whole list.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MySortedList`2.ValueEnumerator">
            <summary>
            Enumerator for the whole list.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MySortedList`2.ListEnumerator">
            <summary>
            Enumerator for the whole list.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.Insert(System.Int32,`0,`1)">
            <summary>
            Insert a key value pair at a previously calculated position.
            </summary>
            <param name="index"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.RemoveInternal(System.Int32)">
            <summary>
            Remove the entry at the provided position.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VRage.Library.Collections.MySortedList`2.EnsureAvailable(System.Int32)">
            <summary>
            Ensure that at least <paramref name="amount"/> positions are available in the list.
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.Collections.MyEnumerableDebugView`1">
            <summary>
            Debug proxy for MySortedList
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:VRage.Library.Collections.MyDictionaryDebugView`2">
            <summary>
            Debug proxy for MySortedList
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyDictionary`4">
            <summary>
            MyMultiKeyDictionary supports value lookups using multiple different keys.
            When keys can be derived from value, use MultiKeyIndex.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyDictionary`3">
            <summary>
            MyMultiKeyDictionary supports value lookups using multiple different keys.
            When keys can be derived from value, use MultiKeyIndex.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyIndex`4">
            <summary>
            MultiKeyIndex supports value lookups using multiple different keys.
            The keys must derivable from value, if it's not the case use MultiKeyDictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyIndex`3">
            <summary>
            MultiKeyIndex supports value lookups using multiple different keys.
            The keys must derivable from value, if it's not the case use MultiKeyDictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.PoolManager">
            <summary>
            A simple thread safe manager for all sorts of pooled objects.
            
            This 
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Preallocate``1(System.Int32)">
            <summary>
            Preallocate a number of elements for a given object pool.
            
            This call only produces an effect if the pool has not yet been initialized.
            </summary>
            <typeparam name="TPooled">The type of the pooled object.</typeparam>
            <param name="size">The number of elements to preallocate, this can be zero.</param>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Get``1">
            <summary>
            Get an instance from a pool.
            
            Pooled resources represent data structures that are cached to prevent unnecessary memory allocations in time critical moments.
            
            Pooled resources must always be return to the pool when no longer necessary.
            </summary>
            <typeparam name="TPooled">The type of the object to retrieve.</typeparam>
            <returns>Retrieve an instance of an object from the appropriate pool, if no pool exists one is created for the type.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Get``1(``0@)">
            <summary>
            Get an instance from a pool.
            
            Pooled resources represent data structures that are cached to prevent unnecessary memory allocations in time critical moments.
            
            Pooled resources must always be return to the pool when no longer necessary.
            </summary>
            <typeparam name="TPooled">The type of the object to retrieve.</typeparam>
            <returns>Retrieve an instance of an object from the appropriate pool, if no pool exists one is created for the type.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Return``1(``0@)">
            <summary>
            Return an object to it's pool.
            
            Note that if no pool has been allocated for the object type this call does nothing.
            
            If this type of behaviour is undesirable one may preallocate the pool <see cref="M:VRage.Library.Collections.PoolManager.Preallocate``1(System.Int32)"/>.
            In this case a preallocation of size 0 ensures the pool exists but does not allocate any instances.
            </summary>
            <typeparam name="TPooled">The type of the object to return to the pool.</typeparam>
            <param name="obj">An object to return to a pool.</param>
        </member>
        <member name="T:VRage.Library.Collections.SimpleEnumerable`1">
            <summary>
            Simple generic wrapper for an enumerator.
            </summary>
            <remarks>This class should be used to facilitate the implementation of enumerable members of collection objects.</remarks>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:VRage.Library.Collections.SimpleEnumerable.Create``1(System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
            Create a new enumerable for the provided creation function.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="createEnumerator"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.Collections.BitField64">
            <summary>
            Bit field with up to 64 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.TryPeek(`0,`1@)">
            <summary>
            Read an entry from the cache without modifying the cache order.
            </summary>
            <param name="key">The entry key.</param>
            <param name="value">The entry if found.</param>
            <returns>Whether the entry was found.</returns>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.Write(`0,`1)">
             <summary>
             Write an entry into the cache.
            
             If the cache is full the oldest record is evicted in order to make room for the new one.
             </summary>
             <param name="key"></param>
             <param name="value"></param>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.Remove(`0)">
            <summary>
            Try to remove an entry from the cache.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.RemoveWhere(System.Func{`0,`1,System.Boolean})">
            <summary>
            Remove every entry in the cache that matches the predicate.
            </summary>
            <param name="entryAction"></param>
            <returns>The number of entries removed.</returns>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.AssertConsistent">
            <summary>
            Verifies that all assumptions are met (linked list is connected and all lookups are correct).
            FULLDEBUG is only here to disable this. Enable by changing to DEBUG if you suspect problems.
            </summary>
        </member>
        <member name="T:VRage.Library.Compression.MyZipArchive">
            <summary>
            Class based on http://www.codeproject.com/Articles/209731/Csharp-use-Zip-archives-without-external-libraries.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.TraceForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VRage.Library.Debugging.TraceForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:VRage.Library.Debugging.TraceForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:VRage.Library.Debugging.VRageTraceListener">
            <inheritdoc />
            <summary>
            Summary description for VRageTraceListener.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.Instance">
            <summary>
            Cached singleton instance.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.m_ignored">
            <summary>
            Set of ignored locations.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.m_ignoredMessages">
            <summary>
            Messages,Frame pairs to be ignored.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.m_lineContents">
            <summary>
            Cached mapping of frames to the source lines containing assertions that did not provide any message.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.m_proxy">
            <summary>
            Proxy to the failure dialog.
            </summary>
        </member>
        <member name="P:VRage.Library.Debugging.VRageTraceListener.Name">
            <inheritdoc cref="P:VRage.Library.Debugging.VRageTraceListener.Name"/>
        </member>
        <member name="P:VRage.Library.Debugging.VRageTraceListener.TargetLog">
            <summary>
            The log where failures should be written to.
            
            When set to null the default log is used.
            
            To disable failure logging set <see cref="F:VRage.Library.Debugging.VRageTraceListener.LogFailures"/> to false.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.LogFailures">
            <summary>
            Whether failures that are reported should be written to the log.
            </summary>
        </member>
        <member name="M:VRage.Library.Debugging.VRageTraceListener.AddAndReplaceDefault">
            <summary>
            Add an instance of this class to the trace listener list and remove the default.
            </summary>
            <remarks>
            Using the app configuration is more versatile, so prefer that instead of this method.
            For more info see https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/how-to-create-and-initialize-trace-listeners.
            </remarks>
        </member>
        <member name="T:VRage.Library.Debugging.VRageTraceListener.FrameId">
            <summary>
            Represents a specific stack frame position.
            </summary>
        </member>
        <member name="T:VRage.Library.Debugging.VRageTraceListener.FailureMessage">
            <summary>
            Represents all the information that can be displayed when a failure is reported.
            </summary>
        </member>
        <member name="M:VRage.Library.Debugging.VRageTraceListener.FormatStackTrace(System.Diagnostics.StackFrame[])">
            <summary>
            Format a stack trace.
            
            Copied from StackTrace.
            </summary>
            <param name="trace"></param>
            <returns></returns>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.FormProxy.m_message">
            <summary>
            Current params to be displayed on the form.
            </summary>
        </member>
        <member name="F:VRage.Library.Debugging.VRageTraceListener.FormProxy.m_result">
            <summary>
            Result from the last form invocation.
            </summary>
        </member>
        <member name="M:VRage.Library.Extensions.MyArrayHelpers.CloneUnsafe``1(``0[])">
            <summary>
            This clone is unsafe because it only works with blittable types.
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="cloneFrom"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Extensions.StringBuilderExtensions_2.CompareUpdate(System.Text.StringBuilder,System.String)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:VRage.Library.Extensions.StringBuilderExtensions_2.CompareUpdate(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:VRage.Library.Extensions.StringBuilderExtensions_2.TrimEnd(System.Text.StringBuilder,System.Int32)">
            <summary>
            Removes the specified number of characters from the end.
            </summary>
            <param name="sb">The sb.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:VRage.Library.Extensions.StringBuilderExtensions_2.TrimTrailingWhitespace(System.Text.StringBuilder)">
            <summary>
            Removes whitespace from the end.
            </summary>
        </member>
        <member name="T:VRage.Library.FastPriorityQueue`1">
            <summary>
            An implementation of a min-Priority Queue using a heap.  Has O(1) .Contains()!
            See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
            </summary>
            <typeparam name="T">The values in the queue.  Must extend the FastPriorityQueueNode class</typeparam>
            
            <inheritdoc />
        </member>
        <member name="F:VRage.Library.FastPriorityQueue`1.Node.Priority">
            <summary>
            The Priority to insert this node at.  Must be set BEFORE adding a node to the queue (ideally just once, in the node's constructor).
            Should not be manually edited once the node has been queued - use queue.UpdatePriority() instead
            </summary>
        </member>
        <member name="F:VRage.Library.FastPriorityQueue`1.Node.QueueIndex">
            <summary>
            Represents the current position in the queue
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">initial memory size of the queue</param>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.#ctor">
            <summary>
            Instantiate a new Priority Queue
            </summary>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.MaxSize">
            <summary>
            Returns the maximum number of items that can be queued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will cause undefined behavior.  O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Contains(`0)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Enqueue(`0,System.Int64)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken arbitrarily.
            If the queue is full, the result is undefined.
            If the node is already queued, the result is undefined.
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.HasHigherOrEqualPriority(`0,`0)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherOrEqualPriority(node, node) (ie. both arguments the same node) will return true
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue and returns it.
            If queue is empty, result is undefined
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Resize(System.Int32)">
            <summary>
            Resize the queue so it can accept more nodes.  All currently queued nodes are remain.
            Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
            O(n)
            </summary>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            If the queue is empty, behavior is undefined.
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.UpdatePriority(`0,System.Int64)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            Calling this method on a node not in the queue results in undefined behavior
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="M:VRage.Library.Image.ImageUtils.GetDimensions(System.String)">
            <summary>
            Gets the dimensions of an image.
            </summary>
            <param name="path">The path of the image to get the dimensions of.</param>
            <returns>The dimensions of the specified image.</returns>
            <exception cref="T:System.ArgumentException">The image was of an unrecognized format.</exception>
        </member>
        <member name="M:VRage.Library.Image.ImageUtils.GetDimensions(System.IO.BinaryReader)">
            <summary>
            Gets the dimensions of an image.
            </summary>
            <param name="path">The path of the image to get the dimensions of.</param>
            <returns>The dimensions of the specified image.</returns>
            <exception cref="T:System.ArgumentException">The image was of an unrecognized format.</exception>    
        </member>
        <member name="M:VRage.Library.Image.ImageUtils.DecodeDds(System.IO.BinaryReader)">
            <summary>
            DDS Header:
            [Magic(i32), Size(i32), Flags(i32), Height(i32), Width(i32), ...] 
            </summary>
            <param name="binaryReader"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.IO.DataIntegrityChecker">
            <summary>
            Helper class used to verify and compare the individual and overall integrity of a set of files.
            </summary>
        </member>
        <member name="P:VRage.Library.IO.DataIntegrityChecker.TotalChecksum">
            <summary>
            The combined has of all checked files.
            </summary>
        </member>
        <member name="M:VRage.Library.IO.DataIntegrityChecker.CheckFile(System.String,System.IO.Stream)">
            <summary>
            Check if a file's checksum is valid.
            </summary>
            <param name="name">The semantic file name.</param>
            <param name="stream">A file stream where to read the file's contents from.</param>
            <returns>Whether the file's hash matches the checksum.</returns>
            <remarks>
            This method also caches the results per file and updates the global checksum.
            </remarks>
        </member>
        <member name="T:VRage.Library.IO.DataIntegrityChecker.CheckResult">
            <summary>
            Represents the result of running this checker over a file.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.DataIntegrityChecker.CheckResult.File">
            <summary>
            The file path.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.DataIntegrityChecker.CheckResult.Result">
            <summary>
            The check result.
            </summary>
        </member>
        <member name="M:VRage.Library.IO.DataIntegrityChecker.CheckResult.#ctor(System.String,VRage.Library.IO.FileChecksumResult)">
            <summary>
            Construct a new check result.
            </summary>
            <param name="file">The file path.</param>
            <param name="result">The verification result.</param>
        </member>
        <member name="M:VRage.Library.IO.DataIntegrityChecker.GetResults">
            <summary>
            Get verification results for all files, both checked, and included in the checksum file.
            </summary>
            <returns>En enumeration of all verification results.</returns>
        </member>
        <member name="T:VRage.Library.IO.DataIntegrityChecksum">
            <summary>
            Storage for file hashes.
            </summary>
            This can be used to create and store hashes to be used later with the data integrity checker.
        </member>
        <member name="P:VRage.Library.IO.DataIntegrityChecksum.Files">
            <summary>
            All file paths.
            </summary>
        </member>
        <member name="T:VRage.Library.IO.FileChecksumResult">
            <summary>
            Represents the possible results after verifying a file with the data integrity checker.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.FileChecksumResult.Match">
            <summary>
            The checksum existed and the file matched.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.FileChecksumResult.Mismatch">
            <summary>
            The checksum existed and the file did not match it.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.FileChecksumResult.Unknown">
            <summary>
            No checksum was found for the file.
            </summary>
        </member>
        <member name="F:VRage.Library.IO.FileChecksumResult.Unchecked">
            <summary>
            The file has a checksum but was never read.
            </summary>
        </member>
        <member name="M:VRage.Library.IO.Win32Processes.GetProcessesLockingFile(System.String)">
            <summary>
            Return a list of processes that hold on the given file.
            </summary>
        </member>
        <member name="M:VRage.Library.IO.Win32Processes.GetFilesLockedBy(System.Diagnostics.Process)">
            <summary>
            Return a list of file locks held by the process.
            </summary>
        </member>
        <member name="T:VRage.Library.Memory.DeepClonerExtensions">
            <summary>
            Extensions for object cloning
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClonerExtensions.DeepClone``1(``0,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Performs deep (full) copy of object and related graph
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClonerExtensions.DeepCloneTo``2(``0,``1,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Performs deep (full) copy of object and related graph to existing object
            </summary>
            <returns>existing filled object</returns>
            <remarks>Method is valid only for classes, classes should be descendants in reality, not in declaration</remarks>
        </member>
        <member name="M:VRage.Library.Memory.DeepClonerExtensions.ShallowCloneTo``2(``0,``1,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Performs shallow copy of object to existing object
            </summary>
            <returns>existing filled object</returns>
            <remarks>Method is valid only for classes, classes should be descendants in reality, not in declaration</remarks>
        </member>
        <member name="M:VRage.Library.Memory.DeepClonerExtensions.ShallowClone``1(``0)">
            <summary>
            Performs shallow (only new object returned, without cloning of dependencies) copy of object
            </summary>
        </member>
        <member name="T:VRage.Library.Memory.Finalizer">
            <summary>
            Simple finalizer object.
            
            This class can be used when static data needs to be finalized during normal app exit.
            
            This is not instended as a robust app finalization event. Only a helper for debug checks
            and other types of unessential finalization tasks.
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.Finalizer.#ctor(System.Action)">
            <summary>
            Create a new finalizer with a callback to be invoked during finalization.
            </summary>
            <param name="finalize"></param>
        </member>
        <member name="M:VRage.Library.Memory.Finalizer.Finalize">
            <summary>
            Fuinalize.
            </summary>
        </member>
        <member name="T:VRage.Library.Memory.DeepClone.DeepClonerRepository">
            <summary>
            A storage for cloner metadata.
            
            When using the default extensions methods to clone an object the <see cref="F:VRage.Library.Memory.DeepClone.DeepClonerRepository.Default"/> repository is used.
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.DeepClonerRepository.ClearCache">
            <summary>
            This method can be used when we switch between safe / unsafe variants (for testing)
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.DeepClonerGenerator.CloneObject``1(``0,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Clone ay object.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="obj">The object to clone.</param>
            <param name="repository">Optional cloner repository, when not provided the default is used.</param>
            <returns>The cloned object.</returns>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.DeepClonerGenerator.CloneStruct``1(``0,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Clone a struct.
            </summary>
            <remarks>
            When cloning a lot of structs it is recommended to call this directly, instead of <see cref="M:VRage.Library.Memory.DeepClone.DeepClonerGenerator.CloneObject``1(``0,VRage.Library.Memory.DeepClone.DeepClonerRepository)"/>
            </remarks>
            <typeparam name="T">The type of the struct.</typeparam>
            <param name="obj">The value to be cloned.</param>
            <param name="repository">Optional cloner repository, when not provided the default is used.</param>
            <returns>The cloned value.</returns>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.DeepClonerGenerator.CloneObjectTo(System.Object,System.Object,System.Boolean,VRage.Library.Memory.DeepClone.DeepClonerRepository)">
            <summary>
            Copy an object into another existing object.
            </summary>
            <param name="objFrom">Source.</param>
            <param name="objTo">Destination.</param>
            <param name="isDeep">Whether this should be a deep copy.</param>
            <param name="repository">Optional cloner repository, when not provided the default is used.</param>
            <returns>A reference to the destination object.</returns>
        </member>
        <member name="T:VRage.Library.Memory.DeepClone.DeepClonerSafeTypes">
            <summary>
            Safe types are types, which can be copied without real cloning. e.g. simple structs or strings (it is immutable)
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.DeepClonerSafeTypes.CanNotDeepCopyClass(System.Type)">
            <summary>
            Classes with only safe fields are safe for ShallowClone (if they root objects for copying)
            </summary>
        </member>
        <member name="T:VRage.Library.Memory.DeepClone.ShallowObjectCloner">
            <summary>
            Internal class but due implementation restriction should be public
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.ShallowObjectCloner.DoCloneObject(System.Object)">
            <summary>
            Abstract method for real object cloning
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.ShallowObjectCloner.CloneObject(System.Object)">
            <summary>
            Performs real shallow object clone
            </summary>
        </member>
        <member name="M:VRage.Library.Memory.DeepClone.ShallowObjectCloner.SwitchTo(System.Boolean)">
            <summary>
            Purpose of this method is testing variants
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.FastResourceLock.SpinConvertSharedToExclusive">
             <summary>
             Two threads calling this at the same time can apparently deadlock waiting for shared readers to reach 1.
            
             So only ever use this if you can ensure only one thread is attempting to convert to exclusive at any one time.
             </summary>
        </member>
        <member name="M:VRage.Library.Threading.FastResourceLockExtensions.AcquireSharedUsing(VRage.Library.Threading.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.FastResourceLockExtensions.AcquireExclusiveUsing(VRage.Library.Threading.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.AcquireExclusive">
            <summary>
            Acquires the lock in exclusive mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.AcquireShared">
            <summary>
            Acquires the lock in shared mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.ReleaseExclusive">
            <summary>
            Releases the lock in exclusive mode.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.ReleaseShared">
            <summary>
            Releases the lock in shared mode.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.TryAcquireExclusive">
            <summary>
            Attempts to acquire the lock in exclusive mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="M:VRage.Library.Threading.IResourceLock.TryAcquireShared">
            <summary>
            Attempts to acquire the lock in shared mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="T:VRage.Library.Threading.SpinLock">
            <summary>
            A struct which implements a spin lock.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.Enter">
            <summary>
            Enters the lock. The calling thread will spin wait until it gains ownership of the lock.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.TryEnter">
            <summary>
            Tries to enter the lock.
            </summary>
            <returns><c>true</c> if the lock was successfully taken; else <c>false</c>.</returns>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.Exit">
            <summary>
            Exits the lock. This allows other threads to take ownership of the lock.
            </summary>
        </member>
        <member name="T:VRage.Library.Threading.ProcessUtil">
            <summary>
            Collection of utilities for advanced process and thread management.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.ProcessUtil.SetThreadProcessorAffinity(System.Int32[])">
            <summary>
            Sets the processor affinity of the current thread.
            </summary>
            <param name="cpus">A list of CPU numbers. The values should be
            between 0 and <see cref="P:System.Environment.ProcessorCount"/>.</param>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.Interpolate(VRage.Library.Utils.InterpolationMethod,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Interpolates using the specified equation method between start and end values.
            </summary>
            <param name="method">Equation method to use.</param>
            <param name="start">Value at time 0.</param>
            <param name="end">Value at time 1.</param>
            <param name="time">Time value.</param>
            <param name="parameters">Additional parameters when using elastic or back method.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.Interpolate(VRage.Library.Utils.InterpolationMethod,System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Interpolates using the specified equation method.
            </summary>
            <param name="method">Equation method to use.</param>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.Linear(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a simple linear tweening, with no easing.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInQuadratic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quadratic (t^2) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutQuadratic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quadratic (t^2) easing out: decelerating to zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutQuadratic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quadratic (t^2) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInQuadratic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quadratic (time^2) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInCubic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a cubic (time^3) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutCubic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a cubic (time^3) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutCubic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a cubic (time^3) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInCubic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a cubic (time^3) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInQuartic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quartic (time^4) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutQuartic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quartic (time^4) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutQuartic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quartic (time^4) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInQuartic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quartic (time^4) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInQuintic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quintic (time^5) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutQuintic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quintic (time^5) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutQuintic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quintic (time^5) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInQuintic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a quintic (time^5) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInSinusoidal(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a sinusoidal (sin(time)) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutSinusoidal(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a sinusoidal (sin(time)) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutSinusoidal(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a sinusoidal (sin(time)) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInSinusoidal(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a sinusoidal (sin(time)) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInExponential(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an exponential (2^time) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutExponential(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an exponential (2^time) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutExponential(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an exponential (2^time) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInExponential(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an exponential (2^time) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInCircular(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a circular (sqrt(1-time^2)) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutCircular(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a circular (sqrt(1-time^2)) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutCircular(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a circular (sqrt(1-time^2)) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInCircular(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a circular (sqrt(1-time^2)) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInElastic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an elastic (exponentially decaying sine wave) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Period and amplitude values for the elastic effect. Default values are 0.3 * duration for period and 0 for amplitude.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutElastic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an elastic (exponentially decaying sine wave) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Period and amplitude values for the elastic effect. Default values are 0.3 * duration for period and 0 for amplitude.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutElastic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an elastic (exponentially decaying sine wave) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Period and amplitude values for the elastic effect. Default values are 0.3 * duration for period and 0 for amplitude.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInElastic(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for an elastic (exponentially decaying sine wave) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Period and amplitude values for the elastic effect. Default values are 0.3 * duration for period and 0 for amplitude.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInBack(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a back (overshooting cubic easing: (s+1)*time^3 - s*time^2) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Overshoot value for the back effect. Default value is 1.70158f.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutBack(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a back (overshooting cubic easing: (s+1)*time^3 - s*time^2) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Overshoot value for the back effect. Default value is 1.70158f.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutBack(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a back (overshooting cubic easing: (s+1)*time^3 - s*time^2) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Overshoot value for the back effect. Default value is 1.70158f.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInBack(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a back (overshooting cubic easing: (s+1)*time^3 - s*time^2) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">Overshoot value for the back effect. Default value is 1.70158f.</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInBounce(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in: accelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutBounce(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero velocity.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseInOutBounce(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in/out: acceleration until halfway, then deceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="M:VRage.Library.Utils.InterpolationEquationsF.EaseOutInBounce(System.Single,System.Single,System.Single,System.Single,System.Nullable{VRage.Library.Utils.InterpolationEquationsF.AdditionalParameters})">
            <summary>
            Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out/in: deceleration until halfway, then acceleration.
            </summary>
            <param name="time">Current time (in frames or seconds).</param>
            <param name="start">Starting value.</param>
            <param name="change">Change needed in value.</param>
            <param name="duration">Expected easing duration (in frames or seconds).</param>
            <param name="parameters">(Not used)</param>
            <returns>The interpolated value.</returns>
        </member>
        <member name="F:VRage.Library.Utils.MyEnum`1.m_names">
            <summary>
            Cached strings to avoid ToString() calls. These values are not readable in obfuscated builds!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyGameTimer">
            <summary>
            Global thread-safe timer.
            Time for update and time for draw must be copied at the beginning of update and draw.
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.MyGameTimer.Frequency">
            <summary>
            Number of ticks per seconds
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyGameTimer.ElapsedTimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyHashUtils.CreateFloatFromMantissa(System.UInt32)">
            <summary>
            Create a [0, 1) float from it's mantissa.
            </summary>
            <param name="m">Mantissa bits.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Utils.MyHashUtils.UniformFloatFromSeed(System.Int32)">
            <summary>
            Compute a float in the range [0, 1) created from the the seed.
            
            For uniformly distributed seeds this method will produce uniformly distributed values.
            </summary>
            <param name="seed">Any integer to be used as a seed. The seed needs not be super uniform since it will be hashed.</param>
            <returns>A float in the range [0, 1)</returns>
        </member>
        <member name="M:VRage.Library.Utils.MyHashUtils.CombineHashesFast(System.Int32,System.Int32)">
            <summary>
            Fast and sufficiently robust hash combiner.
            </summary>
            <param name="hash1"></param>
            <param name="hash2"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Utils.MyHashUtils.CombineHashes(System.Int32,System.Int32)">
            <summary>
            Combine two hash codes with a more robust method.
            </summary>
            <remarks>The method is based on the <see cref="T:System.String"/> implementation.</remarks>
            <param name="hash1"></param>
            <param name="hash2"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Utils.MyImageHeaderUtils.Read_DDS_HeaderData(System.String,VRage.Library.Utils.MyImageHeaderUtils.DDS_HEADER@)">
            <summary>
            Reads the header of standard DDS texture without reading the rest of its contents.
            Checks for magic constant.
            </summary>
            <param name="filePath">Path to dds.</param>
            <param name="header">Output header</param>
            <returns>Success flag.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Library.Utils.MyImageHeaderUtils.Read_PNG_Dimensions(System.String,System.Int32@,System.Int32@)" -->
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.DiscardOld(VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Discards old samples, keeps at least 2 samples to be able to interpolate or extrapolate.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.AddSample(`0@,VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Adds sample with timestamp, it must be larger than last timestamp!
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.Interpolate(VRage.Library.Utils.MyTimeSpan,`0@)">
            <summary>
            Discards old frame (keeps one older) and interpolates between two samples using interpolator.
            Returns interpolator
            There must be at least one sample!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyIterableComplementSet`1">
            Over a given set of elements W this class maintains two subsets A and B such that
            A ⋂ B = ∅, A ⋃ B = W, with constant time operations for moving elements from one set to the other.
            
            Both subsets are individually iterable, as well as the whole W.
            
            The order of elements in either set is never preserved.
            
            When using this class with value types beware that they will be duplicated internally.
            Prefer to use class types or some form of lightweight reference with this.
        </member>
        <member name="T:VRage.Library.Utils.MyRandom">
            <summary>
            Original C# implementation which allows settings the seed.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.SetSeed(System.Int32)">
            <summary>
            Sets new seed, only use this method when you have separate instance of MyRandom.
            Setting seed for RNG used for EntityId without reverting to previous state is dangerous.
            Use PushSeed for EntityId random generator.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.NextFloat">
            Returns random number between 0 and 1.
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.NextDouble">
            Returns random number between 0 and 1.
        </member>
        <member name="T:VRage.Library.Utils.SortUtil">
            <summary>
            Provides utilities for more exotic sorting.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.SortUtil.TopologicalSort``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Collections.Generic.IList{``0}},System.Func{System.Collections.Generic.IEnumerable{``0},System.Boolean})">
            <summary>
            Taking a list as a directed graph this method produces the topological ordering of it's vertices.
            </summary>
            <remarks>
            This method takes an optional argument <paramref name="handleCycle"/>.
            
            When provide this callback is invoked for every cycle found in the graph.
            Each time the call may return <c>true</c> to signify that the cycle should just be ignored,
            or <c>false</c> to mean that the sorting operation should be aborted.
            
            If the argument is not provide cycles are always fatal.
            
            If the sorting is aborted the original list remains unmodified.
            </remarks>
            <typeparam name="TItem">Type of the list item.</typeparam>
            <param name="list">The list to order.</param>
            <param name="getReferences">Get the vertices pointed to by a given item.</param>
            <param name="handleCycle">Delegate invoked to handle any cycles found.</param>
            <returns>Whether the sorting operation was successful (there were no cycles or all off them were ignored).</returns>
        </member>
        <member name="T:VRage.Library.Utils.MyTimer">
            <summary>
            Hi-resolution wait timer, internally uses multimedia timer
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyTimer.StartOneShot(System.Int32,VRage.Library.Utils.MyTimer.TimerEventHandler)">
            <summary>
            Starts one shot periodic timer.
            Handler must be STORED somewhere to prevent GC collection until it's called!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyTimeSpan">
            <summary>
            Hi-resolution time span. Beware: the resolution can be different on different systems!
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyTimeSpan.TimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.NormalizeFloat(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Normalizes uniform-spaced float within min/max into uint with specified number of bits.
            This does not preserve 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.DenormalizeFloat(System.UInt32,System.Single,System.Single,System.Int32)">
            <summary>
            Denormalizes uint with specified number of bits into uniform-space float within min/max.
            This does not preserve 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.NormalizeFloatCenter(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Normalizes uniform-spaced float within min/max into uint with specified number of bits.
            This preserves 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.DenormalizeFloatCenter(System.UInt32,System.Single,System.Single,System.Int32)">
            <summary>
            Denormalizes uint with specified number of bits into uniform-space float within min/max.
            This preserves 0 when min = -max
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.WaitForTargetFrameRate.WaitDeltaMs">
            <summary>
            Extra milliseconds to wait inside wait function.
            This property resets after every call of Wait function.
            </summary>
        </member>
        <member name="T:VRage.Collections.CachingDictionary`2">
            <summary>
            Dictionary wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="T:VRage.Collections.Concurrent.MyConcurrentSortedDictionary`2">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="T:VRage.Collections.Concurrent.MyConcurrentDictionary`2">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="P:VRage.Collections.Concurrent.MyConcurrentDictionary`2.SyncRoot">
            <summary>
            Synchronization object for this dictionary.
            </summary>
        </member>
        <member name="T:VRage.Collections.ConcurrentCachingList`1">
            <summary>
            List wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            
            This version has individual locks for cached and non-cached versions, allowing
            each to be managed efficiently even across multiple threads
            </summary>
        </member>
        <member name="M:VRage.Collections.ConcurrentCachingList`1.RemoveAtImmediately(System.Int32)">
            <summary>
            Immediately removes an element at the specified index.
            </summary>
            <param name="index">Index of the element to remove immediately.</param>
        </member>
        <member name="T:VRage.Collections.CachingList`1">
            <summary>
            List wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="M:VRage.Collections.CachingList`1.RemoveAtImmediately(System.Int32)">
            <summary>
            Immediately removes an element at the specified index.
            </summary>
            <param name="index">Index of the element to remove immediately.</param>
        </member>
        <member name="T:VRage.Collections.DefaultComparerAttribute">
             <summary>
             Attribute that can be used to annotate a static member of some class.
            
             Select collections in the VRage.Collections namespace will automatically use that comparer if no other is provided.
             </summary>
        </member>
        <member name="T:VRage.Collections.Generic.ListComparer`2">
            <summary>
            Comparer that can be used to compare <see cref="T:System.Collections.Generic.IList`1"/> objects.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TList"></typeparam>
        </member>
        <member name="T:VRage.Collections.Generic.ProxyComparer`2">
            <summary>
            Comparer that can leverage a sec ond comparer to order objects based on some property they share.
            </summary>
            <remarks>
            A dedicated comparer will have superior performance to this class. Prefer to use this for tasks that are not time critical.
            </remarks>
            <typeparam name="TObject">The type of the objects to compare.</typeparam>
            <typeparam name="TProxy">The type of the comparable shared property.</typeparam>
        </member>
        <member name="M:VRage.Collections.Generic.ProxyComparer`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IComparer{`1})">
            <summary>
            Create a new proxy comparer.
            </summary>
            <param name="accessor">Delegate used to access the common property for which a comparer is known.</param>
            <param name="comparer">The comparer to use for the common property.</param>
        </member>
        <member name="M:VRage.Collections.Generic.ProxyComparer`2.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Collections.Generic.EnumComparer`1">
            <summary>
            A fast and efficient implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for Enum types.
            Useful for dictionaries that use Enums as their keys.
            </summary>
            <remarks>
            var dict = new Dictionary&lt;DayOfWeek, 
            string&gt;(EnumComparer&lt;DayOfWeek&gt;.Instance);
            </remarks>
            <typeparam name="TEnum">The type of the Enum.</typeparam>
        </member>
        <member name="F:VRage.Collections.Generic.EnumComparer`1.equalsFunct">
            <summary>
            
            </summary>
        </member>
        <member name="F:VRage.Collections.Generic.EnumComparer`1.getHashCodeFunct">
            <summary>
            
            </summary>
        </member>
        <member name="F:VRage.Collections.Generic.EnumComparer`1.instance">
            <summary>
            The singleton accessor.
            </summary>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.#cctor">
            <summary>
            Initializes the <see cref="T:VRage.Collections.Generic.EnumComparer`1"/> class
            by generating the GetHashCode and Equals methods.
            </summary>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.#ctor">
            <summary>
            A private constructor to prevent user instantiation.
            </summary>
        </member>
        <member name="P:VRage.Collections.Generic.EnumComparer`1.Instance">
            <summary>
            The singleton accessor.
            </summary>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <typeparamref name="TEnum"/> 
            to compare.</param>
            <param name="y">The second object of type <typeparamref name="TEnum"/> 
            to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> 
            for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
            <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj"/> is a reference type and 
            <paramref name="obj"/> is null.
            </exception>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.AssertTypeIsEnum">
            <summary>
            Asserts the type is enum.
            </summary>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.AssertUnderlyingTypeIsSupported">
            <summary>
            Asserts the underlying type is supported.
            </summary>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.GenerateEqualsFunct">
            <summary>
            Generates a comparison method similar to this:
            <code>
            bool Equals(TEnum x, TEnum y)
            {
                return x == y;
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="M:VRage.Collections.Generic.EnumComparer`1.GenerateGetHashCodeFunct">
            <summary>
            Generates a GetHashCode method similar to this:
            <code>
            int GetHashCode(TEnum obj)
            {
                return ((int)obj).GetHashCode();
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="T:VRage.Collections.HashSetReader`1">
            <summary>
            Class that wraps and allows for safe read-only manipulation of a <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:VRage.Collections.MyConcurrentHashSet`1">
            <summary>
            Thread safe wrapper for a hashset.
            </summary>
        </member>
        <member name="T:VRage.Collections.ICachingCollection`1">
            <summary>
            Interface describing a collection that caches modifications and allows them to be performed at a later time.
            </summary>
            <typeparam name="T">The type of the collection item.</typeparam>
        </member>
        <member name="M:VRage.Collections.MyBinaryHeap`2.System#Collections#Generic#IEnumerable{VRage#Collections#MyBinaryHeap{TKey,TValue}#HeapItem}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Collections.MyBinaryHeap`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:VRage.Collections.MyIntervalList">
            <summary>
            <para>A set of integer numbers optimized for sets with long consecutive runs. Each interval is stored as two values in m_list: the lower and the upper bound.</para>
            <para>For example, the set of numbers 2, 3, 4, 5, 7, 9, 10, 11, 12, 13 (or alternatively in the interval notation &lt;2, 5&gt; U &lt;7, 7&gt; U &lt;9, 13&gt;)
            is saved as a list { 2, 5, 7, 7, 9, 13 }</para>
            </summary>
        </member>
        <member name="M:VRage.Collections.MyIntervalList.Add(System.Int32)">
            <summary>
            Add a value to the list
            </summary>
        </member>
        <member name="T:VRage.Collections.RangeEnumerator">
            <summary>
            Typeless helper for the <see cref="T:VRage.Collections.RangeEnumerator`1"/>
            </summary>
        </member>
        <member name="T:VRage.Collections.RangeEnumerator`1">
            <summary>
            Iterator for a range of an IList.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Collections.RangeEnumerator`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Create a new range iterator.
            </summary>
            <param name="list">Target of the enumeration.</param>
            <param name="start">Start index (inclusive).</param>
            <param name="end">Past end index (exclusive)</param>
        </member>
        <member name="M:VRage.Collections.MySinglyLinkedList`1.Split(VRage.Collections.MySinglyLinkedList{`0}.Enumerator,System.Int32)">
            <summary>
            Splits the list into two.
            This list's end will be the node pointed by newLastPosition and the newly created list will begin with the next node.
            </summary>
            <param name="newLastPosition">Enumerator that points to the new last position in the list.</param>
            <param name="newCount">New number of elements in this list. If set to -1, it is calculated automatically,
            but that would make the split an O(N) operation. Beware: If you set this parameter, be sure to always set the
            correct number, otherwise, you'd cause both lists (this one and the returned one) to return a wrong number of
            elements in the future.</param>
            <returns>The newly created list</returns>
        </member>
        <member name="T:VRage.Collections.MySwapQueue`1">
            <summary>
            Holds three objects in safe manner, use when Reader requires only last valid data.
            One object is used for reading, one for writing and third is used as buffer, so reader/writer don't have to wait on the other.
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.RefreshRead">
            <summary>
            Updates data for reading if there's something new
            Returns true when Read was updated, returns false when Read was not changed
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.CommitWrite">
            <summary>
            Commits Write and replaces write with new object ready for new writing
            </summary>
        </member>
        <member name="T:VRage.Collections.CollectionReader`1">
            <summary>
            Read only wrapper for a Collection. Can wrap a null instance.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:VRage.Collections.CollectionReader`1.m_collection">
            <summary>
            HashSet to be read.
            </summary>
        </member>
        <member name="P:VRage.Collections.CollectionReader`1.HasValidInstance">
            <summary>
            Whether this wrapper contains a valid instance (as opposed to null).
            </summary>
        </member>
        <member name="P:VRage.Collections.CollectionReader`1.Count">
            <summary>
            Number of items contained in the HashSet.
            </summary>
        </member>
        <member name="M:VRage.Collections.CollectionReader`1.Contains(`0)">
            <summary>
            Whether the wrapped HashSet contains a given value.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Collections.CollectionReader`1.Enumerator">
            <summary>
            Enumerator object for the HashSetReader.
            </summary>
        </member>
        <member name="T:VRage.Collections.ListReader`1">
            <summary>
            Struct that allows for safe and read-only manipulation of a <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <typeparam name="T"></typeparam>
            <inheritdoc cref="T:System.Collections.Generic.IReadOnlyList`1"/>
        </member>
        <member name="T:VRage.Collections.MyCommitQueue`1">
            <summary>
            Basic copy-on-commit implementation, later it will be faster by using one queue with 2 tails
            </summary>
        </member>
        <member name="T:VRage.Collections.MyQueue`1">
            <summary>
            Array backed circular queue.
            </summary>
        </member>
        <member name="F:VRage.Collections.MyQueue`1.m_array">
            <summary>
            Backing array for the queue.
            </summary>
        </member>
        <member name="F:VRage.Collections.MyQueue`1.m_head">
            <summary>
            Head pointer (location to remove the next de-queued item).
            </summary>
        </member>
        <member name="F:VRage.Collections.MyQueue`1.m_tail">
            <summary>
            Tail pointer (index of the next position to insert a new element).
            </summary>
        </member>
        <member name="F:VRage.Collections.MyQueue`1.m_size">
            <summary>
            Size of the queue.
            </summary>
        </member>
        <member name="F:VRage.Collections.MyQueue`1.m_version">
            <summary>
            Used to validate the enumerator.
            </summary>
        </member>
        <member name="M:VRage.Collections.MyQueue`1.RemoveAt(System.Int32)">
            <summary>
            Remove an element at a specific offset from the queue's head.
            
            Calling <c>RemoveAt(0)</c> is equivalent to dequeue.
            </summary>
            <param name="index">The element to remove from the queue.</param>
        </member>
        <member name="M:VRage.Collections.MyQueue`1.IndexOf(System.Predicate{`0})">
            <summary>
            Find the index on the queue for the first item matching the provide predicate.
            </summary>
            <param name="predicate">Query predicate.</param>
            <returns>The index of the first matching item (from queue head to tail), or -1 if no match is found.</returns>
        </member>
        <member name="M:VRage.Collections.MyQueue`1.Remove(System.Int32)">
            <summary>
            Remove an element in the queue by it's <emph>absolute</emph> position.
            </summary>
            <param name="idx"></param>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Count">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Item(System.Int32)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Add(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Insert(System.Int32,`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Remove(`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Contains(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="T:VRage.Collections.Graph.AlGraph`1">
             <summary>
             Adjacency List Graph.
             </summary>
             <remarks>
             A graph data structure that stores edges in the adjacency list format.
            
             This class is optimized for small graphs (up to a couple hundred elements). It is reasonably efficient at handling small changes.
             </remarks>
             <typeparam name="TVertex">The type of stored vertices.</typeparam>
        </member>
        <member name="F:VRage.Collections.Graph.AlGraph`1.m_edgeComparer">
            <summary>
            Comparer used during edge uniqueness test. Private cached reference.
            </summary>
        </member>
        <member name="F:VRage.Collections.Graph.AlGraph`1.VertexNeighbors">
            <summary>
            Mapping of vertices to their edges.
            </summary>
        </member>
        <member name="F:VRage.Collections.Graph.AlGraph`1.m_version">
            <summary>
            Version of this collection.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.AddVertex(`0)">
            <summary>
            Add a new vertex to this graph.
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.RemoveVertex(`0)">
            <summary>
            Remove an existing vertex and all of it's edges.
            </summary>
            <param name="vertex"></param>
            <returns>True when the removed vertex existed on the graph.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.AddEdge(`0,`0)">
            <summary>
            Add an edge between two vertices already contained in the graph.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.RemoveEdge(`0,`0)">
            <summary>
            Remove an edges between two vertices on the graph.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
            <returns>True when the removed edge existed on the graph.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.Clear">
            <summary>
            Remove all edges and vertices in the graph.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.ContainsVertex(`0)">
            <summary>
            Whether the graph contains a given vertex.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.ContainsEdge(`0,`0)">
            <summary>
            Whether the graph contains a given edge.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.GetAdjacentVertices(`0)">
            <summary>
            Get all edges adjacent to a given vertex.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.AlGraph`1.TryGetAdjacentVertices(`0,VRage.Collections.HashSetReader{`0}@)">
            <summary>
            Try to get all edges adjacent to a given vertex.
            </summary>
            <param name="vertex">The vertex to look for.</param>
            <param name="neighbors">Variable to stored the collection of adjacent vertices.</param>
            <returns>Whether the vertex was found on the graph.</returns>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.VertexCount">
            <summary>
            Number of vertices on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.EdgeCount">
            <summary>
            Number of vertices on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.VRage#Collections#Graph#IReadOnlyGraph{TVertex}#Vertices">
            <summary>
            Collection opf all vertices in the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.Vertices">
            <summary>
            Collection opf all vertices in the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.VRage#Collections#Graph#IReadOnlyGraph{TVertex}#Edges">
            <inheritdoc />
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.Edges">
            <summary>
            Collection of all edges on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.Comparer">
            <summary>
            Comparer for vertices on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.AlGraph`1.EdgeComparer">
            <summary>
            Comparer used during edge uniqueness test.
            </summary>
        </member>
        <member name="T:VRage.Collections.Graph.GraphEdge`1">
            <summary>
            Representation of an edge in a graph.
            </summary>
        </member>
        <member name="T:VRage.Collections.Graph.GraphExtensions">
            <summary>
            Set of extensions to perform common but not built-in operations on graphs.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.FindComponent``1(VRage.Collections.Graph.IGraph{``0},``0,System.Collections.Generic.ISet{``0},``0)">
            <summary>
            Find all connected vertices starting from the provided.
            </summary>
            <remarks>
            The implementation of this method is recursive.
            
            This variant of the method is useful for determining if an edge removal disconnects the graph, and simultaneously returning which edges make the connected component when it does.
            </remarks>
            <param name="self">Graph instance.</param>
            <param name="vertex">A vertex known to be contained on the desired component.</param>
            <param name="group">A set that will be populated with all the reachable vertices starting from <paramref name="vertex"/>.</param>
            <param name="earlyExit">A particular neighbor that one looks for, if this neighbor is found this method returns false.</param>
            <returns>False if the early vertex is found and the method exits before locating all members of the connected sub-graph, otherwise true.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.FindComponent``1(VRage.Collections.Graph.IGraph{``0},``0,System.Collections.Generic.ISet{``0})">
            <summary>
            Find all connected vertices starting from the provided.
            </summary>
            <remarks>
            The implementation of this method is recursive.
            </remarks>
            <param name="self">Graph instance.</param>
            <param name="vertex">A vertex known to be contained on the desired component.</param>
            <param name="group">A set that will be populated with all the reachable vertices starting from <paramref name="vertex"/>.</param>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.UnionWith``1(VRage.Collections.Graph.IGraph{``0},VRage.Collections.Graph.IGraph{``0})">
            <summary>
            Merge all vertices and edges in the provided graph.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.ExceptWith``1(VRage.Collections.Graph.IGraph{``0},VRage.Collections.Graph.IGraph{``0})">
            <summary>
            Remove all vertices and edges from the current graph that are also contained in <paramref name="graph"/>.
            </summary>
            <typeparam name="TVertex">The type of the vertex on the graph.</typeparam>
            <param name="self">This graph instance.</param>
            <param name="graph">The other graph.</param>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.CopySubGraph``1(VRage.Collections.Graph.IGraph{``0},System.Collections.Generic.ISet{``0},VRage.Collections.Graph.IGraph{``0})">
            <summary>
            Copy the sub-graph containing all the vertices in the provided set. All edges with both ends in the vertex set are also copied.
            </summary>
            <param name="self">Graph instance.</param>
            <param name="vertices">The set of vertices to copy from this graph.</param>
            <param name="target">The graph used to store all the copied vertices and their edges.</param>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.ExtractSubGraph``1(VRage.Collections.Graph.IGraph{``0},System.Collections.Generic.ISet{``0},VRage.Collections.Graph.IGraph{``0})">
            <summary>
            Extract the sub-graph containing all the vertices in the provided set. Any remaining edges will be removed.
            </summary>
            <param name="self">Graph instance.</param>
            <param name="vertices">The set of vertices to extract from this graph.</param>
            <param name="target">The graph used to store all the extracted vertices and their edges.</param>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.SplitToConnectedComponents``1(VRage.Collections.Graph.IGraph{``0},VRage.Collections.Graph.IGraphSplitHandler{``0})">
            <summary>
            Split this graph into new graphs for each of it's connected components.
            </summary>
            <param name="handleSplit">Callback invoked to handle split sub-graphs.</param>
            <param name="handleSingleVertex">Callback invoked to handle split sub-graphs with a single vertex.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.RemoveEdgeAndSplit``1(VRage.Collections.Graph.IGraph{``0},``0,``0,VRage.Collections.Graph.IGraphSplitHandler{``0})">
             <summary>
             Remove an edges between two vertices on the graph. This method returns the split off component if the removed edge causes a disconnection.
             </summary>
             <remarks>
             Either graph is only guaranteed to be connected if the original graph (before the removal) was connected.
            
             The graph will be split such that the split is no larger than the original graph after splitting.
             </remarks>
             <param name="vertex1"></param>
             <param name="vertex2"></param>
             <returns>Whether the edge was removed from the graph.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.AddEdge``1(VRage.Collections.Graph.IGraph{``0},VRage.Collections.Graph.GraphEdge{``0})">
            <summary>
            Add an edge to this graph.
            </summary>
            <param name="self">The graph instance.</param>
            <param name="edge">The edge to add.</param>
            <typeparam name="TVertex">The type of the vertex the graph contains.</typeparam>
            <returns>Whether the edge was added.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.GraphExtensions.RemoveEdge``1(VRage.Collections.Graph.IGraph{``0},VRage.Collections.Graph.GraphEdge{``0})">
            <summary>
            Remove an edge from this graph.
            </summary>
            <param name="self">The graph instance.</param>
            <param name="edge">The edge to remove.</param>
            <typeparam name="TVertex">The type of the vertex the graph contains.</typeparam>
            <returns>Whether the edge was removed.</returns>
        </member>
        <member name="T:VRage.Collections.Graph.IGraph`1">
            <summary>
            Interface that describes a graph data structure.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.IGraph`1.AddVertex(`0)">
            <summary>
            Add a new vertex to this graph.
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:VRage.Collections.Graph.IGraph`1.RemoveVertex(`0)">
            <summary>
            Remove an existing vertex and all of it's edges.
            </summary>
            <param name="vertex"></param>
            <returns>True when the removed vertex existed on the graph.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.IGraph`1.AddEdge(`0,`0)">
            <summary>
            Add an edge between two vertices already contained in the graph.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
        </member>
        <member name="M:VRage.Collections.Graph.IGraph`1.RemoveEdge(`0,`0)">
            <summary>
            Remove an edges between two vertices on the graph.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
            <returns>True when the removed edge existed on the graph.</returns>
        </member>
        <member name="M:VRage.Collections.Graph.IGraph`1.Clear">
            <summary>
            Remove all edges and vertices in the graph.
            </summary>
        </member>
        <member name="T:VRage.Collections.Graph.IGraphSplitHandler`1">
            <summary>
            Interface describing an object capable of handling graph splitting.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.IGraphSplitHandler`1.CreateSplit">
            <summary>
            Create a new graph instance for a splitting component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.IGraphSplitHandler`1.AllowSingleVertex(`0)">
            <summary>
            Allow split graphs to contain a single vertex.
            </summary>
            <param name="vertex"></param>
        </member>
        <member name="M:VRage.Collections.Graph.IGraphSplitHandler`1.HandleSplitGraph(VRage.Collections.Graph.IGraph{`0})">
            <summary>
            Handle a split sub-graph.
            </summary>
            <param name="split">The sub-graph containing all split vertices and edges.</param>
        </member>
        <member name="M:VRage.Collections.Graph.IGraphSplitHandler`1.HandleSplitVertex(`0)">
            <summary>
            Handle a split component containing a single vertex.
            </summary>
            <param name="vertex">The single vertex in the sub-graph.</param>
        </member>
        <member name="T:VRage.Collections.Graph.IReadOnlyGraph`1">
            <summary>
            Basic interface representing a graph that cannot be modified.
            </summary>
        </member>
        <member name="M:VRage.Collections.Graph.IReadOnlyGraph`1.ContainsVertex(`0)">
            <summary>
            Whether the graph contains a given vertex.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.IReadOnlyGraph`1.ContainsEdge(`0,`0)">
            <summary>
            Whether the graph contains a given edge.
            </summary>
            <param name="vertex1"></param>
            <param name="vertex2"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.IReadOnlyGraph`1.GetAdjacentVertices(`0)">
            <summary>
            Get all edges adjacent to a given vertex.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Collections.Graph.IReadOnlyGraph`1.TryGetAdjacentVertices(`0,System.Collections.Generic.ICollection{`0}@)">
            <summary>
            Try to get all edges adjacent to a given vertex.
            </summary>
            <param name="vertex">The vertex to look for.</param>
            <param name="neighbors">Variable to stored the collection of adjacent vertices.</param>
            <returns>Whether the vertex was found on the graph.</returns>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.VertexCount">
            <summary>
            Number of vertices on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.EdgeCount">
            <summary>
            Number of vertices on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.Vertices">
            <summary>
            Collection opf all vertices in the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.Edges">
            <summary>
            Collection of all edges on the graph.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.EdgeComparer">
            <summary>
            Comparer used during edge uniqueness test.
            </summary>
        </member>
        <member name="P:VRage.Collections.Graph.IReadOnlyGraph`1.Comparer">
            <summary>
            Comparer for vertices on the graph.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VRage.Collections.ObservableCollection`1" -->
        <member name="T:VRage.Collections.ObservableCollection`1.Enumerator">
            <summary>
            Enumerator which uses index access.
            Index access on Collection is O(1) operation
            </summary>
        </member>
        <member name="M:VRage.Collections.ObservableCollection`1.ClearItems">
            <summary>
            Clears the items.
            </summary>
        </member>
        <member name="M:VRage.Collections.ObservableCollection`1.GetEnumerator">
            <summary>
            Gets allocation free enumerator (returns struct)
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentQueue`1">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryHack`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryHack`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="T:VRage.Serialization.BlitCollectionSerializer`2">
            <summary>
            This is not optimal in terms of allocations, but works fine
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.None">
            <summary>
            No serialization flags
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultZero">
            <summary>
            Do not serialize member when it has default value, null for objects, zeros for structs.
            In binary streams, bit is written to indicate whether object had a value or not.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Nullable">
            <summary>
            Alias to default value.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Dynamic">
            <summary>
            Member can store subclasses of specified type, actual member type will be serialized as well.
            Valid only on class members (not for value types).
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultValueOrEmpty">
            <summary>
            Applies only to collections.
            When serializing empty collection (zero element count) it will behave like DefaultValue.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DynamicDefault">
            <summary>
            Same as dynamic, but stores a bit indicating whether serialized type is different from member type or not.
            When it's same, type is not serialized. Useful when some instances have default type.
            </summary>
        </member>
        <member name="T:VRage.Serialization.MyPrimitiveFlags">
            <summary>
            Primitive flags are passed down the object hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.None">
            <summary>
            No primitive flags.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Signed">
            <summary>
            Flag which indicates whether primitive is signed.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Normalized">
            <summary>
            Flag which indicates whether primitive is normalized.
            Exact behavior depends on actual type (0..1, -1..1, normalized vector, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Variant">
            <summary>
            Serialize member as unsigned variant (variable length integer, 0-127...1-byte, 127-32767...2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.VariantSigned">
            <summary>
            Serialize member as unsigned signed (-63..64, 1-byte etc, -32767..32768, 2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Ascii">
            <summary>
            Serialize string in ascii encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Utf8">
            <summary>
            Serialize string in UTF8 encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint8">
            <summary>
            Fixed point 8-bit precision, use with normalized
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint16">
            <summary>
            Fixed point 16-bit precision, use with normalized
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Flags">
            <summary>
            Serialization flags for member itself.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.PrimitiveFlags">
            <summary>
            Serialization flags for primitive types, when defined for types, passed down the hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.FixedLength">
            <summary>
            Length for fixed length arrays, collections and strings.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.DynamicSerializerType">
            <summary>
            Type of dynamic resolver.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Kind">
            <summary>
            Kind of attribute, specify Item for collections like list, array or dictionary value, specify Key for dictionary key.
            </summary>
        </member>
        <member name="T:VRage.Serialization.TupleSerializer">
            <summary>
            Serializer for empty class, does nothing
            </summary>
        </member>
        <member name="F:VRage.Compiler.IlCompiler.CompatibilityUsings">
            <summary>
            Usings that will be added to scripts before compilation. Those usings will replace default ones.
            </summary>
        </member>
        <member name="M:VRage.Compiler.IlCompiler.CheckResultInternal(System.Reflection.Assembly@,System.Collections.Generic.List{System.String},System.CodeDom.Compiler.CompilerResults,System.Boolean)">
            <summary>
            Checks assembly for not allowed operations (ie. accesing file system, network)
            </summary>
            <param name="tmpAssembly">output assembly</param>
            <param name="errors">compilation or check errors</param>
            <param name="result">compiled assembly</param>
            <param name="isIngameScript"></param>
            <returns>wheter the check was sucessflu (false AND null asembly on fail)</returns>
        </member>
        <member name="M:VRage.Compiler.IlChecker.IsTypeValid(System.Type)">
            <summary>
            Checks if the passed type is valid, ie. not null, assembly is not null and namespace is not null.
            </summary>
            <param name="type">Type to check</param>
            <returns>True if type is valid, false if it isn't.</returns>
        </member>
        <member name="M:VRage.Compiler.IlChecker.AddNamespaceOfTypeToDictionary(System.Type,System.Collections.Generic.Dictionary{System.Reflection.Assembly,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Adds the namespace of the specified type to the specified dictionary.
            </summary>
            <param name="type">Type whose namespace needs to be added.</param>
            <param name="targetDictionary">Dictionary which needs to be modified.</param>
            <returns>True if it was added, false otherwise.</returns>
        </member>
        <member name="M:VRage.Compiler.IlChecker.AllowNamespaceOfTypeModAPI(System.Type)">
            <summary>
            Allows the namespace of the type for ModAPI only.
            </summary>
            <param name="type">Type whose namespace needs to be whitelisted for ModAPI.</param>
            <returns>True if it was added, false otherwise.</returns>
        </member>
        <member name="M:VRage.Compiler.IlChecker.AllowNamespaceOfTypeCommon(System.Type)">
            <summary>
            Allows the namespace of the type for both ModAPI and ingame programmable blocks.
            </summary>
            <param name="type">Type whose namespace needs to be whitelisted for common listing.</param>
            <returns>True if it was added, false otherwise.</returns>
        </member>
        <member name="M:VRage.Compiler.IlChecker.CheckIl(System.Collections.Generic.List{VRage.Compiler.IlReader.IlInstruction},System.Type@,System.Boolean,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.Reflection.MemberInfo}})">
            <summary>
            Checks list of IL instructions against dangerous types
            </summary>
            <param name="dangerousTypeNames">Full names of dangerous types</param>
        </member>
        <member name="T:VRage.Compiler.IlReader">
            <summary>
            Reads method body and returns instructions
            </summary>
        </member>
        <member name="T:VRage.Compiler.TypeNameHelper`1">
            <summary>
            Type name which does not make allocations
            </summary>
        </member>
        <member name="M:VRage.Cryptography.MySHA256.Create">
            <summary>
            Creates FIPS compliant crypto provider if available, otherwise pure managed implementation.
            </summary>
        </member>
        <member name="T:VRage.Extensions.FieldExtensions">
            <summary>
            Extension methods for the <see cref="T:System.Reflection.FieldInfo"/> class.
            </summary>
        </member>
        <member name="M:VRage.Extensions.ArrayOfTypeEnumerator`3.GetEnumerator">
            <summary>
            So we can put this into foreach
            </summary>
        </member>
        <member name="T:VRage.MemberFormat">
            <summary>
            Flags that describe how members should be formatted.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.Accessors">
            <summary>
            Whether to include the visibility modifiers (<c>public</c>, <c>private</c>, etc) when formatting a member.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.Modifiers">
            <summary>
            Whether to include the other modifiers (such as <c>virtual</c>, <c>unsafe</c>, <c>readonly</c>, <c>new</c>, etc) when formatting a member.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.Type">
            <summary>
            Whether the member should display it's type.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.ParameterNames">
            <summary>
            Whether to include the names of parameters in constructors, methods and indexers.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.ParameterDefaults">
            <summary>
            Whether to include the default values of arguments.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.All">
            <summary>
            All member format flags.
            </summary>
        </member>
        <member name="F:VRage.MemberFormat.None">
            <summary>
            None of the member format flags.
            </summary>
        </member>
        <member name="M:VRage.MemberHelper.GetMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the memberinfo of field/property on static class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.MemberHelper`1.GetMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
             Gets the memberinfo of field/property on instance class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="T:VRage.NameQualification">
            <summary>
            Depth for 
            </summary>
        </member>
        <member name="F:VRage.NameQualification.None">
            <summary>
            No members will be printed as their full names.
            </summary>
            <example>
            typeof(List&lt;int&gt;).PrettyFormat(NameQualification.None); // Returns: "List&lt;int&gt;"
            </example>
        </member>
        <member name="F:VRage.NameQualification.OnlyFirst">
            <summary>
            Only level 1 members will be printed as their full names.
            </summary>
            <example>
            typeof(List&lt;int&gt;).PrettyFormat(NameQualification.FirstLevel); // Returns: "System.Collections.Generic.List&lt;int&gt;"
            </example>
        </member>
        <member name="F:VRage.NameQualification.AllButFirst">
            <summary>
            All except for Level 1 members will be formatted with their full names.
            </summary>
            <example>
            typeof(List&lt;int&gt;).GetMethod("Add").PrettyFormat(NameQualification.AllButFirst); // Returns: "public void Add(System.Int32 item)"
            </example>
        </member>
        <member name="F:VRage.NameQualification.All">
            <summary>
            All members will be printed as their full names.
            </summary>
            <example>
            typeof(List&lt;int&gt;).PrettyFormat(NameQualification.All); // Returns: "System.Collections.Generic.List&lt;System.Int32&gt;"
            </example>
        </member>
        <member name="T:VRage.NameQualificationExtensions">
            <summary>
            Extension methods for the <see cref="T:VRage.NameQualification"/> enum.
            </summary>
        </member>
        <member name="M:VRage.NameQualificationExtensions.Recurse(VRage.NameQualification)">
            <summary>
            Determine the correct qualification after recursion.
            </summary>
            <param name="base"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.NameQualificationExtensions.ShouldQualify(VRage.NameQualification)">
            <summary>
            whether the qualification requires the current member to be qualified.
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.FileSystem.MultipleRootResolver">
            <summary>
            Class that can combine and resolve a set of file system paths (called roots) into a single tree.
            </summary>
        </member>
        <member name="T:VRage.FileSystem.MultipleRootResolver.Node">
            <summary>
            Node on the cached file system tree.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MultipleRootResolver.Resolve(System.String)">
            <summary>
            Resolve the provide path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MultipleRootResolver.TryResolve(System.String,System.String@)">
            <summary>
            Try to resolve a path to one of the roots.
            </summary>
            <param name="path"></param>
            <param name="resolved"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MultipleRootResolver.ResolveNode(System.Int32,System.String)">
            <summary>
            Index all folders under a directory node, and which root path lead up to that.
            </summary>
            <param name="node"></param>
            <param name="relativePath"></param>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists
            </summary>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.DirectoryExists(System.String)">
            <summary>
            True if directory exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.FileExists(System.String)">
            <summary>
            True if file exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.GetFiles(System.String,System.String,VRage.FileSystem.MySearchOption)">
            <summary>
            Returns list of files in directory
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.GetDirectories(System.String)">
            <summary>
            Get the subdirectories of the provided path.
            </summary>
            <param name="path">The path to look under.</param>
            <returns>An enumeration of all the subdirectories under the provided path.</returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileProviderAggregator.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists or cannot be opened
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyZipFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            FileShare is ignored
            Usage: C:\Users\Data\Archive.zip\InnerFolder\file.txt
            </summary>
        </member>
        <member name="F:VRage.FileSystem.MyFileSystem.m_cachedFileExists">
            <summary>
            Caching file exists queries. File.Exists is rather slow and unfortunately it is used a lot in our beloved engine.
            We can safely cache file existence for content folder.
            </summary>
        </member>
        <member name="P:VRage.FileSystem.MyFileSystem.Initialized">
            <summary>
            Whether Init has been called.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.Init(System.String,System.Boolean)">
            <summary>
            Initialize the file subsystem providing only a path safe version of the application's name.
            </summary>
            <param name="safeAppName"></param>
            <param name="caseSensitive"></param>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.GetDefaultContentPath">
            <summary>
            Get the default app content path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.GetDefaultUserDataPath(System.String)">
            <summary>
            Get the default app data path.
            </summary>
            <remarks>The default content path is "../Content", relative to the main executable's location in disk.</remarks>
            <param name="safeAppName"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.Reset">
            <summary>
            Reset internals so init can be called again.
            </summary>
        </member>
        <member name="F:VRage.FileSystem.MyFileSystem.Resolver">
            <summary>
            Root resolver.
            </summary>
        </member>
        <member name="F:VRage.FileSystem.MyFileSystem.m_nonMergedPaths">
            <summary>
            Paths that are not merged.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.SetAdditionalContentPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Set extra content paths to be overlapped with the current paths.
            </summary>
            <param name="roots"></param>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.SetNonMergedPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Set the set of child paths of the content path that are not merged with the additional roots.
            Files on those paths can only be looked up by knowing their true path.
            </summary>
            <param name="paths"></param>
        </member>
        <member name="F:VRage.FileSystem.MyFileSystem.m_ignoreCombinedRoots">
            <summary>
            Disable combined root paths for the current thread.
            
            Prefer to use
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.IgnoreCombinedRoots">
            <summary>
            Temporarily ignore combined roots and treat paths as always absolute instead.
            
            The returned token must be disposed when done to revert back to original behavior.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.Resolve(System.String,System.Boolean@)">
            <summary>
            Resolve a path if it is relative to our content path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.Resolve(System.String)">
            <summary>
            Resolve a path if it is relative to our content path.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.GetAbsoluteContentFilePath(System.String)">
            <summary>
            For a given file inside the application's content folder this method returns it's absolute path.
            
            This will include any root resolution.
            </summary>
            <remarks>
            If the path is absolute and does not point to a file inside the content folder it will be returned as is.
            If the file does not exist the returned path will be invalid.
            </remarks>
            <param name="filePath">The path to resolve.</param>
            <returns>The absolute path to the file.</returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String)">
            <summary>
            Opens file for reading
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String,System.String)">
            <summary>
            Opens file for reading, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CheckFileWriteAccess(System.String)">
            <summary>
            Checks write access for file
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CopyAll(System.String,System.String)">
            <summary>
            Copy all files and folders from a source directory to the target directory.
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            TODO: Make this work with zip files.
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CopyAll(System.String,System.String,System.Predicate{System.String})">
            <summary>
            Copy all files and folders from a source directory to the target directory, excluding any paths that do not match the provided condition predicate.
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            TODO: Make this work with zip files.
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.EnsureDirectoryExists(System.String)">
            <summary>
            Ensure that the directory identified by the specified path does exist.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.GetContentRelativePath(System.String)">
            <summary>
            Produce a shortened path that omits the content or appdata paths.
            
            This path is not usable for file operations, it's sole purpose is to be more compact for displaying in logs and etc.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.SearchPatternToRegex(System.String)">
            <summary>
            Convert a search pattern into a regular expression.
            </summary>
            <param name="searchPattern"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.Clean(System.String)">
            <summary>
            Clean up all of the contents of the target directory.
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnCreate``1(VRage.Groups.MyGroups{`0,``0}.Group)">
            <summary>
            Group is taken from pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnRelease">
            <summary>
            Group is returned to pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeAdded(`0)">
            <summary>
            Node is added to group
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeRemoved(`0)">
            <summary>
            Node is removed from group
            </summary>
        </member>
        <member name="T:VRage.Groups.MyGroups`2.MajorGroupComparer">
            <summary>
            Return true when "major" is really major group, otherwise false.
            </summary>
        </member>
        <member name="P:VRage.Groups.MyGroups`2.SupportsOphrans">
            <summary>
            When true, groups with one member are supported.
            You can use AddNode and RemoveNode.
            You have to manually call RemoveNode!
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.#ctor(System.Boolean,VRage.Groups.MyGroups{`0,`1}.MajorGroupComparer)">
            <summary>
            Initializes a new instance of MyGroups class.
            </summary>
            <param name="supportOphrans">When true, groups with one member are supported and you have to manually call RemoveNode!</param>
            <param name="groupSelector">Major group selector, when merging two groups, major group is preserved. By default it's larger group.</param>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique for parent and for child; LinkId is unique node-node identifier.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.TryReleaseNode(VRage.Groups.MyGroups{`0,`1}.Node)">
            <summary>
            Returns true when node was released completely and returned to pool.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique only for parent, for grid it can be packed position of block which created constraint.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.LinkExists(System.Int64,`0,`0)">
            <summary>
            Returns true if the given link between parent and child exists, you can set child to null to find it by linkId.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.GetGroupNodes(`0)">
            <summary>
            Allocates!!
            Returns list of nodes datas in group
            </summary>
            <param name="nodeInGroup"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Compression.MyStreamWrapper">
            <summary>
            Stream wrapper which will close both stream and other IDisposable object
            </summary>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.GenerateKeys(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generate keys into specified files.
            </summary>
            <param name="publicKeyFileName">Name of the file that will contain public key</param>
            <param name="privateKeyFileName">Name of the file that will contain private key</param>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignData(System.String,System.String)">
            <summary>
            Signs given data with provided key.
            </summary>
            <param name="data">data to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed data (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.Byte[],System.Byte[])">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign</param>
            <param name="privateKey">private key</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.String,System.String)">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash</param>
            <param name="publicKey">signature</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyData(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the hash value of the provided data.
            </summary>
            <param name="originalMessage">original data</param>
            <param name="signedMessage">signed message (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="T:VRage.Common.Utils.MyChecksums">
            <summary>
            Helper class for serializing and deserializing checksum file.
            </summary>
        </member>
        <member name="M:VRage.DateTimeExtensions.ToDateTimeFromUnixTimestamp(System.UInt32)">
            <summary>
            Converts seconds passed since unix epoch into DateTime.
            </summary>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.DateTimeExtensions.ToDateTimeFromUnixTimestampUTC(System.UInt32)">
            <summary>
            Converts seconds passed since unix epoch into DateTime.
            </summary>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.DateTimeExtensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts DateTime to seconds passed since 1/1/1970.
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="T:VRage.Exceptions">
            <summary>
            Provides a set of methods that help throwing exceptions. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
            <param name="arg2">The arg2.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.Object[])">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAny``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if any of the conditions is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAll``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if all conditions are true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="T:VRage.TypeExtensions">
            <summary>
            Useful extensions for dealing with reflected type information.
            </summary>
        </member>
        <member name="F:VRage.TypeExtensions.CoreTypes">
            <summary>
            CLR built in types.
            </summary>
        </member>
        <member name="F:VRage.TypeExtensions.PrimitiveValueTypes">
            <summary>
            CLR primitive types.
            </summary>
        </member>
        <member name="F:VRage.TypeExtensions.PrimitiveTypeNames">
            <summary>
            Mapping of primitive types to their simple names.
            </summary>
        </member>
        <member name="M:VRage.TypeExtensions.IsAccessible(System.Type)">
            <summary>
            Check that the type is public to an unrelated scope, this will also check the declaring type hierarchy if needed..
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.GetAllFields(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Get all the fields of a given type.
            
            The built-in <see cref="M:System.Type.GetFields"/> method does not return private fields provided by parent classes, whereas this method does.
            </summary>
            <param name="type"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.GetAllProperties(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Get all the properties of a given type.
            
            The built-in <see cref="M:System.Type.GetProperties"/> method does not return private properties provided by parent classes, whereas this method does.
            </summary>
            <param name="type"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.GetAllEvents(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Get all the events of a given type.
            
            The built-in <see cref="M:System.Type.GetEvents"/> method does not return private events provided by parent classes, whereas this method does.
            </summary>
            <param name="type"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.GetGenericBase(System.Type,System.Type)">
            <summary>
            Get the concrete base type that is defined by the provided generic type definition.
            </summary>
            <param name="self">The type instance.</param>
            <param name="baseDefinition">The base class definition to look for.</param>
            <returns>The concrete base with the provided definition, or null if this type does
            not extend a concrete generic type with the provided definition.</returns>
        </member>
        <member name="M:VRage.TypeExtensions.IsChildOfType(System.Type,System.Type)">
            <summary>
            Whether the current type is a direct child of the parent type.
            </summary>
            <remarks>
            This method works with concrete types and concrete parents or with generic definitions and a generic or concrete parent.</remarks>
            <param name="self"></param>
            <param name="baseDefinition"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.GetGenericInterfaceImplementation(System.Type,System.Type)">
             <summary>
             Return the first interface that subtype implements which is concrete instance of the provided generic interface type.
             </summary>
             <remarks>
             This method succeeds even when the type is an interface.
             </remarks>
             <example>
             <code>
             var list = new List&lt;String&gt;();
             var itemType = list.GetType().GetGenericInterfaceImplementation(typeof(IList&lt;&gt;)).GenericTypeArguments[0];
            
             Console.WriteLine("List {0} contains elements of type {1}", list, itemType);
             // Outputs: "List System.Collections.Generic.List`1[System.String] contains elements of type System.String" 
             </code>
             </example>
             <param name="type">The type implementing the interface.</param>
             <param name="genericInterface">The generic interface sought after.</param>
             <returns>The first concrete implementation of the provided generic interface type.</returns>
        </member>
        <member name="M:VRage.TypeExtensions.PrettyFormat(System.Type,VRage.NameQualification,VRage.MemberFormat)">
            <summary>
            Get full type name with full namespace names
            </summary>
            <param name="type">Type. May be generic or nullable</param>
            <param name="qualification"></param>
            <param name="format"></param>
            <param name="includeNamespaces">Whether to include the namespace names of non-primitive types.</param>
            <returns>Full type name, fully qualified namespaces</returns>
        </member>
        <member name="M:VRage.TypeExtensions.PrettyFormat(System.Type,System.Text.StringBuilder,VRage.MemberFormat,VRage.NameQualification)">
            <summary>
            Get full type name with full namespace names
            </summary>
            <param name="type">Type. May be generic or nullable</param>
            <param name="builder"></param>
            <param name="format"></param>
            <param name="qualification"></param>
            <param name="includeNamespaces">Whether to include the namespace names of non-primitive types.</param>
            <returns>Full type name, fully qualified namespaces</returns>
        </member>
        <member name="T:VRage.Logging.AssertFilter">
            <summary>
            A log filter that shows the assert window for messages of a specified severity.
            </summary>
        </member>
        <member name="F:VRage.Logging.AssertFilter.MinSeverity">
            <summary>
            Minimum severity for the displaying of the failure window.
            </summary>
        </member>
        <member name="T:VRage.Logging.ContextualLogger">
            <summary>
            Basic filter logger that pipes all contextual log messages into <see>ContextualLogMessage</see>
            </summary>
        </member>
        <member name="T:VRage.Logging.ContextualLogMessage">
            <summary>
            Format for log messages with a basic object context that is converted to a string before printing
            </summary>
        </member>
        <member name="T:VRage.Logging.FilterLogger">
            <summary>
            Base class for loggers that only filter the contents of messages which are then forwarded to another logger.
            </summary>
        </member>
        <member name="F:VRage.Logging.FilterLogger.Parent">
            <summary>
            Parent logger.
            </summary>
        </member>
        <member name="M:VRage.Logging.FilterLogger.Filter(VRage.Logging.NamedLogger@,VRage.Logging.LogSeverity@,System.Object@)">
            <summary>
            Filter the message being passed to this logger.
            </summary>
            <param name="source"></param>
            <param name="severity"></param>
            <param name="message"></param>
        </member>
        <member name="T:VRage.Logging.ICustomLogFormatter">
            <summary>
            Defines a special type of formatter that can optionally provide additional text for a message.
            </summary>
        </member>
        <member name="M:VRage.Logging.ICustomLogFormatter.Format(System.String,System.Object,System.IFormatProvider,System.Text.StringBuilder)">
            <summary>
            Format the provided argument object.
            </summary>
            <remarks>
            The <paramref name="extraData"/> string builder can be used to add extra text to the message that is appended to the end of the current message.
            </remarks>
            <param name="format"></param>
            <param name="argument"></param>
            <param name="provider"></param>
            <param name="extraData"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Logging.ILogFilter">
            <summary>
            Defines an object that can be used to filter what messages go to a particular log.
            </summary>
        </member>
        <member name="M:VRage.Logging.ILogger.Log(VRage.Logging.NamedLogger@,VRage.Logging.LogSeverity,System.Object)">
            <summary>
            Append a given message to this log.
            </summary>
            <param name="source">Source of this log message.</param>
            <param name="severity">The message severity.</param>
            <param name="message">The actual message.</param>
        </member>
        <member name="M:VRage.Logging.ILogger.OpenBlock(VRage.Logging.NamedLogger@,System.String)">
            <summary>
            Begin a named sequence of operations on this log.
            </summary>
            <remarks>
            The sequence should be tracked on a per-thread basis.
            </remarks>
            <param name="source"></param>
            <param name="message">The name of the block.</param>
        </member>
        <member name="M:VRage.Logging.ILogger.CloseBlock(VRage.Logging.NamedLogger@,System.String)">
            <summary>
            End the current open block.
            </summary>
            <param name="message">An optional message to include after the block is finished.</param>
        </member>
        <member name="T:VRage.Logging.LegacyLoggerCalls">
            <summary>
            Collection of extension method representing the legacy logger calls that are getting phased out.
            </summary>
        </member>
        <member name="T:VRage.Logging.LogWriter">
            <summary>
            Base class for loggers that support filters.
            </summary>
        </member>
        <member name="P:VRage.Logging.LogWriter.Filters">
            <summary>
            Collection of filters that can select which messages do and do not get written to the log.
            </summary>
        </member>
        <member name="T:VRage.Logging.TextLogger">
            <summary>
            Logger that outputs messages as human readable text.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.TrackBlockTime">
            <summary>
            Whether to track and log the duration of blocks.
            </summary>
        </member>
        <member name="P:VRage.Logging.TextLogger.FilePath">
            <summary>
            Path to the file where this log is kept.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.IndentSpaces">
            <summary>
            Number of spaces per indentation level.
            </summary>
        </member>
        <member name="P:VRage.Logging.TextLogger.AutoFlush">
            <summary>
            Whether to always flush the log to disk after each message.
            </summary>
        </member>
        <member name="P:VRage.Logging.TextLogger.Disposed">
            <summary>
            Whether this log instance has been disposed.
            </summary>
        </member>
        <member name="P:VRage.Logging.TextLogger.SyncRoot">
            <summary>
            Synchronization object used by this logger to protect the output stream.
            </summary>
        </member>
        <member name="P:VRage.Logging.TextLogger.FormatProvider">
            <summary>
            Our format provider.
            </summary>
        </member>
        <member name="M:VRage.Logging.TextLogger.#ctor(System.String)">
            <summary>
            Create a new logger instance targeting a file.
            </summary>
            <param name="destination"></param>
        </member>
        <member name="M:VRage.Logging.TextLogger.#ctor(System.String,System.IO.Stream)">
            <summary>
            Create a new logger instance targeting a stream.
            </summary>
            <param name="destination"></param>
        </member>
        <member name="T:VRage.Logging.TextLogger.WriterFormatProvider">
            <summary>
            Custom format provider and formatter that can delegate per type formatting to the logger.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_formatProvider">
            <summary>
            Our format provider.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_formatters">
            <summary>
            Custom per type formatters.
            </summary>
        </member>
        <member name="M:VRage.Logging.TextLogger.SetFormatter(System.Type,System.ICustomFormatter)">
            <summary>
            Set the formatter for a given object type.
            </summary>
            <param name="argType"></param>
            <param name="formatter"></param>
        </member>
        <member name="M:VRage.Logging.TextLogger.ClearFormatter(System.Type)">
            <summary>
            Clear the formatter currently set for a given type.
            </summary>
            <param name="argType"></param>
        </member>
        <member name="M:VRage.Logging.TextLogger.TryGetFormatter(System.Type,System.ICustomFormatter@)">
            <summary>
            Try to get the user defined formatter for a given type.
            </summary>
            <param name="argType"></param>
            <param name="formatter"></param>
            <returns></returns>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_builder">
            <summary>
            Builder used to compose messages before writing them to the stream.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_buffer">
            <summary>
             Intermediate buffer used to write messages without allocating a final string from the builder.
            </summary>
        </member>
        <member name="M:VRage.Logging.TextLogger.StartLine(System.String)">
            <summary>
            Start a new line in the log.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:VRage.Logging.TextLogger.WriteIndent(System.Int32)">
            <summary>
            Append an indentation amount to the builder.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:VRage.Logging.TextLogger.WriteSeverity(VRage.Logging.LogSeverity)">
            <summary>
            Start a new line in the log.
            </summary>
            <param name="name"></param>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_ownerThreadId">
            <summary>
            Owner thread.
            </summary>
        </member>
        <member name="T:VRage.Logging.TextLogger.Block">
            <summary>
            Log block.
            </summary>
        </member>
        <member name="F:VRage.Logging.TextLogger.m_perThreadBlocks">
            <summary>
            Tracking of open blocks for each thread using this log.
            </summary>
        </member>
        <member name="M:VRage.Logging.TextLogger.GetStack">
            <summary>
            Get the block stack for the current thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Logging.MyLog.GetNamedLogger(System.String)">
            <summary>
            Try to retrieve a logger by name.
            </summary>
            <param name="name"></param>
            <returns>The logger registered with the given name, or null if no such logger exists.</returns>
        </member>
        <member name="P:VRage.Logging.MyLog.Logger">
            <summary>
            Internal logger instance.
            </summary>
        </member>
        <member name="P:VRage.Logging.MyLog.Loggers">
            <summary>
            Set of known loggers.
            </summary>
        </member>
        <member name="M:VRage.Logging.MyLog.#ctor(System.Boolean)">
            <summary>
            Create a new logger instance.
            </summary>
            <param name="noBuffer">Set true to disable output buffering. Output buffering may result in truncated logs if the process does not terminate normally, but will result in a performance degradation.</param>
        </member>
        <member name="M:VRage.Logging.MyLogExtensions.LogCrash(VRage.Logging.MyLog,System.Exception)">
            <summary>
            Log an exception that was not, or could not be handled correctly and cause the process to terminate.
            </summary>
            <param name="self"></param>
            <param name="causeOfFailure"></param>
        </member>
        <member name="T:VRage.Logging.LogSeverity">
            <summary>
            Specifies the severity of a message recorded onto a log.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Debug">
            <summary>
            Debug info/verbose logging.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Message">
            <summary>
            A message that should be transcribed on it's own to the log (without a prefix).
            
            Should be used for displaying version numbers, greetings or any other type of
            message destined to the reader of the log that does not fit in the other categories.
            
            On most log printers this message will not have any prefix (unlike the remaining severity levels).
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Verbatim">
            <summary>
            Append Text to the log as a dump, i.e. without any re-formatting, indent
            or other embellishments usually applied to other message types.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Info">
            <summary>
            Status information.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Warning">
            <summary>
            A warning about a sub-optimal condition or minor failure.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Error">
            <summary>
            A notification of a recoverable, yet serious error. Should be used when a failure disrupts
            normal application functioning but do not result in a crash or major data loss.
            </summary>
        </member>
        <member name="F:VRage.Logging.LogSeverity.Critical">
            <summary>
            A critical failure that results in major loss of data or the application having to abort.
            </summary>
        </member>
        <member name="T:VRage.Logging.NamedLogger">
            <summary>
            Named logging source.
            </summary>
            <remarks>
            This object add context and provides a more convenient interface to logging.
            </remarks>
        </member>
        <member name="F:VRage.Logging.NamedLogger.Name">
            <summary>
            Name of this source.
            </summary>
        </member>
        <member name="F:VRage.Logging.NamedLogger.m_target">
            <summary>
            Target logger internal reference.
            </summary>
        </member>
        <member name="P:VRage.Logging.NamedLogger.Target">
            <summary>
            Logger that gets the messages issued by this source.
            </summary>
        </member>
        <member name="F:VRage.Logging.NamedLogger.Context">
            <summary>
            Contextual information about this logger.
            </summary>
        </member>
        <member name="M:VRage.Logging.NamedLogger.#ctor(VRage.Logging.NamedLogger@,System.String,VRage.Logging.ILogger)">
            <summary>
            Create a new logger that is logically a child of the provided parent.
            </summary>
            <remarks>
            The name of this logger will be composed of the parent's followed by a <c>'.'</c> and the new name.
            </remarks>
            <param name="parent">The parent logger.</param>
            <param name="name">The name of the new logger.</param>
            <param name="logger">An optional override for the parent's internal logger target.</param>
            <exception cref="T:System.ArgumentNullException">When the provided name is null.</exception>
        </member>
        <member name="M:VRage.Logging.NamedLogger.#ctor(VRage.Logging.ILogger)">
            <summary>
            Create a new anonymous logger targeting the provided log.
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:VRage.Logging.NamedLogger.WithContext(System.Object)">
            <summary>
            Return a copy of this logger with the provided object as it's context.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Logging.NamedLogger.OpenBlock(System.String)">
            <summary>
            Start a new block on the target logger and return a token that can be disposed to close the block.
            </summary>
            <remarks>
            Ideally this call should be paired with the <see langword="using"/> statement.
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Logging.NamedLogger.BlockToken">
            <summary>
            Token representing an open block in a logger.
            </summary>
        </member>
        <member name="M:VRage.Logging.NamedLogger.BlockToken.Close(System.String)">
            <summary>
            Dispose this block, with an optional message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VRage.Logging.NamedLogger.BlockToken.SetMessage(System.String)">
            <summary>
            Set the message displayed when the block is closed.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VRage.Logging.NamedLogger.BlockToken.Dispose">
            <summary>
            Dispose this toke, closing the block in the process.
            </summary>
        </member>
        <member name="F:VRage.Logging.NullLogger.Instance">
            <summary>
            Single instance of the null logger.
            </summary>
        </member>
        <member name="T:VRage.Memory.DataPin`1">
            <summary>
            Pin a byte array and allow for access as if it were a struct.
            </summary>
            <remarks>
            Not disposing this object will cause the array to be pinned in the heap indefinitely.
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Memory.DataPin`1.#ctor(System.Byte[])">
            <summary>
            Construct a new DataPin instance that points to the specified byte array.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.ArgumentException">When the size of the array does not match the size of the object.</exception>
        </member>
        <member name="P:VRage.Memory.DataPin`1.Value">
            <summary>
            Get a reference to the data interpreted as the pin type.
            </summary>
            <value></value>
        </member>
        <member name="M:VRage.Memory.DataPin`1.Dispose">
            <summary>
            Release the pinned handle to the target byte array.
            </summary>
        </member>
        <member name="T:VRage.Memory.NativeBuffer`1">
            <summary>
            Wrapper for as type safe native buffer.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:VRage.Memory.NativeBuffer`1.Handle">
            <summary>
            The managed handle that controls the lifetime of the un-managed buffer.
            </summary>
        </member>
        <member name="P:VRage.Memory.NativeBuffer`1.Data">
            <summary>
            The data contained in the buffer.
            </summary>
        </member>
        <member name="P:VRage.Memory.NativeBuffer`1.Length">
            <summary>
            The length of the buffer.
            </summary>
        </member>
        <member name="P:VRage.Memory.NativeBuffer`1.Item(System.Int32)">
            <summary>
            Access an item in the buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Memory.NativeBuffer`1.Dispose">
            <summary>
            Release the pinned handle to the target byte array.
            </summary>
        </member>
        <member name="T:VRage.Memory.SafeNativeBuffer`1">
            <summary>
            Wrapper for as type safe native buffer.
            </summary>
            <remarks>This wrapper exists as an intermediate for code that is not compatible with the C# 7.3 <c>unsafe</c> type constraint.</remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:VRage.Memory.SafeNativeBuffer`1.Handle">
            <summary>
            The managed handle that controls the lifetime of the un-managed buffer.
            </summary>
        </member>
        <member name="P:VRage.Memory.SafeNativeBuffer`1.Data">
            <summary>
            The data contained in the buffer.
            </summary>
        </member>
        <member name="P:VRage.Memory.SafeNativeBuffer`1.Length">
            <summary>
            The length of the buffer.
            </summary>
        </member>
        <member name="M:VRage.Memory.SafeNativeBuffer`1.Dispose">
            <summary>
            Release the pinned handle to the target byte array.
            </summary>
        </member>
        <member name="T:VRage.Reflection.LightWeightStackTrace">
             <summary>
             A lightweight version of <see cref="T:System.Diagnostics.StackTrace"/>.
            
             This struct will pre-load less data which should make it faster to create (in particular it will not load reflection info until requested).
             </summary>
        </member>
        <member name="F:VRage.Reflection.LightWeightStackTrace.m_stackFrameHelper">
            <summary>
            Instance of the stack frame helper.
            </summary>
        </member>
        <member name="F:VRage.Reflection.LightWeightStackTrace.m_hashCode">
            <summary>
            Cached hash code of the trace.
            </summary>
        </member>
        <member name="P:VRage.Reflection.LightWeightStackTrace.Count">
            <summary>
            The number of frames in the trace.
            </summary>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetMethod(System.Int32)">
            <summary>
            Get method information for a frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetMethodHandle(System.Int32)">
            <summary>
            Get an internal runtime memory address that uniquely identifies a method.
            </summary>
            <remarks>The memory address is not useful to the user in any way other than being a
            runtime-unique method identifier that is much faster to interact with than a MethodBase instance.</remarks>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetIlOffset(System.Int32)">
            <summary>
            Get the IL byte-code offset for the active statement of a given stack frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetFileName(System.Int32)">
            <summary>
            Get the source file name for a stack frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetLineNumber(System.Int32)">
            <summary>
            Get the source file line number for a frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetColumnNumber(System.Int32)">
            <summary>
            Get the source file column number for a frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetMethodHandles">
            <summary>
            Get an internal runtime memory address that uniquely identifies a method.
            </summary>
            <remarks>The memory address is not useful to the user in any way other than being a
            runtime-unique method identifier that is much faster to interact with than a MethodBase instance.</remarks>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetIlOffsets">
            <summary>
            Get the IL byte-code offset for the active statement of a given stack frame.
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:VRage.Reflection.LightWeightStackTrace.Create(System.Int32,System.Boolean)">
            <summary>
            Create a trace from the current thread's stack.
            </summary>
            <param name="framesToSkip">Number of frames to skip from the bottom of the stack.</param>
            <param name="collectFileData">Whether debug information such as file names should be collected for the frames on the stack.s</param>
            <returns></returns>
        </member>
        <member name="T:VRage.Reflection.StackTracker">
            <summary>
            Data structure designed to aggregate stack traces.
            </summary>
            <remarks>This data structure is most useful whe tracking object allocation traces.</remarks>
        </member>
        <member name="F:VRage.Reflection.StackTracker.m_traceIndex">
            <summary>
            Mapping of traces to an index in the trace data free list.
            </summary>
        </member>
        <member name="F:VRage.Reflection.StackTracker.m_traceData">
            <summary>
            List of trace data.
            </summary>
        </member>
        <member name="F:VRage.Reflection.StackTracker.m_collectFileData">
            <summary>
            Whether to collect file information for each trace.
            </summary>
        </member>
        <member name="M:VRage.Reflection.StackTracker.#ctor(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:VRage.Reflection.StackTracker.Count">
            <summary>
            Number of distinct tracked stacks.
            </summary>
        </member>
        <member name="M:VRage.Reflection.StackTracker.Collect(System.Int32)">
            <summary>
            Collect a trace for the current stack and return a handle to it.
            </summary>
            <remarks>
            If the current stack is identical to another already tracked the same handle will be returned and the reference count will be increased.
            </remarks>
            <param name="framesToSkip"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.StackTracker.GetTrace(System.Int32)">
            <summary>
            Get data for a stack trace with the given key.
            </summary>
            <param name="traceId"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.StackTracker.GetReferenceCount(System.Int32)">
            <summary>
            Get the number of references for a given stack trace.
            </summary>
            <param name="traceId"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Reflection.StackTracker.ReleaseTrace(System.Int32)">
            <summary>
            Release a reference to the stack trace with the provided id.
            </summary>
            <param name="traceId"></param>
        </member>
        <member name="T:VRage.Text.ExceptionFormatter">
            <summary>
            Formatter that can be used to write exceptions to the log.
            </summary>
        </member>
        <member name="F:VRage.Text.ExceptionFormatter.Help">
            <summary>
            Contains the following text:
            <code>
            Available arguments are:
            M/G - Only display message (default).
            D - Display stack trace on debug builds, otherwise only the message.
            F - Always display both the message and stack trace.
            </code>
            </summary>
        </member>
        <member name="T:VRage.Text.TypeFormatter">
            <summary>
            Formatter that can be used to write exceptions to the log.
            </summary>
        </member>
        <member name="F:VRage.Text.TypeFormatter.Help">
            <summary>
            Contains the following message:
            <code>
            Available arguments are:
            S - Display simple names.
            G - Display full name for type and simple for generic arguments.
            F - Display full names.
            </code>
            </summary>
        </member>
        <member name="T:VRage.Boxed`1">
            <summary>
            Thin wrapper for value types for type safe boxing.
            </summary>
            <remarks>
            Class types can also be stored in this container, as an alternative to the ref parameter specifier.
            </remarks>
            <typeparam name="T">Value type wrapped by this class.</typeparam>
        </member>
        <member name="T:VRage.MyFixedPoint">
            <summary>
            Fixed point number represented as 64-bit integer with 6 decimal places (one millionts)
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.SerializeString">
            <summary>
            For XmlSerialization, format is 123.456789
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.DeserializeStringSafe(System.String)">
            <summary>
            For XmlSerialization, format is 123.456789
            Handles double and decimal formats too.
            </summary>
        </member>
        <member name="T:VRage.MyTupleComparer`2">
            <summary>
            Use this as a custom comparer for the dictionaries, where the tuple is a key
            </summary>
        </member>
        <member name="T:VRage.MyTupleComparer`3">
            <summary>
            Use this as a custom comparer for the dictionaries, where the tuple is a key
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.AsynchronousLoader`3">
            <summary>
            Simple manager for objects that can be loaded asynchronously but also requested immediately.
            </summary>
            <typeparam name="TKey">The type for an object key.</typeparam>
            <typeparam name="TCreationArgs">The type of the creation arguments for an object.</typeparam>
            <typeparam name="TObject">The type of the loaded or created object</typeparam>
        </member>
        <member name="F:VRage.ParallelWorkers.AsynchronousLoader`3.NullObject">
            <summary>
            Value used for object references that are not valid.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.AsynchronousLoader`3.#ctor(`2,System.Collections.Generic.IEqualityComparer{`0},System.Boolean)">
            <summary>
            Constructor of the async loader.
            </summary>
            <param name="nullObject">provide the instance of placeholder/null object</param>
            <param name="comparer">comparer of object keys</param>
            <param name="rescheduleAfterEachItem">when set to true, async loader reschedules after each loaded item, this prevent starvation of other workers</param>
        </member>
        <member name="M:VRage.ParallelWorkers.AsynchronousLoader`3.HandleConflict(`0,`1@,`1@)">
            <summary>
            Handles
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.AsynchronousLoader`3.GetObjectImmediately(`0)">
            <summary>
            Request an object immediately.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.AsynchronousLoader`3.StartWork(VRage.ParallelWorkers.WorkerGroupId)">
            <summary>
            Start the background worker.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.IWorker">
            <summary>
            Represents publicly visible aspects of a parallel worker.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorker.Name">
            <summary>
            The name of this individual worker.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorker.ManagedThreadId">
            <summary>
            Id of the managed thread associated with this worker.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorker.State">
            <summary>
            State of the worker thread.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorker.Idle">
            <summary>
            Whether this worker is idle and has no work to do.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorker.CurrentTask">
            <summary>
            Get's the Id of the current item this worker is working on, if any.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.IWorkerManager">
            <summary>
            Interface describing a manager for work execution and scheduling.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorkerManager.DefaultGroup">
            <summary>
            Get the Id of the default worker group in this manager's configuration.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorkerManager.CurrentWorker">
            <summary>
            Worker for the current thread.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.IWorkerManager.CurrentWork">
            <summary>
            The work item currently being executed.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.UpdateWorkerConfiguration(VRage.ParallelWorkers.WorkerConfiguration@)">
            <summary>
            Update the worker configuration for this manager.
            </summary>
            <remarks>
            This method will lock all other threads while the configuration is set up, this can take several milliseconds.
            </remarks>
            <exception cref="T:System.ArgumentException">When the configuration is not valid.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.GetWorkerConfiguration">
            <summary>
            Get a copy of the current configuration.
            </summary>
            <returns>A copy of the current configuration.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.Close">
             <summary>
             Stop all workers and close the manager.
            
             It is an error to invoke any other methods in this instance after this.
             </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.EnqueueWork(VRage.ParallelWorkers.IWork,System.Nullable{VRage.ParallelWorkers.WorkerGroupId})">
            <summary>
            Enqueue a piece of work to be executed by some worker.
            </summary>
            <param name="work">The work to be executed.</param>
            <param name="group">The worker group to execute this work. If none or Null is provided the default is used.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.EnqueueWorkGroup(VRage.ParallelWorkers.IWork,System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
             <summary>
             Enqueue a piece of work to be executed by all workers.
            
             This differs from regular enqueue in that the task is scheduled for each worker of the requested group,
             , if no group Id is provided then the default group is used.
             </summary>
             <param name="work">The work to be executed.</param>
             <param name="group">The worker group to execute this work. If none or Null is provided then the default is taken.</param>
             <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.EnqueueWorkAll(VRage.ParallelWorkers.IWork)">
             <summary>
             Enqueue a piece of work to be executed by all workers.
            
             This differs from regular enqueue in that the task is scheduled for each worker.
             </summary>
             <param name="work">The work to be executed.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.AddCompletion(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.ICompletion)">
            <summary>
            Request that the provided completion object be invoked upon completion of the task identified by the given work id.
            </summary>
            <param name="work">The id of the work to listen to.</param>
            <param name="callback">The completion callback to be invoked upon the work finishing.</param>
            <remarks>
            The completion object will be invoked on the thread executing the work.
            Unless it has already completed, in which case it is invoked immediately by this call.
            </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.ExecutePendingWork(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)">
            <summary>
            Execute a work item that has already been queued.
            </summary>
            <remarks>
            This call is akin to stealing a work item from the queue.
            
            If the work is to be carried by multiple workers the caller will act as if it were one of them.
            </remarks>
            <param name="workId">The id of the work to execute.</param>
            <param name="work">The work item to execute.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.ParallelWorkers.IWorkerManager.IsComplete(VRage.ParallelWorkers.WorkId)" -->
        <member name="M:VRage.ParallelWorkers.IWorkerManager.WaitOn(VRage.ParallelWorkers.WorkId)">
             <summary>
             Wait on a piece work to be finished.
            
             This will block the calling thread until all workers that might be processing the work are finished.
             </summary>
             <param name="work">The id of the work to wait on.</param>
             <remarks>
             Calling this on a worker may deadlock.
            
             Workers have so called 'personal' queues of work items. These queues are appended to by calls to EnqueueAll.
             If a worker waits on a task that is in it's personal queue it will then deadlock that worker.
             Any other thread that waits on a task that worker would perform will likewise be stuck.
            
             To avoid that be very careful with the tasks you wait on inside workers, preferably always wait on tasks that
             are issued with the Enqueue call as those can be performed by any worker in the group, which means as long as
             at least one is idle it will not deadlock.
             </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.WaitAll(System.Nullable{System.TimeSpan})">
             <summary>
             Wait on all workers to be idle.
            
             This call will only return after the specified timeout or when all workers are idle.
             </summary>
             <returns>Whether the call returned because all workers became idle (true) or because the timeout was reached.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.IsWorker(System.Threading.Thread)">
            <summary>
            Tell whether a given thread is the thread used by one of our workers.
            </summary>
            <param name="thread">The thread to lookup</param>
            <returns>Whether the argument thread represents a worker.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.IsCurrentThreadWorker">
            <summary>
            Tell whether the current thread is a worker.
            </summary>
            <param name="thread">The thread to lookup</param>
            <returns>Whether the argument thread represents a worker.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.GetWorkerCount(VRage.ParallelWorkers.WorkerGroupId)">
             <summary>
             Get the number of workers in a group.
            
             If this worker does not have that group this method returns 0.
             </summary>
             <param name="groupId">The id of the worker group to query, if Null is provided the default is used.</param>
             <returns>The number of workers in the found group, or zero.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.IWorkerManager.GetWorkerStatus">
            <summary>
            Get status information about worker threads in each worker group.
            
            This information changes in real time (even as it's queried) so it's important to take it only as a sample.
            </summary>
            <returns>An enumeration of each group, the number of active workers on that group, and the number of total workers on that group.</returns>
        </member>
        <member name="E:VRage.ParallelWorkers.IWorkerManager.AfterWorkersCreated">
            <summary>
            Event fired after all workers have been created.
            </summary>
        </member>
        <member name="E:VRage.ParallelWorkers.IWorkerManager.BeforeWorkersDestroyed">
            <summary>
            Event fired before workers are destroyed. Any work scheduled inside this callback will be executed.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.RecurringWork">
            <summary>
            Simple struct that makes it easier to schedule long frequently running jobs.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.SynchronousWorkerManager">
            <summary>
            Simple worker manager that does not execute any parallel work.
            </summary>
            <remarks>
            This worker is useful when debugging a program to find if the source of a bug is the asynchronous execution.
            </remarks>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_config">
            <summary>
            Our config.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_currentWork">
            <summary>
            Work being executed by the current thread.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_idTracker">
            <summary>
            Counter for work Ids
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_completions">
            <summary>
            Completion data for each work item.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_workData">
            <summary>
            Work data for each work item.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_executing">
            <summary>
            Set of work items currently in execution.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.m_workQueues">
            <summary>
            Per callback runner queues.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.SynchronousWorkerManager.DataLock">
            <summary>
            Lock used when modifying work data or callbacks.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.SynchronousWorkerManager.Queue.Scheduled">
            <summary>
            Whether this queue is scheduled to be processed.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.SynchronousWorkerManager.Queue.Count">
            <summary>
            The current number of items in the queue.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecuteWork(VRage.ParallelWorkers.WorkId)">
            <summary>
            Execute a work item.
            </summary>
            <remarks>
            If another thread stole the work (via <see cref="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecutePendingWork(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)"/> or <see cref="M:VRage.ParallelWorkers.SynchronousWorkerManager.WaitOn(VRage.ParallelWorkers.WorkId)"/>) this method will skip it.
            </remarks>
            <param name="id"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecuteOrWait(VRage.ParallelWorkers.WorkId)">
            <summary>
            Execute or wait for an item to complete.
            </summary>
            <remarks>
            If another thread stole the work (via <see cref="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecutePendingWork(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)"/> or <see cref="M:VRage.ParallelWorkers.SynchronousWorkerManager.WaitOn(VRage.ParallelWorkers.WorkId)"/>) this method will wait for it to finish.
            </remarks>
            <param name="id"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecuteInternal(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)">
            <summary>
            Perform the actual execution of a work item and callbacks.
            </summary>
            <param name="id"></param>
            <param name="work"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.SynchronousWorkerManager.ExecuteQueue">
            <summary>
            Execute all work queued for the current thread.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.ActionCompletion">
            <inheritdoc />
            <summary>
            Wrapper for a completion callback that is implemented as an action.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.ActionDataCompletion`1">
            <inheritdoc />
            <summary>
            </summary>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.ActionDataWork`1">
            <inheritdoc />
            <summary>
            Represents work that takes a generic argument.
            </summary>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.ActionWork">
            <inheritdoc />
            <summary>
            Represents a piece of work that takes no arguments.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.CompletionBase`1">
            <inheritdoc />
            <summary>
            Base class for complex completion callbacks.
            </summary>
            <typeparam name="TChild">Should be the child class when inheriting from this.</typeparam>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.ForEachWork`1">
            <inheritdoc />
            <summary>
            Implements work that executes a callback for each element of an enumeration.
            </summary>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="M:VRage.ParallelWorkers.Work.ForEachWork`1.Get(System.Collections.Generic.IEnumerable{`0},System.Action{`0},System.Int32)">
            <summary>
            Prepare this work for execution.
            </summary>
            <param name="enumerable"></param>
            <param name="action"></param>
            <param name="stride"></param>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.GenericWork">
            <inheritdoc />
            <summary>
            Represents a piece of work that executes an IWork.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.SynchronizedCompletion">
            <inheritdoc />
            <summary>
            A completion callback that enqueues a synchronized callback into a completion buffer.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Work.WorkBase`1">
            <inheritdoc />
            <summary>
            Implements a work object that maintains the worker threads work buffer.
            </summary>
            <typeparam name="TChild">Should be the type of the child class.</typeparam>
        </member>
        <member name="T:VRage.ParallelWorkers.ICompletion">
            <summary>
            Interface describing a listener for the completion of some work.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.ICompletion.Completed">
            <summary>
            Inform that the work item waited on has finished.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.IWork">
            <summary>
            Interface describing a piece of work that can be executed by a worker manager.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.IWork.DoWork">
            <summary>
            Execute the actual work.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Workers">
            <summary>
            A wrapper for a worker manager that facilitates common operations and provides extra abstractions for work tracking, and completion.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.InitDefault">
             <summary>
             Initialize with the default configuration.
             </summary>
             <remarks>
             This initialization is automatically performed the first time one of the methods in this class is invoked if no prior initialization happens.
            
             The default configuration is a single group with id <see cref="F:VRage.ParallelWorkers.WorkerGroupId.Default"/> and as many workers as the current cpu has logical cores.
             </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.GetDefaultConfiguration">
            <summary>
            Get the default configuration for the worker manager.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Init(VRage.ParallelWorkers.WorkerConfiguration@)">
            <summary>
            Set up the default worker manager with the provided configuration.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Init(VRage.ParallelWorkers.IWorkerManager)">
            <summary>
            Initialize with a default worker manager.
            </summary>
            <param name="manager">The worker manager to use.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.UpdateConfiguration(VRage.ParallelWorkers.WorkerConfiguration@)">
            <summary>
            Set up the internal worker manager with the provided configuration.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Close">
            <summary>
            Close the current worker manager and clean up any static data structures.
            </summary>
            <remarks>
            Make sure that no mere work is being submitted before calling this.
            
            Also make sure this is invoked from the same thread that initialized the workers.
            </remarks>
            <exception cref="T:System.InvalidOperationException">When invoked from a different thread than the one in which <c>Init()</c> was called.</exception>
        </member>
        <member name="P:VRage.ParallelWorkers.Workers.Manager">
            <summary>
            Global worker manager.
            </summary>
            <remarks>
            For normal use one should prefer the methods in this class than to use the manager directly.
            </remarks>
        </member>
        <member name="P:VRage.ParallelWorkers.Workers.CurrentExecutingWork">
            <summary>
            The work currently being executed by the current thread.
            </summary>
            <remarks>
            This property is valid whenever a task is being executed, even if outside a worker (for instance via <see cref="M:VRage.ParallelWorkers.WorkHandle.ExecuteOrWait"/>).
            </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.For(System.Int32,System.Int32,System.Action{System.Int32},System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Iterate over an integer range, using all workers in the provided group.
            </summary>
            <param name="start">Inclusive start index.</param>
            <param name="end">Exclusive end index.</param>
            <param name="body">Callback to be invoked upon iteration.</param>
            <param name="group">Id of the worker group to execute this iteration.</param>
            <param name="batching">Number of iterations to execute in batch per worker (if needed to increase locality, reduce scheduling overhead).</param>
            <returns>A for loop handler for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Iterate over a collection, using all workers in the provided group.
            </summary>
            <typeparam name="T">The type of the enumeration's elements.</typeparam>
            <param name="collection">The object to enumerate.</param>
            <param name="action">A callback to be invoked for each element of the enumeration.</param>
            <param name="group">Id of the worker group to execute this iteration.</param>
            <param name="batching">Number of iterations to execute in batch per worker (if needed to increase locality, reduce scheduling overhead).</param>
            <returns>A for loop handler for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ScheduleCallback(System.Action,System.Boolean)">
            <summary>
            Schedule a callback to be invoked by the current callback thread.
            </summary>
            <param name="callback">The callback to be invoked.</param>
            <param name="allowDefault">Whether to use the default callback thread if the current is null.</param>
            <exception cref="T:System.InvalidOperationException">Fired when the current callback thread is null (not set), and using the default was not allowed.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ScheduleCallback(VRage.ParallelWorkers.ICompletion,System.Boolean)">
            <summary>
            Schedule a callback to be invoked by the current callback thread.
            </summary>
            <param name="callback">The callback to be invoked.</param>
            <param name="allowDefault">Whether to use the default callback thread if the current is null.</param>
            <exception cref="T:System.InvalidOperationException">Fired when the current callback thread is null (not set), and using the default was not allowed.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ScheduleCallback(System.Action,System.Threading.Thread)">
            <summary>
            Schedule a callback to be invoked by a specific callback runner.
            </summary>
            <param name="callback">The callback to be invoked.</param>
            <param name="callbackThread">The thread that should execute the callback.</param>
            <exception cref="T:System.InvalidOperationException">Fired if <paramref name="callbackThread"/> is not registered as a callback runner.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ScheduleCallback(VRage.ParallelWorkers.ICompletion,System.Threading.Thread)">
            <summary>
            Schedule a callback to be invoked by a specific callback runner.
            </summary>
            <param name="callback">The callback to be invoked.</param>
            <param name="callbackThread">The thread that should execute the callback.</param>
            <exception cref="T:System.InvalidOperationException">Fired if <paramref name="callbackThread"/> is not registered as a callback runner.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Do(System.Action,System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Execute a worker action in a worker thread.
            </summary>
            <param name="action">The action to be invoked.</param>
            <param name="group">The worker group to execute this action.</param>
            <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
            <returns>A handle for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Do``1(``0,System.Action{``0},System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Execute a worker action with some data in a worker thread.
            </summary>
            <typeparam name="TData">The type of the action's argument.</typeparam>
            <param name="data">The data to be provided to the callback.</param>
            <param name="action">The action to be invoked.</param>
            <param name="group">The worker group to execute this action.</param>
            <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
            <returns>A handle for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Do``1(``0,System.Action{``0},System.Action{``0},System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Execute a worker action with some data in a worker thread.
            </summary>
            <typeparam name="TData">The type of the action and callback's argument.</typeparam>
            <param name="data">The data to be provided to the callback.</param>
            <param name="action">The action to be invoked.</param>
            <param name="callback">A callback to be executed in the current callback thread once the work is complete.</param>
            <param name="group">The worker group to execute this action.</param>
            <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
            <returns>A handle for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.Do(VRage.ParallelWorkers.IWork,System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
            <summary>
            Execute some work in a worker thread.
            </summary>
            <param name="iWork">The work to be executed.</param>
            <param name="group">The worker group to execute this work.</param>
            <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
            <returns>A handle for the scheduled work.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.CheckInitialized">
            <summary>
            Check that workers have been initialized and are ready to use.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Workers.CompletionBuffer">
            <summary>
            Represents a completion queue.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.Workers.m_ownedCompletionBuffer">
            <summary>
            The completion buffer owned by the current thread.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.Workers.m_currentCompletionBuffer">
             <summary>
             Stack of completion buffers for callbacks on the current thread.
             </summary>
             <remarks>
             When a work starts executing it will set the callback based on the thread that scheduled it.
            
             Since work can be executed recursively (via waiting) we need to maintain the buffers as a stack,
             to make sure that no completion winds up in the wrong thread.
             </remarks>
        </member>
        <member name="F:VRage.ParallelWorkers.Workers.m_defaultCompletionBuffer">
            <summary>
            The default completion buffer, on the 'main' thread.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.Workers.Buffers">
            <summary>
            Per thread completion buffer set.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.RunCallbacks">
             <summary>
             Run all callbacks for the current thread.
            
             This must be called once before any work can be scheduled to be completed on the current thread.
             </summary>
             <remarks>
             Completion callbacks are asynchronous calls that can be queued to execute after some parallel work
             is finished. They are a non-blocking and thread safe alternative to waiting (<see cref="M:VRage.ParallelWorkers.WorkHandle.Wait"/>).
             
             Completion callbacks are scheduled based on the target buffer for the current thread. These can be set in a few ways:
             <ul>
               <li>Main thread callback buffer: The *main thread* (the thread that called one of the <c>Init</c> methods) will automatically
               receive a buffer and be designated a callback runner.</li>
               <li>Callback runner buffer: Any thread that invokes RunCallbacks is registered as a callback runner, and get's it's own buffer.
                 An example of this behavior is a render thread, that wants callbacks for it's jobs to be executed by it and not the main thread.</li>
               <li>Worker buffer stack: Workers maintain a stack of destination buffers. While they cannot be callback runners themselves they
                 will have the callback buffer set based on the thread that scheduled the currently executing job. That way if a job is scheduled in a parallel
                 it will complete on the same thread as the job that scheduled it.</li>
             </ul>
             
             If work is scheduled with completion from a thread that is neither a worker or a callback runner
             it will complete on the <b>Main Thread</b>.
             </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.GetCurrentCompletionThread">
            <summary>
            Get the thread that is scheduled to run completions for the current thread.
            </summary>
            <returns>The thread that currently is set to execute completions for newly scheduled works.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.ClearCallbacks">
            <summary>
            Clear all pending callbacks.
            
            Use this with care.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.GetCompletionBuffer(System.Boolean)">
            <summary>
            Get the target completion buffer for the current thread.
            </summary>
            <param name="allowDefault">Whether to use the default if the current thread does not have one.</param>
            <returns>The completion buffer or null if none is set.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.GetCompletionBuffer(System.Threading.Thread)">
            <summary>
            Get the completion buffer for a given thread.
            </summary>
            <param name="completionRunner">The thread whose completion buffer is requested.</param>
            <returns>The completion buffer or null if none is set.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.PushCompletionBuffer(VRage.ParallelWorkers.Workers.CompletionBuffer)">
            <summary>
            Set the target completion buffer for the current thread.
            </summary>
            <param name="buffer">The completion buffer.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.Workers.PopCompletionBuffer">
            <summary>
            Pop the current completion buffer.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerManager">
             <summary>
             Manager of parallel workers.
             </summary>
             <remarks>
             This class tracks workers in groups, which can each have their on priority, affinity, and number of threads.
             Each of these worker groups has a unique identifier that can be used to target them specifically.
            
             The worker manager 
             
             </remarks>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerManager.DefaultGroup">
            <summary>
            Get the Id of the default worker group in this manager's configuration.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.#ctor(VRage.ParallelWorkers.WorkerConfiguration@)">
            <summary>
            Create a new worker manager with the provided configuration.
            </summary>
            <param name="configuration">The worker configuration to create.</param>
            <exception cref="T:System.ArgumentException">When the configuration is not valid.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.Close">
             <summary>
             Stop all workers and close the manager.
            
             It is an error to invoke any other methods in this instance after this.
             </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.UpdateWorkerConfiguration(VRage.ParallelWorkers.WorkerConfiguration@)">
            <summary>
            Update the worker configuration for this manager.
            </summary>
            <remarks>
            This method will lock all other threads while the configuration is set up, this can take several milliseconds.
            </remarks>
            <exception cref="T:System.ArgumentException">When the configuration is not valid.</exception>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.GetWorkerConfiguration">
            <summary>
            Get a copy of the current configuration.
            </summary>
            <returns>A copy of the current configuration.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.EnqueueWork(VRage.ParallelWorkers.IWork,System.Nullable{VRage.ParallelWorkers.WorkerGroupId})">
            <summary>
            Enqueue a piece of work to be executed by some worker.
            </summary>
            <param name="work">The work to be executed.</param>
            <param name="group">The worker group to execute this work. If none or Null is provided the default is used.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.EnqueueWorkGroup(VRage.ParallelWorkers.IWork,System.Nullable{VRage.ParallelWorkers.WorkerGroupId},System.Int32)">
             <summary>
             Enqueue a piece of work to be executed by all workers.
            
             This differs from regular enqueue in that the task is scheduled for each worker of the requested group,
             , if no group Id is provided then the default group is used.
             </summary>
             <param name="work">The work to be executed.</param>
             <param name="group">The worker group to execute this work. If none or Null is provided then the default is taken.</param>
             <param name="maxWorkers">Maximum number of workers that will be allowed work on this task. -1 means all.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.EnqueueWorkAll(VRage.ParallelWorkers.IWork)">
             <summary>
             Enqueue a piece of work to be executed by all workers.
            
             This differs from regular enqueue in that the task is scheduled for each worker.
             </summary>
             <param name="work">The work to be executed.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.AddCompletion(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.ICompletion)">
            <summary>
            Request that the provided completion object be invoked upon completion of the task identified by the given work id.
            </summary>
            <param name="work">The id of the work to listen to.</param>
            <param name="callback">The completion callback to be invoked upon the work finishing.</param>
            <remarks>
            The completion object will be invoked on the thread executing the work.
            Unless it has already completed, in which case it is invoked immediately by this call.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.ParallelWorkers.WorkerManager.IsComplete(VRage.ParallelWorkers.WorkId)" -->
        <member name="M:VRage.ParallelWorkers.WorkerManager.WaitOn(VRage.ParallelWorkers.WorkId)">
             <summary>
             Wait on a piece work to be finished.
            
             This will block the calling thread until all workers that might be processing the work are finished.
             </summary>
             <param name="work">The id of the work to wait on.</param>
             <remarks>
             When waiting on another work inside a worker be sure that there are no wait cycles, such as two tasks that both wait on each other.
            
             Cases where workers wait on items in their own, or other worker's queues are resolved via work stealing, so they do not deadlock (but they might brake the FIFO ordering of the work queues).
             </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.WaitAll(System.Nullable{System.TimeSpan})">
             <summary>
             Wait on all workers to be idle.
            
             This call will only return after the specified timeout or when all workers are idle.
             </summary>
             <returns>Whether the call returned because all workers became idle (true) or because the timeout was reached.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.IsWorker(System.Threading.Thread)">
            <summary>
            Tell whether a given thread is the thread used by one of our workers.
            </summary>
            <param name="thread">The thread to lookup</param>
            <returns>Whether the argument thread represents a worker.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.IsCurrentThreadWorker">
            <summary>
            Tell whether the current thread is a worker.
            </summary>
            <param name="thread">The thread to lookup</param>
            <returns>Whether the argument thread represents a worker.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.GetWorkerCount(VRage.ParallelWorkers.WorkerGroupId)">
             <summary>
             Get the number of workers in a group.
            
             If this worker does not have that group this method returns 0.
             </summary>
             <param name="groupId">The id of the worker group to query, if Null is provided the default is used.</param>
             <returns>The number of workers in the found group, or zero.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.GetWorkerStatus">
            <summary>
            Get status information about worker threads in each worker group.
            
            This information changes in real time (even as it's queried) so it's important to take it only as a sample.
            </summary>
            <returns>An enumeration of each group, the number of active workers on that group, and the number of total workers on that group.</returns>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerManager.CurrentWorker">
            <summary>
            Worker for the current thread.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerManager.CurrentWork">
            <summary>
            The work item currently being executed.
            </summary>
        </member>
        <member name="E:VRage.ParallelWorkers.WorkerManager.AfterWorkersCreated">
            <summary>
            Event fired after all workers have been created.
            </summary>
        </member>
        <member name="E:VRage.ParallelWorkers.WorkerManager.BeforeWorkersDestroyed">
            <summary>
            Event fired before workers are destroyed. Any work scheduled inside this callback will be executed.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.m_configuration">
            <summary>
            Current configuration.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.m_internalsLock">
             <summary>
             Lock used to protect our worker configuration.
            
             Any operation that depends on the current configuration should acquire this lock.
             </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.CheckClosed">
            <summary>
            Check that this worker group has not been closed.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.UpdateConfigInternal(VRage.ParallelWorkers.WorkerConfiguration)">
            <summary>
            Update the configuration.
            </summary>
            <param name="newConfig">The new configuration to use.</param>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.m_groups">
            <summary>
            List of workers per priority.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerManager.WorkerGroup">
            <summary>
            Container for group queue and threads.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerManager.WorkerGroup.WorkCount">
            <summary>
            Number of items in this group's work queue.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.WorkerGroup.DequeueGroupWork(VRage.ParallelWorkers.WorkId)">
            <summary>
            Remove a group work item from the queue.
            </summary>
            <param name="item">The id of the work item.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.WorkerGroup.TrySteal(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.WorkItem@)">
            <summary>
            Try to steal a work item from this group's queue.
            </summary>
            <param name="work"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.GetGroup(VRage.ParallelWorkers.WorkerGroupId)">
            <summary>
            Get the workers for a given priority.
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.WaitAllInternal(System.Nullable{System.TimeSpan})">
            <summary>
            Wait on all worker threads to become idle.
            </summary>
            <param name="timeout">Timeout</param>
            <returns>Whether the wait was successful.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.EnqueueAll(VRage.ParallelWorkers.IWork)">
            <summary>
            Enqueue work on all workers.
            </summary>
            <param name="work">work instance</param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.EnqueueGroup(VRage.ParallelWorkers.IWork,VRage.ParallelWorkers.WorkerGroupId,System.Int32)">
            <summary>
            Enqueue work on all workers within specified group.
            </summary>
            <param name="work">work instance</param>
            <param name="groupId">target work group</param>
            <param name="maxWorkers">Maximum number of worker threads that can work on this item.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.GetAndTrack(VRage.ParallelWorkers.WorkerGroupId,System.Int32,System.Int32)">
            <summary>
            Get a new workId for a work item.
            </summary>
            <param name="group">Id of the group the item is queued to, if the item is queued to multiple queues the group must be set to null.</param>
            <param name="queueCount">Number of queues the work item is queued to.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.NotifyWorkStart(VRage.ParallelWorkers.WorkId,System.Boolean)">
            <summary>
            Notify that one of the workers started the work tracked by the provided workId.
            </summary>
            <param name="workId"></param>
            <returns>returns false when this tracked work has been already finished</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.NotifyWorkEnd(VRage.ParallelWorkers.WorkId)">
            <summary>
            Notify the completion of the work tracked by the provided workId.
            </summary>
            <param name="workId"></param>
            <param name="finished">When set to true, task signals that it finished, it was not re-queued internally.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.DequeueGroupWork(VRage.ParallelWorkers.WorkerManager.TrackerData@,VRage.ParallelWorkers.WorkId)">
            <summary>
            Dequeue a group work item.
            </summary>
            <param name="track"></param>
            <param name="id"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.JoinInternal(VRage.ParallelWorkers.WorkId)">
            <summary>
            Request to wait for a task, returns when the task finishes or immediately if the task has already been completed.
            </summary>
            <param name="work">The workId to join on.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.TryStealWork(VRage.ParallelWorkers.WorkerManager.TrackerData@,VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.WorkItem@)">
            <summary>
            Try to steal a work item form it's queue if possible.
            
            Work items that are on multiple queues cannot be stolen.
            </summary>
            <param name="track">Tracking data for the work item.</param>
            <param name="work">The work item id.</param>
            <param name="item">The stolen work item if that was possible.</param>
            <returns>Whether it was possible to steal the work item from it's queue.</returns>
            <remarks>
            This method assumes the caller to be holding on the tracker lock.
            </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.AddCompleteCallbackInternal(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.ICompletion)">
            <summary>
            Add callback to be invoked when a work item finishes.
            </summary>
            <param name="work">The id of the work item to wait on completion.</param>
            <param name="callback">The completion object invoked when the work item is finished.</param>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerManager.Joiner">
            <summary>
            Reference counting helper for the manual reset event which
            allows tracking the last waiter on the event.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.Joiner.Wait">
            <summary>
            Join and return whether the reference count reached zero.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerManager.TrackerData">
            <summary>
            Metadata about a work item.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.TrackerData.QueueReferenceCount">
            <summary>
            Number of references to this work item in queues.
            
            Decreases upon dequeue.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.TrackerData.ExecutionReferenceCount">
            <summary>
            Number of workers currently executing this item.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.TrackerData.Queue">
            <summary>
            Worker group queue if any.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.TrackerData.MaxWorkers">
            <summary>
            Maximum number of workers allowed to execute this task simultaneously.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerManager.TrackerData.Pending">
            <summary>
            Whether this work item is still queued and not being executed.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerManager.m_currentWork">
            <summary>
            Id of the current work item being executed, this is valid even for non worker threads.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.VRage#ParallelWorkers#IWorkerManager#ExecutePendingWork(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)">
            <summary>
            Execute a work item.
            </summary>
            <param name="workId">The id of the work to execute.</param>
            <param name="removeFromQueue">Whether the work item is to be removed from it's queue.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.ExecuteWork(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork,System.Boolean)">
            <summary>
            Execute a work item.
            </summary>
            <param name="workId">The id of the work to execute.</param>
            <param name="work">The work item to execute.</param>
            <param name="removeFromQueue">Whether the work item is to be removed from it's queue.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerManager.Wait(System.Threading.ManualResetEventSlim)">
            <summary>
            Wait on a event, does extra checks on debug builds.
            </summary>
            <param name="event"></param>
        </member>
        <member name="T:VRage.ParallelWorkers.CompoundCompletion">
            <summary>
            A A completion instance that can be used to make a list of completions.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.Worker">
            <summary>
            Class representing a background worker.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.Name">
            <inheritdoc />
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.ManagedThreadId">
            <inheritdoc />
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.State">
            <inheritdoc />
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.Idle">
            <inheritdoc />
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.CurrentTask">
            <inheritdoc />
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.ThreadInstance">
            <summary>
            Worker assigned to the current thread if any.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.Thread">
            <summary>
            Managed thread that executes this worker.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.IdleGate">
            <summary>
            Event set by the worker as the worker becomes idle and then reset upon waking up.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.Worker.IsSleeping">
            <summary>
            Whether this worker is currently sleeping.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.EnqueueWork(VRage.ParallelWorkers.WorkItem)">
            <summary>
            Enqueue work to this worker's personal queue.
            </summary>
            <param name="workItem"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.WakeUp">
            <summary>
            Wake up this worker.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.Stop">
            <summary>
            Stop this worker.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.TryDequeueWork(VRage.ParallelWorkers.WorkItem@,System.Boolean@)">
            <summary>
            Try to get some work from the personal queue.
            </summary>
            <param name="workItem">The located work if any.</param>
            <returns>Whether some work item was found.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.TryDequeuePersonal(VRage.ParallelWorkers.WorkItem@)">
            <summary>
            Try to dequeue an work item from the personal queue.
            </summary>
            <param name="workItem">Personal item.</param>
            <returns>Whether an item could be de-queued.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.Worker.WorkLoop">
            <summary>
            Main loop for this worker thread.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerConfiguration">
            <summary>
            Describes a configuration of worker threads for ParallelWorkers.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerConfiguration.Group">
            <summary>
            Defines a group of threads of same priority.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Group.Id">
            <summary>
            Name of this thread group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Group.Priority">
            <summary>
            The priority of the threads.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Group.CpuAffinity">
            <summary>
            Array of CPU cores that this work group will be allowed to run on.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Group.Count">
            <summary>
            The amount of threads in this group.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfiguration.Group.#ctor(VRage.ParallelWorkers.WorkerGroupId,System.Threading.ThreadPriority,System.Int32,System.Int32[])">
            <summary>
            Specify a worker group.
            </summary>
            <param name="id">Id of the group.</param>
            <param name="priority">Priority of workers in this group.</param>
            <param name="count">Number of workers in this group.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfiguration.Group.Clone">
            <summary>
            Make a deep copy of this group definition.
            </summary>
            <returns></returns>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.WorkerGroups">
            <summary>
            Named worker groups.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Default">
            <summary>
            Default worker group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.TotalWorkers">
            <summary>
            Total workers in this configuration.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerConfiguration.IsValid">
            <summary>
            Whether this configuration is valid.
            A valid configuration a non empty list of groups where each group
            has at least one worker specified and no group has the same id as another group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfiguration.Null">
            <summary>
            A configuration with no groups.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfiguration.Clone">
            <summary>
            Make a deep copy of this configuration.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerConfigurationFactory">
            <summary>
            Helper for constructing valid worker configurations.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerConfigurationFactory.Group">
            <summary>
            Group descriptor.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfigurationFactory.Group.Id">
            <summary>
            Id of this worker group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfigurationFactory.Group.Priority">
            <summary>
            Priority of threads in this worker group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfigurationFactory.Group.Min">
            <summary>
            Minimum number of workers in this group.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerConfigurationFactory.Group.Ratio">
            <summary>
            Worker ratio with regard to other groups in the same configuration.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfigurationFactory.AddGroup(VRage.ParallelWorkers.WorkerConfigurationFactory.Group)">
            <summary>
            Add a group to this factory.
            </summary>
            <param name="group"></param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfigurationFactory.SetCpuAffinity(System.Int32[])">
            <summary>
            Set the CPU affinity used for all workers.
            </summary>
            <param name="affinity">List of CPU indices where the worker threads may be scheduled.</param>
            <seealso cref="M:VRage.Library.Threading.ProcessUtil.SetThreadProcessorAffinity(System.Int32[])"/>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfigurationFactory.SetDefault(VRage.ParallelWorkers.WorkerGroupId)">
            <summary>
            Set the default worker group id for the produced configuration.
            </summary>
            <param name="groupId">The group id to be set as default.</param>
            <returns>This instance so the callas can be chained.</returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerConfigurationFactory.Bake(System.Int32)">
            <summary>
            Bake the configuration to a given maximum number of threads.
            </summary>
            <param name="workerCount">The desired number of workers.</param>
            <returns>A valid worker configuration with the provided groups.</returns>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkerGroupId">
            <summary>
            Identifier for a worker group.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkerGroupId.Name">
            <summary>
            Name of this worker group.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerGroupId.Register(System.String)">
            <summary>
            Register a worker group id.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkerGroupId.TryGet(System.String,VRage.ParallelWorkers.WorkerGroupId@)">
            <summary>
            Try and get a group id from it's name.
            </summary>
            <param name="name">The name of the group.</param>
            <param name="id">The group id or <see cref="F:VRage.ParallelWorkers.WorkerGroupId.Null"/> if not found.</param>
            <returns>Whether the id was found.</returns>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerGroupId.Null">
            <summary>
            Null work group id instance.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkerGroupId.Default">
            <summary>
            Null work group id instance.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkHandle">
            <summary>
            Handle for a scheduled work.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkHandle.m_id">
            <summary>
            Id of the work.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkHandle.m_work">
            <summary>
            Reference to the executed work.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.#ctor(VRage.ParallelWorkers.WorkId,VRage.ParallelWorkers.IWork)">
            <summary>
            Create a new handle from a work id.
            </summary>
            <param name="id"></param>
            <param name="work"></param>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkHandle.IsComplete">
            <summary>
            Whether work tracked by this handle has completed.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkHandle.Id">
            <summary>
            Id of the work.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkHandle.Work">
            <summary>
            Reference to the work object that is to be executed.
            </summary>
        </member>
        <member name="P:VRage.ParallelWorkers.WorkHandle.IsNull">
            <summary>
            whether this handled points to the null work id.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.Wait">
            <summary>
            Block and wait for the work to finish.
            </summary>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.ExecuteOrWait">
             <summary>
             Wait or execute the work. Returns when the work is finished.
             </summary>
             <remarks>
             If the work item can be executed on multiple workers the current thread will participate.
            
             Otherwise if the work is not scheduled yet it will be removed from the queue and executed on the current thread.
            
             If the work has reached it's execution limit this method suspends the calling thread until the work is finished.
             </remarks>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.OnComplete(System.Action)">
            <summary>
            Add a completion callback to be invoked in the current, or the default callback thread.
            </summary>
            <param name="callback">The callback to be invoked.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.OnComplete(VRage.ParallelWorkers.ICompletion)">
            <summary>
            Add a completion to be invoked in the current, or the default callback thread.
            </summary>
            <param name="completion">The completion to be invoked.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.OnCompleteAsync(System.Action)">
            <summary>
            Add a completion callback to be invoked on the worker as soon as the work is done.
            </summary>
            <param name="callback">The callback to be invoked.</param>
        </member>
        <member name="M:VRage.ParallelWorkers.WorkHandle.OnCompleteAsync(VRage.ParallelWorkers.ICompletion)">
            <summary>
            Add a completion to be invoked on the worker as soon as the work is done.
            </summary>
            <param name="completion">The completion to be invoked.</param>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkId.Null">
            <summary>
            An invalid work item id.
            </summary>
        </member>
        <member name="T:VRage.ParallelWorkers.WorkItem">
            <summary>
            Represents a tracked work object.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkItem.Id">
            <summary>
            Unique identification of this work item.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkItem.Work">
            <summary>
            Work to execute.
            </summary>
        </member>
        <member name="F:VRage.ParallelWorkers.WorkItem.GroupWork">
            <summary>
            Whether this work item is to be executed by the whole group until finished.
            </summary>
        </member>
        <member name="T:VRage.Profiler.MyProfiler">
            <summary>
            Part of MyRenderProfiler, this is per-thread profiler
            </summary>
        </member>
        <member name="F:VRage.Profiler.MyProfiler.AutoCommit">
            <summary>
            Enable for background workers.
            It will automatically commit after top level profiling block is closed
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.OnHistorySafe">
            <summary>
            End operation on history data
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.CommitFrame">
            <summary>
            Adds current frame to history and clear it
            Returns number of calls this frame
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.ClearFrame">
            <summary>
            Clears current frame.
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfilerBlock.Clear">
            <summary>
            Clears immediate data
            </summary>
        </member>
        <member name="T:VRage.ConstructorHelper`1">
            <summary>
            Helpers for constructor.
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.ConstructorHelper`1.CreateInPlaceConstructor(System.Type)" -->
        <member name="T:VRage.Security.Md5.Hash">
            <summary>
            Represent digest with ABCD
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.Hash.ReverseByte(System.UInt32)">
            <summary>
            perform a ByteReversal on a number
            </summary>
            <param name="uiNumber">value to be reversed</param>
            <returns>reversed value</returns>
        </member>
        <member name="M:VRage.Security.Md5.RotateLeft(System.UInt32,System.UInt16)">
            <summary>
            Left rotates the input word
            </summary>
            <param name="uiNumber">a value to be rotated</param>
            <param name="shift">no of bits to be rotated</param>
            <returns>the rotated value</returns>
        </member>
        <member name="F:VRage.Security.Md5.T">
            <summary>
            lookup table 4294967296*sin(i)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[])">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[],VRage.Security.Md5.Hash)">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransF(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransG(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <member name="M:VRage.Security.Md5.TransH(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using h(b^c^d)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.TransI(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using i (c^(b|~d))
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.PerformTransformation(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32*)">
            <summary>
            Perform All the transformation on the data
            </summary>
            <param name="A">A</param>
            <param name="B">B </param>
            <param name="C">C</param>
            <param name="D">D</param>
        </member>
        <member name="M:VRage.Security.Md5.CopyBlock(System.Byte[],System.UInt32,System.UInt32*)">
            <summary>
            Copies a 512 bit block into X as 16 32 bit words
            </summary>
            <param name="bMsg"> source buffer</param>
            <param name="block">no of block to copy starting from 0</param>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create non-resetable Stream, optionally expandable
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor">
            <summary>
            Creates resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates and initializes resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="E:VRage.Service.ExitListenerSTA.OnExit">
            <summary>
            Raised when close message is sent to thread message pump (e.g. "taskkill.exe /im MyApp.exe")
            Use only in windowless applications!
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Clear">
            <summary>
            Clears all stats (doesn't remove them)
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.RemoveAll">
            <summary>
            Removes all stats
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Remove(System.String)">
            <summary>
            Remove a stat
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Increment(System.String,System.Int32,System.Int32)">
            <summary>
            Increments an internal counter with given name and sets it to refresh after given time has passed.
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.Component">
            <summary>
            Represents a component which may contain dependencies.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.Component.Type">
            <summary>
            The type of the component.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.Component.Default">
            <summary>
            Default implementation for this component when the type is abstract or an interface.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.Component.AllowCreation">
            <summary>
            Whether to allow
            </summary>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.Dependency">
            <summary>
            Represents a dependency between two components.
            </summary>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.DependencyException">
            <summary>
            Exception during dependency resolution.
            </summary>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.DependencyFlags">
            <summary>
            Flags specifying how a dependency is handled.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyFlags.Recursive">
            <summary>
            Implicitly depend on every child type as well.
            </summary>
            <remarks>
            On some object types dependencies are always recursive, in those cases this flag is ignored.
            </remarks>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyFlags.Critical">
            <summary>
            Mark this dependency as critical, meaning the annotated object cannot be used without the object that it depends on.
            </summary>
            <remarks>
            Critical dependencies when not met will cause a <see cref="T:VRage.Utils.DependencyResolve.DependencyException"/>, unless the component depended on
            allows it's instantiation in that case (see <see cref="F:VRage.Utils.DependencyResolve.Component.AllowCreation"/>).
            </remarks>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyFlags.Reverse">
            <summary>
            Marks a dependency as having reversed ordering.
            </summary>
            <remarks>
            A reverse dependency expresses the same object requirement relation with an inverse ordering relation
            (i.e.: The first type still depends on the second but should be placed before the later in the parent container).
            </remarks>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.DependencyResolveError">
            <summary>
            Encodes the possible causes for error when resolving dependencies using the dependency resolver.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyResolveError.None">
            <summary>
            Default value, not use in an actual exception.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyResolveError.UnresolvedAbstractType">
            <summary>
            Dependency on abstract type or interface could not be resolved to a known concrete type or default.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyResolveError.DependencyCycle">
            <summary>
            The dependency graph contains a cycle.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyResolveError.InvalidType">
            <summary>
            A dependency on the graph contains objects that are not valid instances of the common base type.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.DependencyResolveError.MissingCriticalDependency">
            <summary>
            A critical dependency could not be met.
            </summary>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.TypeDependencyMapper">
            <summary>
            Helper class
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.ErrorHandler">
            <summary>
            Handler for resolution errors. If this handler is not set or returns false an exception is thrown.
            </summary>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.#ctor(System.Type,System.Boolean,VRage.Utils.DependencyResolve.DependencyFlags)">
            <summary>
            Set up the resolver.
            </summary>
            <param name="baseType">The relevant base type for dependencies.</param>
            <param name="defaultAllowCreate">
            The default value of the <see cref="F:VRage.Utils.DependencyResolve.Component.AllowCreation"/> flag for components
            indexed from dependencies.
            </param>
            <param name="defaultFlags">
            Default dependency flags, these are combined with the value of
            <see cref="F:VRage.Utils.DependencyResolve.Dependency.Flags"/> for each dependency in this resolver.
            </param>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_baseType">
            <summary>
            Base type for all concrete component types.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_types">
            <summary>
            Description of each type.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_dependencies">
            <summary>
            Mapping of type to it's dependencies.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_childTypes">
            <summary>
            Map of a type to all of it's children.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_baseTypes">
            <summary>
            Mapping of a type to all of it's relevant base types.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_defaultFlags">
            <summary>
            Default dependency flags.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_defaultAllowCreate">
            <summary>
            Default allow create flag for components that are not provided but discovered from dependencies.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.m_comparer">
            <summary>
            Comparer used to sort component lists.
            </summary>
        </member>
        <member name="P:VRage.Utils.DependencyResolve.TypeDependencyMapper.Comparer">
            <summary>
            Comparer used to sort component lists.
            </summary>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.Set(System.Collections.Generic.IEnumerable{VRage.Utils.DependencyResolve.Component},System.Collections.Generic.IEnumerable{VRage.Utils.DependencyResolve.Dependency})">
            <summary>
            Set the dependencies and components of
            </summary>
            <param name="components"></param>
            <param name="dependencies"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.GetComponentIndex(System.Type)">
            <summary>
            Get the global dependency based index of a component.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.GetDerivedTypes(System.Type)">
            <summary>
            Get a collection of all known types derived from <paramref name="type"/>.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.GetParentTypes(System.Type)">
            <summary>
            Get a collection of all the parent types of <paramref name="type"/>.
            </summary>
            <remarks>
            This includes the entire type hierarchy up to the common base and all interfaces.
            </remarks>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.EnsureComponentType(System.Type)">
            <summary>
            Ensure that the provided type is indexed.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.CheckType``1(System.Type,``0,System.Boolean)">
            <summary>
            Check that the provided type is valid for use.
            </summary>
            <typeparam name="TContainer"></typeparam>
            <param name="type"></param>
            <param name="container"></param>
            <param name="allowInterface"></param>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.MapHierarchy(System.Type)">
            <summary>
            Map the type's hierarchy.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.IterateTypeHierarchy(System.Type)">
            <summary>
            Iterate all elements of the type's hierarchy leading up to the relevant base.
            </summary>
            <param name="type">The type to iterate.</param>
            <returns>An enumeration including the type and all of it's base types leading up to the relevant base.</returns>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.Error(VRage.Utils.DependencyResolve.DependencyResolveError,System.String,System.Object[])">
            <summary>
            Handle an error during dependency resolution.
            </summary>
            <param name="error">The error code.</param>
            <param name="format">Format string for the message.</param>
            <param name="formatArgs">Optional format arguments.</param>
        </member>
        <member name="T:VRage.Utils.DependencyResolve.TypeDependencyMapper.Resolver">
            <summary>
            Object capable of resolving dependencies on a list of component types.
            </summary>
        </member>
        <member name="F:VRage.Utils.DependencyResolve.TypeDependencyMapper.Resolver.ErrorHandler">
            <summary>
            Handler for resolution errors. If this handler is not set or returns false an exception is thrown.
            </summary>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.Resolver.Resolve(System.Collections.Generic.List{System.Type},System.Collections.Generic.HashSet{System.Type})">
            <summary>
            Resolve missing dependencies and sort the given component list.
            </summary>
            <param name="list">The list of components to resolve.</param>
            <param name="criticalItems">Set that will be used to store the set of components that were critical dependencies. Not used if not provided.</param>
        </member>
        <member name="M:VRage.Utils.DependencyResolve.TypeDependencyMapper.Resolver.Error(VRage.Utils.DependencyResolve.DependencyResolveError,System.String,System.Object[])">
            <summary>
            Handle an error during dependency resolution.
            </summary>
            <param name="error">The error code.</param>
            <param name="format">Format string for the message.</param>
            <param name="formatArgs">Optional format arguments.</param>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_MAXIMIZE">
            <summary>
             Sent when form maximizes
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_MAXIMIZE2">
            <summary>
             Sent when form maximizes because of doubcle click on caption
             JTE: Don't use this constant. As per the documentation, you
                  must mask off the last 4 bits of wParam by AND'ing it
                  with 0xFFF0. You can't assume the last 4 bits. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_CLOSE">
            <summary>
             Closes the form
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_RESTORE">
            <summary>
             Sent when form is maximized from the taskbar
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_RESTORE2">
            <summary>
             Sent when form maximizes because of doubcle click on caption
             JTE: Don't use this constant. As per the documentation, you
                  must mask off the last 4 bits of wParam by AND'ing it
                  with 0xFFF0. You can't assume the last 4 bits. 
            </summary>
        </member>
        <member name="T:VRage.Win32.WinApi.SW">
            <summary>
            Show Commands
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_FORCEMINIMIZE1">
            <summary>
            Minimizes a window, even if the thread that owns the window is not responding. This flag should only be used when minimizing windows from a different thread.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_HIDE">
            <summary>
            Hides the window and activates another window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_MAXIMIZE">
            <summary>
            Maximizes the specified window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_MINIMIZE">
            <summary>
            Minimizes the specified window and activates the next top-level window in the Z order.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_RESTORE">
            <summary>
            Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOW">
            <summary>
            Activates the window and displays it in its current size and position.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWDEFAULT1">
            <summary>
            Sets the show state based on the SW_ value specified in the STARTUPINFO structure passed to the CreateProcess function by the program that started the application.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWMAXIMIZED">
            <summary>
            Activates the window and displays it as a maximized window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWMINIMIZED">
            <summary>
            Activates the window and displays it as a minimized window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWMINNOACTIVE">
            <summary>
            Displays the window as a minimized window. This value is similar to SW_SHOWMINIMIZED, except the window is not activated.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWNA">
            <summary>
            Displays the window in its current size and position. This value is similar to SW_SHOW, except that the window is not activated.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWNOACTIVATE">
            <summary>
            Displays a window in its most recent size and position. This value is similar to SW_SHOWNORMAL, except that the window is not activated.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SW.SW_SHOWNORMAL">
            <summary>
            Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time.
            </summary>
        </member>
        <member name="T:VRage.Win32.WinApi.WM">
            <summary>
            Windows Messages
            Defined in winuser.h from Windows SDK v6.1
            Documentation pulled from MSDN.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NULL">
            <summary>
            The WM_NULL message performs no operation. An application sends the WM_NULL message if it wants to post a message that the recipient window will ignore.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CREATE">
            <summary>
            The WM_CREATE message is sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function. (The message is sent before the function returns.) The window procedure of the new window receives this message after the window is created, but before the window becomes visible.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DESTROY">
            <summary>
            The WM_DESTROY message is sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen. 
            This message is sent first to the window being destroyed and then to the child windows (if any) as they are destroyed. During the processing of the message, it can be assumed that all child windows still exist.
            /// </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOVE">
            <summary>
            The WM_MOVE message is sent after a window has been moved. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZE">
            <summary>
            The WM_SIZE message is sent to a window after its size has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ACTIVATE">
            <summary>
            The WM_ACTIVATE message is sent to both the window being activated and the window being deactivated. If the windows use the same input queue, the message is sent synchronously, first to the window procedure of the top-level window being deactivated, then to the window procedure of the top-level window being activated. If the windows use different input queues, the message is sent asynchronously, so the window is activated immediately. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETFOCUS">
            <summary>
            The WM_SETFOCUS message is sent to a window after it has gained the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KILLFOCUS">
            <summary>
            The WM_KILLFOCUS message is sent to a window immediately before it loses the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENABLE">
            <summary>
            The WM_ENABLE message is sent when an application changes the enabled state of a window. It is sent to the window whose enabled state is changing. This message is sent before the EnableWindow function returns, but after the enabled state (WS_DISABLED style bit) of the window has changed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETREDRAW">
            <summary>
            An application sends the WM_SETREDRAW message to a window to allow changes in that window to be redrawn or to prevent changes in that window from being redrawn. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETTEXT">
            <summary>
            An application sends a WM_SETTEXT message to set the text of a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTEXT">
            <summary>
            An application sends a WM_GETTEXT message to copy the text that corresponds to a window into a buffer provided by the caller. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTEXTLENGTH">
            <summary>
            An application sends a WM_GETTEXTLENGTH message to determine the length, in characters, of the text associated with a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINT">
            <summary>
            The WM_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window. The message is sent when the UpdateWindow or RedrawWindow function is called, or by the DispatchMessage function when the application obtains a WM_PAINT message by using the GetMessage or PeekMessage function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLOSE">
            <summary>
            The WM_CLOSE message is sent as a signal that a window or an application should terminate.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYENDSESSION">
            <summary>
            The WM_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions. If any application returns zero, the session is not ended. The system stops sending WM_QUERYENDSESSION messages as soon as one application returns zero.
            After processing this message, the system sends the WM_ENDSESSION message with the wParam parameter set to the results of the WM_QUERYENDSESSION message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYOPEN">
            <summary>
            The WM_QUERYOPEN message is sent to an icon when the user requests that the window be restored to its previous size and position.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENDSESSION">
            <summary>
            The WM_ENDSESSION message is sent to an application after the system processes the results of the WM_QUERYENDSESSION message. The WM_ENDSESSION message informs the application whether the session is ending.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUIT">
            <summary>
            The WM_QUIT message indicates a request to terminate an application and is generated when the application calls the PostQuitMessage function. It causes the GetMessage function to return zero.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ERASEBKGND">
            <summary>
            The WM_ERASEBKGND message is sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCOLORCHANGE">
            <summary>
            This message is sent to all top-level windows when a change is made to a system color setting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SHOWWINDOW">
            <summary>
            The WM_SHOWWINDOW message is sent to a window when the window is about to be hidden or shown.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WININICHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETTINGCHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEVMODECHANGE">
            <summary>
            The WM_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ACTIVATEAPP">
            <summary>
            The WM_ACTIVATEAPP message is sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.FONTCHANGE">
            <summary>
            An application sends the WM_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TIMECHANGE">
            <summary>
            A message that is sent whenever there is a change in the system time.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CANCELMODE">
            <summary>
            The WM_CANCELMODE message is sent to cancel certain modes, such as mouse capture. For example, the system sends this message to the active window when a dialog box or message box is displayed. Certain functions also send this message explicitly to the specified window regardless of whether it is the active window. For example, the EnableWindow function sends this message when disabling the specified window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETCURSOR">
            <summary>
            The WM_SETCURSOR message is sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEACTIVATE">
            <summary>
            The WM_MOUSEACTIVATE message is sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHILDACTIVATE">
            <summary>
            The WM_CHILDACTIVATE message is sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUEUESYNC">
            <summary>
            The WM_QUEUESYNC message is sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH_JOURNALPLAYBACK Hook procedure. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETMINMAXINFO">
            <summary>
            The WM_GETMINMAXINFO message is sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINTICON">
            <summary>
            Windows NT 3.51 and earlier: The WM_PAINTICON message is sent to a minimized window when the icon is to be painted. This message is not sent by newer versions of Microsoft Windows, except in unusual circumstances explained in the Remarks.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ICONERASEBKGND">
            <summary>
            Windows NT 3.51 and earlier: The WM_ICONERASEBKGND message is sent to a minimized window when the background of the icon must be filled before painting the icon. A window receives this message only if a class icon is defined for the window; otherwise, WM_ERASEBKGND is sent. This message is not sent by newer versions of Windows.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NEXTDLGCTL">
            <summary>
            The WM_NEXTDLGCTL message is sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SPOOLERSTATUS">
            <summary>
            The WM_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DRAWITEM">
            <summary>
            The WM_DRAWITEM message is sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MEASUREITEM">
            <summary>
            The WM_MEASUREITEM message is sent to the owner window of a combo box, list box, list view control, or menu item when the control or menu is created.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DELETEITEM">
            <summary>
            Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT message. The system sends a WM_DELETEITEM message for each deleted item. The system sends the WM_DELETEITEM message for any deleted list box or combo box item with nonzero item data.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VKEYTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_KEYDOWN message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHARTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_CHAR message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETFONT">
            <summary>
            An application sends a WM_SETFONT message to specify the font that a control is to use when drawing text. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETFONT">
            <summary>
            An application sends a WM_GETFONT message to a control to retrieve the font with which the control is currently drawing its text. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETHOTKEY">
            <summary>
            An application sends a WM_SETHOTKEY message to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETHOTKEY">
            <summary>
            An application sends a WM_GETHOTKEY message to determine the hot key associated with a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYDRAGICON">
            <summary>
            The WM_QUERYDRAGICON message is sent to a minimized (iconic) window. The window is about to be dragged by the user but does not have an icon defined for its class. An application can return a handle to an icon or cursor. The system displays this cursor or icon while the user drags the icon.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMPAREITEM">
            <summary>
            The system sends the WM_COMPAREITEM message to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box. Whenever the application adds a new item, the system sends this message to the owner of a combo box or list box created with the CBS_SORT or LBS_SORT style. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETOBJECT">
            <summary>
            Active Accessibility sends the WM_GETOBJECT message to obtain information about an accessible object contained in a server application. 
            Applications never send this message directly. It is sent only by Active Accessibility in response to calls to AccessibleObjectFromPoint, AccessibleObjectFromEvent, or AccessibleObjectFromWindow. However, server applications handle this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMPACTING">
            <summary>
            The WM_COMPACTING message is sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMMNOTIFY">
            <summary>
            WM_COMMNOTIFY is Obsolete for Win32-Based Applications
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WINDOWPOSCHANGING">
            <summary>
            The WM_WINDOWPOSCHANGING message is sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WINDOWPOSCHANGED">
            <summary>
            The WM_WINDOWPOSCHANGED message is sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.POWER">
            <summary>
            Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.
            Use: POWERBROADCAST
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COPYDATA">
            <summary>
            An application sends the WM_COPYDATA message to pass data to another application. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CANCELJOURNAL">
            <summary>
            The WM_CANCELJOURNAL message is posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NOTIFY">
            <summary>
            Sent by a common control to its parent window when an event has occurred or the control requires some information. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUTLANGCHANGEREQUEST">
            <summary>
            The WM_INPUTLANGCHANGEREQUEST message is posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar. An application can accept the change by passing the message to the DefWindowProc function or reject the change (and prevent it from taking place) by returning immediately. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUTLANGCHANGE">
            <summary>
            The WM_INPUTLANGCHANGE message is sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows. These child windows can pass the message to DefWindowProc to have it pass the message to their child windows, and so on. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TCARD">
            <summary>
            Sent to an application that has initiated a training card with Microsoft Windows Help. The message informs the application when the user clicks an authorable button. An application initiates a training card by specifying the HELP_TCARD command in a call to the WinHelp function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HELP">
            <summary>
            Indicates that the user pressed the F1 key. If a menu is active when F1 is pressed, WM_HELP is sent to the window associated with the menu; otherwise, WM_HELP is sent to the window that has the keyboard focus. If no window has the keyboard focus, WM_HELP is sent to the currently active window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.USERCHANGED">
            <summary>
            The WM_USERCHANGED message is sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NOTIFYFORMAT">
            <summary>
            Determines if a window accepts ANSI or Unicode structures in the WM_NOTIFY notification message. WM_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CONTEXTMENU">
            <summary>
            The WM_CONTEXTMENU message notifies a window that the user clicked the right mouse button (right-clicked) in the window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.STYLECHANGING">
            <summary>
            The WM_STYLECHANGING message is sent to a window when the SetWindowLong function is about to change one or more of the window's styles.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.STYLECHANGED">
            <summary>
            The WM_STYLECHANGED message is sent to a window after the SetWindowLong function has changed one or more of the window's styles
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DISPLAYCHANGE">
            <summary>
            The WM_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETICON">
            <summary>
            The WM_GETICON message is sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETICON">
            <summary>
            An application sends the WM_SETICON message to associate a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCCREATE">
            <summary>
            The WM_NCCREATE message is sent prior to the WM_CREATE message when a window is first created.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCDESTROY">
            <summary>
            The WM_NCDESTROY message informs a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM_NCDESTROY message to the window following the WM_DESTROY message. WM_DESTROY is used to free the allocated memory object associated with the window. 
            The WM_NCDESTROY message is sent after the child windows have been destroyed. In contrast, WM_DESTROY is sent before the child windows are destroyed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCCALCSIZE">
            <summary>
            The WM_NCCALCSIZE message is sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCHITTEST">
            <summary>
            The WM_NCHITTEST message is sent to a window when the cursor moves, or when a mouse button is pressed or released. If the mouse is not captured, the message is sent to the window beneath the cursor. Otherwise, the message is sent to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCPAINT">
            <summary>
            The WM_NCPAINT message is sent to a window when its frame must be painted. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCACTIVATE">
            <summary>
            The WM_NCACTIVATE message is sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETDLGCODE">
            <summary>
            The WM_GETDLGCODE message is sent to the window procedure associated with a control. By default, the system handles all keyboard input to the control; the system interprets certain types of keyboard input as dialog box navigation keys. To override this default behavior, the control can respond to the WM_GETDLGCODE message to indicate the types of input it wants to process itself.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYNCPAINT">
            <summary>
            The WM_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSEMOVE">
            <summary>
            The WM_NCMOUSEMOVE message is posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONDOWN">
            <summary>
            The WM_NCLBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONUP">
            <summary>
            The WM_NCLBUTTONUP message is posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONDBLCLK">
            <summary>
            The WM_NCLBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONDOWN">
            <summary>
            The WM_NCRBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONUP">
            <summary>
            The WM_NCRBUTTONUP message is posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONDBLCLK">
            <summary>
            The WM_NCRBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONDOWN">
            <summary>
            The WM_NCMBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONUP">
            <summary>
            The WM_NCMBUTTONUP message is posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONDBLCLK">
            <summary>
            The WM_NCMBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONDOWN">
            <summary>
            The WM_NCXBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONUP">
            <summary>
            The WM_NCXBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONDBLCLK">
            <summary>
            The WM_NCXBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUT_DEVICE_CHANGE">
            <summary>
            The WM_INPUT_DEVICE_CHANGE message is sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUT">
            <summary>
            The WM_INPUT message is sent to the window that is getting raw input. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYFIRST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYDOWN">
            <summary>
            The WM_KEYDOWN message is posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYUP">
            <summary>
            The WM_KEYUP message is posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHAR">
            <summary>
            The WM_CHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_CHAR message contains the character code of the key that was pressed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEADCHAR">
            <summary>
            The WM_DEADCHAR message is posted to the window with the keyboard focus when a WM_KEYUP message is translated by the TranslateMessage function. WM_DEADCHAR specifies a character code generated by a dead key. A dead key is a key that generates a character, such as the umlaut (double-dot), that is combined with another character to form a composite character. For example, the umlaut-O character (Ö) is generated by typing the dead key for the umlaut character, and then typing the O key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSKEYDOWN">
            <summary>
            The WM_SYSKEYDOWN message is posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYDOWN message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSKEYUP">
            <summary>
            The WM_SYSKEYUP message is posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYUP message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCHAR">
            <summary>
            The WM_SYSCHAR message is posted to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. It specifies the character code of a system character key — that is, a character key that is pressed while the ALT key is down. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSDEADCHAR">
            <summary>
            The WM_SYSDEADCHAR message is sent to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. WM_SYSDEADCHAR specifies the character code of a system dead key — that is, a dead key that is pressed while holding down the ALT key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNICHAR">
            <summary>
            The WM_UNICHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_UNICHAR message contains the character code of the key that was pressed. 
            The WM_UNICHAR message is equivalent to WM_CHAR, but it uses Unicode Transformation Format (UTF)-32, whereas WM_CHAR uses UTF-16. It is designed to send or post Unicode characters to ANSI windows and it can can handle Unicode Supplementary Plane characters.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYLAST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_STARTCOMPOSITION">
            <summary>
            Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_ENDCOMPOSITION">
            <summary>
            Sent to an application when the IME ends composition. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_COMPOSITION">
            <summary>
            Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITDIALOG">
            <summary>
            The WM_INITDIALOG message is sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMMAND">
            <summary>
            The WM_COMMAND message is sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCOMMAND">
            <summary>
            A window receives this message when the user chooses a command from the Window menu, clicks the maximize button, minimize button, restore button, close button, or moves the form. You can stop the form from moving by filtering this out.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TIMER">
            <summary>
            The WM_TIMER message is posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HSCROLL">
            <summary>
            The WM_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar. This message is also sent to the owner of a horizontal scroll bar control when a scroll event occurs in the control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VSCROLL">
            <summary>
            The WM_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar. This message is also sent to the owner of a vertical scroll bar control when a scroll event occurs in the control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITMENU">
            <summary>
            The WM_INITMENU message is sent when a menu is about to become active. It occurs when the user clicks an item on the menu bar or presses a menu key. This allows the application to modify the menu before it is displayed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITMENUPOPUP">
            <summary>
            The WM_INITMENUPOPUP message is sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUSELECT">
            <summary>
            The WM_MENUSELECT message is sent to a menu's owner window when the user selects a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUCHAR">
            <summary>
            The WM_MENUCHAR message is sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERIDLE">
            <summary>
            The WM_ENTERIDLE message is sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENURBUTTONUP">
            <summary>
            The WM_MENURBUTTONUP message is sent when the user releases the right mouse button while the cursor is on a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUDRAG">
            <summary>
            The WM_MENUDRAG message is sent to the owner of a drag-and-drop menu when the user drags a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUGETOBJECT">
            <summary>
            The WM_MENUGETOBJECT message is sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNINITMENUPOPUP">
            <summary>
            The WM_UNINITMENUPOPUP message is sent when a drop-down menu or submenu has been destroyed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUCOMMAND">
            <summary>
            The WM_MENUCOMMAND message is sent when the user makes a selection from a menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHANGEUISTATE">
            <summary>
            An application sends the WM_CHANGEUISTATE message to indicate that the user interface (UI) state should be changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UPDATEUISTATE">
            <summary>
            An application sends the WM_UPDATEUISTATE message to change the user interface (UI) state for the specified window and all its child windows.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYUISTATE">
            <summary>
            An application sends the WM_QUERYUISTATE message to retrieve the user interface (UI) state for a window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORMSGBOX">
            <summary>
            The WM_CTLCOLORMSGBOX message is sent to the owner window of a message box before Windows draws the message box. By responding to this message, the owner window can set the text and background colors of the message box by using the given display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLOREDIT">
            <summary>
            An edit control that is not read-only or disabled sends the WM_CTLCOLOREDIT message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the edit control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORLISTBOX">
            <summary>
            Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORBTN">
            <summary>
            The WM_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORDLG">
            <summary>
            The WM_CTLCOLORDLG message is sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORSCROLLBAR">
            <summary>
            The WM_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn. By responding to this message, the parent window can use the display context handle to set the background color of the scroll bar control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORSTATIC">
            <summary>
            A static control, or an edit control that is read-only or disabled, sends the WM_CTLCOLORSTATIC message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the static control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEFIRST">
            <summary>
            Use WM_MOUSEFIRST to specify the first mouse message. Use the PeekMessage() Function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEMOVE">
            <summary>
            The WM_MOUSEMOVE message is posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONDOWN">
            <summary>
            The WM_LBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONUP">
            <summary>
            The WM_LBUTTONUP message is posted when the user releases the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONDBLCLK">
            <summary>
            The WM_LBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONDOWN">
            <summary>
            The WM_RBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONUP">
            <summary>
            The WM_RBUTTONUP message is posted when the user releases the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONDBLCLK">
            <summary>
            The WM_RBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONDOWN">
            <summary>
            The WM_MBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONUP">
            <summary>
            The WM_MBUTTONUP message is posted when the user releases the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONDBLCLK">
            <summary>
            The WM_MBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEWHEEL">
            <summary>
            The WM_MOUSEWHEEL message is sent to the focus window when the mouse wheel is rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONDOWN">
            <summary>
            The WM_XBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONUP">
            <summary>
            The WM_XBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONDBLCLK">
            <summary>
            The WM_XBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEHWHEEL">
            <summary>
            The WM_MOUSEHWHEEL message is sent to the focus window when the mouse's horizontal scroll wheel is tilted or rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSELAST">
            <summary>
            Use WM_MOUSELAST to specify the last mouse message. Used with PeekMessage() Function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PARENTNOTIFY">
            <summary>
            The WM_PARENTNOTIFY message is sent to the parent of a child window when the child window is created or destroyed, or when the user clicks a mouse button while the cursor is over the child window. When the child window is being created, the system sends WM_PARENTNOTIFY just before the CreateWindow or CreateWindowEx function that creates the window returns. When the child window is being destroyed, the system sends the message before any processing to destroy the window takes place.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERMENULOOP">
            <summary>
            The WM_ENTERMENULOOP message informs an application's main window procedure that a menu modal loop has been entered. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.EXITMENULOOP">
            <summary>
            The WM_EXITMENULOOP message informs an application's main window procedure that a menu modal loop has been exited. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NEXTMENU">
            <summary>
            The WM_NEXTMENU message is sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZING">
            <summary>
            The WM_SIZING message is sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CAPTURECHANGED">
            <summary>
            The WM_CAPTURECHANGED message is sent to the window that is losing the mouse capture.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOVING">
            <summary>
            The WM_MOVING message is sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.POWERBROADCAST">
            <summary>
            Notifies applications that a power-management event has occurred.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEVICECHANGE">
            <summary>
            Notifies an application of a change to the hardware configuration of a device or the computer.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDICREATE">
            <summary>
            An application sends the WM_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIDESTROY">
            <summary>
            An application sends the WM_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIACTIVATE">
            <summary>
            An application sends the WM_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIRESTORE">
            <summary>
            An application sends the WM_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDINEXT">
            <summary>
            An application sends the WM_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIMAXIMIZE">
            <summary>
            An application sends the WM_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window. The system resizes the child window to make its client area fill the client window. The system places the child window's window menu icon in the rightmost position of the frame window's menu bar, and places the child window's restore icon in the leftmost position. The system also appends the title bar text of the child window to that of the frame window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDITILE">
            <summary>
            An application sends the WM_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDICASCADE">
            <summary>
            An application sends the WM_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIICONARRANGE">
            <summary>
            An application sends the WM_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIGETACTIVE">
            <summary>
            An application sends the WM_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDISETMENU">
            <summary>
            An application sends the WM_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERSIZEMOVE">
            <summary>
            The WM_ENTERSIZEMOVE message is sent one time to a window after it enters the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns. 
            The system sends the WM_ENTERSIZEMOVE message regardless of whether the dragging of full windows is enabled.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.EXITSIZEMOVE">
            <summary>
            The WM_EXITSIZEMOVE message is sent one time to a window, after it has exited the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DROPFILES">
            <summary>
            Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIREFRESHMENU">
            <summary>
            An application sends the WM_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_SETCONTEXT">
            <summary>
            Sent to an application when a window is activated. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_NOTIFY">
            <summary>
            Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_CONTROL">
            <summary>
            Sent by an application to direct the IME window to carry out the requested command. The application uses this message to control the IME window that it has created. To send this message, the application calls the SendMessage function with the following parameters.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_COMPOSITIONFULL">
            <summary>
            Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_SELECT">
            <summary>
            Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_CHAR">
            <summary>
            Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_REQUEST">
            <summary>
            Sent to an application to provide commands and request information. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_KEYDOWN">
            <summary>
            Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_KEYUP">
            <summary>
            Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEHOVER">
            <summary>
            The WM_MOUSEHOVER message is posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSELEAVE">
            <summary>
            The WM_MOUSELEAVE message is posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSEHOVER">
            <summary>
            The WM_NCMOUSEHOVER message is posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSELEAVE">
            <summary>
            The WM_NCMOUSELEAVE message is posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WTSSESSION_CHANGE">
            <summary>
            The WM_WTSSESSION_CHANGE message notifies applications of changes in session state.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CUT">
            <summary>
            An application sends a WM_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COPY">
            <summary>
            An application sends the WM_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PASTE">
            <summary>
            An application sends a WM_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLEAR">
            <summary>
            An application sends a WM_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNDO">
            <summary>
            An application sends a WM_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RENDERFORMAT">
            <summary>
            The WM_RENDERFORMAT message is sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format. The clipboard owner must render data in the specified format and place it on the clipboard by calling the SetClipboardData function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RENDERALLFORMATS">
            <summary>
            The WM_RENDERALLFORMATS message is sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats. For the content of the clipboard to remain available to other applications, the clipboard owner must render data in all the formats it is capable of generating, and place the data on the clipboard by calling the SetClipboardData function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DESTROYCLIPBOARD">
            <summary>
            The WM_DESTROYCLIPBOARD message is sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DRAWCLIPBOARD">
            <summary>
            The WM_DRAWCLIPBOARD message is sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINTCLIPBOARD">
            <summary>
            The WM_PAINTCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area needs repainting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VSCROLLCLIPBOARD">
            <summary>
            The WM_VSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar. The owner should scroll the clipboard image and update the scroll bar values. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZECLIPBOARD">
            <summary>
            The WM_SIZECLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area has changed size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ASKCBFORMATNAME">
            <summary>
            The WM_ASKCBFORMATNAME message is sent to the clipboard owner by a clipboard viewer window to request the name of a CF_OWNERDISPLAY clipboard format.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHANGECBCHAIN">
            <summary>
            The WM_CHANGECBCHAIN message is sent to the first window in the clipboard viewer chain when a window is being removed from the chain. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HSCROLLCLIPBOARD">
            <summary>
            The WM_HSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window. This occurs when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's horizontal scroll bar. The owner should scroll the clipboard image and update the scroll bar values. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYNEWPALETTE">
            <summary>
            This message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PALETTEISCHANGING">
            <summary>
            The WM_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PALETTECHANGED">
            <summary>
            This message is sent by the OS to all top-level and overlapped windows after the window with the keyboard focus realizes its logical palette. 
            This message enables windows that do not have the keyboard focus to realize their logical palettes and update their client areas.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HOTKEY">
            <summary>
            The WM_HOTKEY message is posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PRINT">
            <summary>
            The WM_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PRINTCLIENT">
            <summary>
            The WM_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.APPCOMMAND">
            <summary>
            The WM_APPCOMMAND message notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.THEMECHANGED">
            <summary>
            The WM_THEMECHANGED message is broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLIPBOARDUPDATE">
            <summary>
            Sent when the contents of the clipboard have changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMCOMPOSITIONCHANGED">
            <summary>
            The system will send a window the WM_DWMCOMPOSITIONCHANGED message to indicate that the availability of desktop composition has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMNCRENDERINGCHANGED">
            <summary>
            WM_DWMNCRENDERINGCHANGED is called when the non-client area rendering status of a window has changed. Only windows that have set the flag DWM_BLURBEHIND.fTransitionOnMaximized to true will get this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMCOLORIZATIONCOLORCHANGED">
            <summary>
            Sent to all top-level windows when the colorization color has changed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMWINDOWMAXIMIZEDCHANGE">
            <summary>
            WM_DWMWINDOWMAXIMIZEDCHANGE will let you know when a DWM composed window is maximized. You also have to register for this message as well. You'd have other windowd go opaque when this message is sent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTITLEBARINFOEX">
            <summary>
            Sent to request extended title bar information. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.APP">
            <summary>
            The WM_APP constant is used by applications to help define private messages, usually of the form WM_APP+X, where X is an integer value. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.USER">
            <summary>
            The WM_USER constant is used by applications to help define private messages for use by private window classes, usually of the form WM_USER+X, where X is an integer value. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CPL_LAUNCH">
            <summary>
            An application sends the WM_CPL_LAUNCH message to Windows Control Panel to request that a Control Panel application be started. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CPL_LAUNCHED">
            <summary>
            The WM_CPL_LAUNCHED message is sent when a Control Panel application, started by the WM_CPL_LAUNCH message, has closed. The WM_CPL_LAUNCHED message is sent to the window identified by the wParam parameter of the WM_CPL_LAUNCH message that started the application. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSTIMER">
            <summary>
            WM_SYSTIMER is a well-known yet still undocumented message. Windows uses WM_SYSTIMER for internal actions like scrolling.
            </summary>
        </member>
        <member name="M:VRage.Win32.WinApi.MessageBox(System.String,System.String)">
            <summary>
            Shorthand for a simple message box with the OK button.
            </summary>
            <param name="caption"></param>
            <param name="text"></param>
        </member>
        <member name="P:VRage.Win32.WinApi.WorkingSet">
            <summary>
            Gets working set size without creating garbage, it's also faster.
            Environment.WorkingSet create garbage.
            </summary>
        </member>
        <member name="T:VRage.Win32.WinError">
             <summary>
             winerror.h --  error code definitions for the Win32 API functions.
             </summary>
             <remarks>
            <code>
              Values are 32 bit values laid out as follows:
            
               3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
               1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
              +---+-+-+-----------------------+-------------------------------+
              |Sev|C|R|     Facility          |               Code            |
              +---+-+-+-----------------------+-------------------------------+
            
              where
            
                  Sev - is the severity code
            
                      00 - Success
                      01 - Informational
                      10 - Warning
                      11 - Error
            
                  C - is the Customer code flag
            
                  R - is a reserved bit
            
                  Facility - is the facility code
            
                  Code - is the facility's status code
             </code>
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ClassIdAttribute">
            <summary>
            Attribute which assigns ID to class, this id persists after obfuscation and it's same on both x86 and X64 build.
            ID can change with different versions of source code.
            </summary>
        </member>
        <member name="T:System.EventExtensions">
            <summary>
            Extension methods for <see cref="T:System.Reflection.EventInfo"/>.
            </summary>
        </member>
        <member name="T:System.PropertyExtensions">
            <summary>
            Extension methods for <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Whether this collection is empty or a null reference.
            </summary>
            <typeparam name="T">The type of the collection element.</typeparam>
            <param name="self">The collection.</param>
            <returns>Whether the collection is a null reference or contains zero items.</returns>
        </member>
        <member name="T:System.Collections.Generic.ListInternalsAccessor`1">
            <summary>
            Factory for list internals accessors.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Collections.Generic.ArrayExtensions.BinaryIntervalSearch``1(``0[],System.Func{``0,System.Int32})">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-∞,+∞) interval).
            
            The search is done using the specified search method. The method must return an integer
            representing whether the argument is greater (1), smaller (-1) or equal(0) to the search condition.
            </summary>
            <param name="self">The array to search into.</param>
            
            <returns>[0, Length]</returns>
        </member>
        <member name="M:System.Collections.Generic.ArrayExtensions.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Enumerate a range of an IList.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ArrayExtensions.OfTypeFast``2(``0[])">
            <summary>
            OfType on array implemented without allocations
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ArrayExtensions.CreateSubarray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Copy a section of an array to a new array.
            </summary>
            <typeparam name="T">The type of the array element.</typeparam>
            <param name="input">The input array.</param>
            <param name="startIndex">The starting index of the elements to copy out.</param>
            <param name="count">The number of elements to copy.</param>
            <returns>A new array containing the copied segment of the original array.</returns>
        </member>
        <member name="M:System.Collections.Generic.ArrayExtensions.Equals(System.Byte[],System.Byte[])">
            <summary>
            Compare two byte arrays for equality.
            </summary>
            <param name="a1">The first array to be compared.</param>
            <param name="a2">The second array to be compared.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.GetInternalArray``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the internal array backing a list.
            </summary>
            <remarks>
            This method has a first call overhead.
            </remarks>
            <typeparam name="T">The array type.</typeparam>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.SetSize``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set the size of an array.
            </summary>
            <remarks>
            This method has a first call overhead.
            </remarks>
            <typeparam name="T">The array type.</typeparam>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveAtFast``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Remove element at index by replacing it with last element in list.
            Removing is very fast but it breaks order of items in list!
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.AddCollection``1(System.Collections.Generic.List{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            Add all elements in a collection to the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="itemsToAdd"></param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.AddCollection``1(System.Collections.Generic.List{``0},System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Add a range of elements from a collection to the end of this list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self">The list instance.</param>
            <param name="itemsToAdd">The collection to add.</param>
            <param name="itemCount">The number of elements to take from the collection.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.AddCollection``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <summary>
            Add a range of elements from am array to the end of this list.
            </summary>
            <remarks>
            This overload is much faster than the ICollection variant since it can leverage <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>.
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="self">The list instance.</param>
            <param name="itemsToAdd">The array to add.</param>
            <param name="itemCount">The number of elements to take from the array.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.Move``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Moves item in the list from original index to target index, reordering elements as if Remove and Insert was called.
            However, only elements in the range between the two indices are affected.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveIndices``1(System.Collections.Generic.List{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Given a list of indices, remove each one from the list while preserving the existing order and performing as few operations as possible.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="indices"></param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.Swap``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Swap two elements in the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.BinaryIntervalSearch``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-∞,+∞) interval).
            </summary>
            <returns>[0, Length]</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.BinaryIntervalSearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-∞,+∞) interval).
            
            Return range: [0, Length]
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.BinaryIntervalSearch``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-∞,+∞) interval).
            
            Return range: [0, Length]
            </summary>
        </member>
        <member name="M:System.DoubleExtensions.IsValid(System.Double)">
            <summary>
            Returns true if double is valid
            </summary>
        </member>
        <member name="M:System.FloatExtensions.IsValid(System.Single)">
            <summary>
            Returns true if float is not NaN or infinity.
            </summary>
        </member>
        <member name="M:System.MethodInfoExtensions.PrettyFormat(System.Reflection.MethodBase,VRage.MemberFormat,VRage.NameQualification,VRage.NameQualification)">
            <summary>
            Return the method signature as a string.
            </summary>
            <param name="method">The Method</param>
            <returns>Method signature</returns>
        </member>
        <member name="M:System.MethodInfoExtensions.PrettyFormat(System.Reflection.MethodBase,System.Text.StringBuilder,VRage.MemberFormat,VRage.NameQualification,VRage.NameQualification)">
            <summary>
            Append a formatted method signature to the provided string builder.
            </summary>
            <param name="method">The method to format.</param>
            <param name="sigBuilder">The builder where the string is appended</param>
            <param name="flags">Flags for member presentation.</param>
            <param name="typeQualification">Qualification flags for types on the signature.</param>
            <param name="nameQualification">Qualification flags for the method name.</param>
        </member>
        <member name="M:System.Net.IPAddressExtensions.TryParseEndpoint(System.String,System.Net.IPEndPoint@)">
            <summary>
            Parses IP Endpoint from string in format x.x.x.x:port
            </summary>
        </member>
        <member name="M:System.StreamExtensions.UnwrapGZip(System.IO.Stream)">
            <summary>
            Checks for GZip header and if found, returns decompressed Stream, otherwise original Stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WrapGZip(System.IO.Stream,System.Boolean)">
            <summary>
            Wraps stream into GZip compression stream resulting in writing compressed stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WriteNoAlloc(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            Writes byte count prefixed encoded text into the file. Byte count is written as 7-bit encoded 32-bit int.
            If no encoding is specified, UTF-8 will be used. Byte count prefix specifies number of bytes taken up by
            the string, not length of the string itself.
            Note that this method may allocate if the size of encoded string exceeds size of prepared buffer.
            </summary>
        </member>
        <member name="T:System.PreloadRequiredAttribute">
            <summary>
            Specifies that this class requires preload before running the game
            Preload is be done when starting the app
            </summary>
        </member>
        <member name="T:System.Security.Cryptography.Crc32">
            <summary>
            Hash algorithm implementing a 32-bit CRC.
            </summary>
            <remarks>
            See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for more info.
            </remarks>
        </member>
        <member name="T:ProtoBuf.BclHelpers">
            <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
            <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers.NetObjectOptions">
            <summary>
            Optional behaviours that introduce .NET-specific functionality
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.None">
            <summary>
            No special behaviour
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.UseConstructor">
            <summary>
            If false, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.LateSet">
            <summary>
            Should the object index be reserved, rather than creating an object promptly
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadNetObject(System.Object,ProtoBuf.ProtoReader,System.Int32,System.Type,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Reads an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteNetObject(System.Object,ProtoBuf.ProtoWriter,System.Int32,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Writes an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="T:ProtoBuf.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.LoadNullRef">
            <summary>
            Pushes a null reference onto the stack. Note that this should only
            be used to return a null (or set a variable to null); for null-tests
            use BranchIfTrue / BranchIfFalse.
            </summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.UsingBlock.#ctor(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Creates a new "using" block (equivalent) around a variable;
            the variable must exist, and note that (unlike in C#) it is
            the variables *final* value that gets disposed. If you need
            *original* disposal, copy your variable first.
            
            It is the callers responsibility to ensure that the variable's
            scope fully-encapsulates the "using"; if not, the variable
            may be re-used (and thus re-assigned) unexpectedly.
            </summary>
        </member>
        <member name="T:ProtoBuf.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="T:ProtoBuf.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:ProtoBuf.IExtensible"/>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Object@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <param name="type">The data-type of the field.</param>
            <param name="model">The model to use for configuration.</param>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="type">The data-type of the field.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="T:ProtoBuf.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.AppendExtendValueTyped``2(ProtoBuf.Meta.TypeModel,``0,System.Int32,ProtoBuf.DataFormat,``1)">
            <summary>
            Stores the given value into the instance's stream; the serializer
            is inferred from TValue and format.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="T:ProtoBuf.Helpers">
            <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoTypeCode">
            <summary>
            Intended to be a direct map to regular TypeCode, but:
            - with missing types
            - existing on WinRT
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from Extensible.</remarks>
        </member>
        <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="T:ProtoBuf.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:ProtoBuf.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.CallbackSet">
            <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
            <summary>Called before serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
            <summary>Called before deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
            <summary>Called after serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
            <summary>Called after deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
            <summary>
            True if any callback is set, else False
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.MetaType">
            <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ToString">
            <summary>
            Get the name of the type being represented
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.BaseType">
            <summary>
            Gets the base-type for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
            <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default?
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
            <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
            <summary>
            Indicates whether the current type has defined subtypes
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
            <summary>
            Returns the set of callbacks defined for this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Name">
            <summary>
            Gets or sets the name of this contract.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.String)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
            <summary>
            Throws an exception if the type has been made immutable
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Type">
            <summary>
            The runtime type that the meta-type represents
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
            <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
            <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
            <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
            <summary>
            Adds a set of members (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
            <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
            <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetFields">
            <summary>
            Returns the ValueMember instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
            <summary>
            Returns the SubType instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.CompileInPlace">
            <summary>
            Compiles the serializer for this type; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
            <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IgnoreListHandling">
            <summary>
            Gets or sets a value indicating that this type should NOT be treated as a list, even if it has
            familiar list-like characteristics (enumerable, add, etc)
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
            <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
            <summary>
            Global default that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName"/>
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddProtoContractTypesOnly">
            <summary>
            Global default that determines whether types are considered serializable
            if they have [DataContract] / [XmlType]. With this enabled, <b>ONLY</b>
            types marked as [ProtoContract] are added automatically.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
            <summary>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowParseableTypes">
            <summary>
            Global switch that determines whether types with a <c>.ToString()</c> and a <c>Parse(string)</c>
            should be serialized as strings.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
            <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
            <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
            <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
            <summary>
            Adds support for an additional type in this model, optionally
            appplying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoCompile">
            <summary>
            Should serializers be compiled on demand? It may be useful
            to disable this for debugging purposes.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
            <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
            <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
            <summary>
            Prevents further changes to this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompileInPlace">
            <summary>
            Compiles the serializers individually; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile">
            <summary>
            Fully compiles the current model into a static-compiled model instance
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions">
            <summary>
            Represents configuration options for compiling a model to 
            a standalone assembly.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.SetFrameworkOptions(ProtoBuf.Meta.MetaType)">
            <summary>
            Import framework options from an existing type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkName">
            <summary>
            The TargetFrameworkAttribute FrameworkName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkDisplayName">
            <summary>
            The TargetFrameworkAttribute FrameworkDisplayName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TypeName">
            <summary>
            The name of the TypeModel class to create
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.OutputPath">
            <summary>
            The path for the new dll
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.ImageRuntimeVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.MetaDataVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.Accessibility">
            <summary>
            The acecssibility of the generated serializer
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.Accessibility">
            <summary>
            Type accessibility
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Public">
            <summary>
            Available to all callers
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Internal">
            <summary>
            Available to all callers in the same assembly, or assemblies specified via [InternalsVisibleTo(...)]
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(System.String,System.String)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <param name="name">The name of the TypeModel class to create</param>
            <param name="path">The path for the new dll</param>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
            <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.LockContended">
            <summary>
            If a lock-contention is detected, this event signals the *owner* of the lock responsible for the blockage, indicating
            what caused the problem; this is only raised if the lock-owning code successfully completes.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SetDefaultFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of any type; note that this only affect types seen by the serializer *after* setting the factory.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventArgs">
            <summary>
            Contains the stack-trace of the owning code when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.LockContentedEventArgs.OwnerStackTrace">
            <summary>
            The stack-trace of the code that owned the lock when a lock-contention scenario occurred
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventHandler">
            <summary>
            Event-type that is raised when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.SubType">
            <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
            <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.DerivedType">
            <summary>
            The sub-type to be considered.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType,ProtoBuf.DataFormat)">
            <summary>
            Creates a new SubType instance.
            </summary>
            <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
            <param name="derivedType">The sub-type to be considered.</param>
            <param name="format">Specific encoding style to use; in particular, Grouped can be used to avoid buffering, but is not the default.</param>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
            <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
            <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
            <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
            <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel">
            <summary>
            Provides protobuf serialization support for a number of types
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type,System.Boolean)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean)">
            <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination writer to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int32@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.ProtoReader,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer reader to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The reader to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Create">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ResolveProxies(System.Type)">
            <summary>
            Applies common proxy scenarios, resolving the actual type to consider
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKey(System.Type@)">
            <summary>
            Provides the key that represents a given type in the current model.
            The type is also normalized for proxies at the same time.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
            <summary>
            Indicates the type of callback to be used
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeSerialize">
            <summary>
            Invoked before an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterSerialize">
            <summary>
            Invoked after an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeDeserialize">
            <summary>
            Invoked before an object is deserialized (or when a new instance is created)
            </summary>            
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterDeserialize">
            <summary>
            Invoked after an object is deserialized
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type)">
            <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type)">
            <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeContractType(System.Type)">
            <summary>
            Returns true if the type supplied is either a recognised contract type,
            or a *list* of a recognised contract type. 
            </summary>
            <remarks>Note that primitives always return false, even though the engine
            will, if forced, try to serialize such</remarks>
            <returns>True if this type is recognised as a serializable entity, else false</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerialize(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            a recognised contract type, or a *list* of a basic / contract type. 
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeBasicType(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            or a *list* of a basic type with inbuilt handling
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
            <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateFormatter(System.Type)">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
            <param name="type">The type of object to be [de]deserialized by the formatter.</param>
        </member>
        <member name="T:ProtoBuf.Meta.ValueMember">
            <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
            <summary>
            The number that identifies this member in a protobuf stream
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Member">
            <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
            <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
            <summary>
            The underlying type of the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
            <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
            <summary>
            The type the defines the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
            <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
            <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
            <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
            <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
            <summary>
            Indicates whether this field is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Specifies methods for working with optional data members.
            </summary>
            <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
            <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Name">
            <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.SupportNull">
            <summary>
            Should lists have extended support for null values? Note this makes the serialization less efficient.
            </summary>
        </member>
        <member name="T:ProtoBuf.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Base128">
            <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
            <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IgnoreListHandling">
            <summary>
            If specified, do NOT treat this type as a list, even if it looks like one.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
            <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
            <remarks>If not explicitly specified, the default is assumed from Serializer.GlobalOptions.InferTagFromName.</remarks>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
            <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
            <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
            <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default? Please also see the implications of this,
            as recorded on ProtoMemberAttribute.AsReference
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
             <param name="tag">The unique index (within the type) that will identify this data.</param>
             <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
            <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:ProtoBuf.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReferenceHasValue">
            <summary>
            Determines whether the types AsReferenceDefault value is used, or whether this member's AsReference should be used
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader">
            <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="P:ProtoBuf.ProtoReader.InternStrings">
            <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Enabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Context">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Dispose">
            <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Position">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadString">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Int32,ProtoBuf.ProtoReader)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Model">
            <summary>
            Get the TypeModel associated with this reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadLittleEndianInt32(System.IO.Stream)">
            <summary>
            Reads a little-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBigEndianInt32(System.IO.Stream)">
            <summary>
            Reads a big-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadVarintInt32(System.IO.Stream)">
            <summary>
            Reads a varint encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source into a pre-existing buffer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadString(System.IO.Stream,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadUInt32Variant(System.IO.Stream,System.UInt32@)">
            <returns>The number of bytes consumed; 0 if no data available</returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.NoteObject(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Utility method, not intended for public use; this helps maintain the root object is complex scenarios
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadType">
            <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Merge(ProtoBuf.ProtoReader,System.Object,System.Object)">
            <summary>
            Merge two objects using the details from the current reader; this is used to change the type
            of objects when an inheritance relationship is discovered later than usual during deserilazation.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoWriter">
            <summary>
            Represents an output stream for writing protobuf data.
            
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type).
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteRecursionSafeObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type) - but the
            caller is asserting that this relationship is non-recursive; no recursion check will be
            performed.
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <param name="writer">The destination.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Context">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Model">
            <summary>
            Get the TypeModel associated with this writer
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Flush(ProtoBuf.ProtoWriter)">
            <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
            <param name="writer">The writer to flush</param>
            <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32Variant(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetRootObject(System.Object)">
            <summary>
            Specifies a known root object to use during reference-tracked serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteType(System.Type,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="T:ProtoBuf.SerializationContext">
            <summary>
            Additional information about a serialization operation
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Context">
            <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Default">
            <summary>
            A default SerializationContext, with minimal information.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.State">
            <summary>
            Gets or sets the source or destination of the transmitted data.
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(ProtoBuf.SerializationContext)~System.Runtime.Serialization.StreamingContext">
            <summary>
            Convert a SerializationContext to a StreamingContext
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(System.Runtime.Serialization.StreamingContext)~ProtoBuf.SerializationContext">
            <summary>
            Convert a StreamingContext to a SerializationContext
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TFrom">The type of the object being copied.</typeparam>
            <typeparam name="TTo">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="writer">The destination XmlWriter to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
            <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="F:ProtoBuf.Serializer.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.NonGeneric">
            <summary>
            Provides non-generic access to the default serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Merge(System.IO.Stream,System.Object)">
            <summary>Applies a protocol-buffer stream to an existing instance.</summary>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Serializer.TypeResolver,System.Object@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
            <summary>
            <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault"/>
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.FlushPool">
            <summary>
            Releases any internal buffers that have been reserved for efficiency; this does not affect any serialization
            operations; simply: it can be used (optionally) to release the buffers for garbage collection (at the expense
            of having to re-allocate a new buffer for the next operation, rather than re-use prior buffers).
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ExpectedType">
            <summary>
            The type that this serializer is intended to work for.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Write(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Perform the steps necessary to serialize this data.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="dest">The writer entity that is accumulating the output data.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Read(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
            <param name="value">The current value, if appropriate.</param>
            <param name="source">The reader providing the input data.</param>
            <returns>The updated / replacement value.</returns>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue">
            <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ReturnsValue">
            <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitWrite(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>Emit the IL necessary to perform the given actions
            to serialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="valueFrom">The source of the data to work against;
            If the value is only needed once, then LoadValue is sufficient. If
            the value is needed multiple times, then note that a "null"
            means "the top of the stack", in which case you should create your
            own copy - GetLocalWithValue.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitRead(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Emit the IL necessary to perform the given actions to deserialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="entity">For nested values, the instance holding the values; note
            that this is not always provided - a null means not supplied. Since this is always
            a variable or argument, it is not necessary to consume this value.</param>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorAttribute">
            <summary>
            Uses protocol buffer serialization on the specified operation; note that this
            must be enabled on both the client and server.
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorExtension">
            <summary>
            Configuration element to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
            </summary>
            <seealso cref="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior"/>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.#ctor">
            <summary>
            Creates a new ProtoBehaviorExtension instance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ServiceModel.ProtoBehaviorExtension.BehaviorType">
            <summary>
            Gets the type of behavior.
            </summary>     
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.CreateBehavior">
            <summary>
            Creates a behavior extension based on the current configuration settings.
            </summary>
            <returns>The behavior extension.</returns>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior">
            <summary>
            Behavior to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
             <example>
            Add the following to the server and client app.config in the system.serviceModel section:
             <behaviors>
               <endpointBehaviors>
                 <behavior name="ProtoBufBehaviorConfig">
                   <ProtoBufSerialization/>
                 </behavior>
               </endpointBehaviors>
             </behaviors>
             <extensions>
               <behaviorExtensions>
                 <add name="ProtoBufSerialization" type="ProtoBuf.ServiceModel.ProtoBehaviorExtension, protobuf-net, Version=1.0.0.255, Culture=neutral, PublicKeyToken=257b51d87d2e4d67"/>
               </behaviorExtensions>
             </extensions>
            
            Configure your endpoints to have a behaviorConfiguration as follows:
            
             <service name="TK.Framework.Samples.ServiceModel.Contract.SampleService">
               <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" behaviorConfiguration="ProtoBufBehaviorConfig"
                bindingConfiguration="basicHttpBindingConfig" name="basicHttpProtoBuf" contract="ISampleServiceContract" />
             </service>
             <client>
                 <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding"
                     bindingConfiguration="basicHttpBindingConfig" contract="ISampleServiceContract"
                     name="BasicHttpProtoBufEndpoint" behaviorConfiguration="ProtoBufBehaviorConfig"/>
              </client>
            </example>
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoOperationBehavior">
            <summary>
            Describes a WCF operation behaviour that can perform protobuf serialization
            </summary>
        </member>
        <member name="P:ProtoBuf.ServiceModel.ProtoOperationBehavior.Model">
            <summary>
            The type-model that should be used with this behaviour
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.#ctor(System.ServiceModel.Description.OperationDescription)">
            <summary>
            Create a new ProtoOperationBehavior instance
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.CreateSerializer(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates a protobuf serializer if possible (falling back to the default WCF serializer)
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.XmlProtoSerializer">
            <summary>
            An xml object serializer that can embed protobuf data in a base-64 hunk (looking like a byte[])
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.TryCreate(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Attempt to create a new serializer for the given model and type
            </summary>
            <returns>A new serializer instance if the type is recognised by the model; null otherwise</returns>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.#ctor(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Creates a new serializer for the given model and type
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)">
            <summary>
            Ends an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Begins an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Writes the body of an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.IsStartObject(System.Xml.XmlDictionaryReader)">
            <summary>
            Indicates whether this is the start of an object we are prepared to handle
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)">
            <summary>
            Reads the body of an object
            </summary>
        </member>
        <member name="T:ProtoBuf.SubItemToken">
            <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
        </member>
        <member name="T:ProtoBuf.WireType">
            <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.None">
            <summary>
            Represents an error condition
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Variant">
            <summary>
            Base-128 variant-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.WireType.SignedVariant">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a variant integer that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
    </members>
</doc>
