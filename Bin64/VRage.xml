<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage</name>
    </assembly>
    <members>
        <member name="M:VRage.Audio.IMyAudio.ApplyEffect(VRage.Audio.IMySourceVoice,VRage.Utils.MyStringHash,VRage.Audio.MyCueId[],System.Nullable{System.Single},System.Boolean)">
            <summary>
            Creates effect on input emitter
            </summary>
            <param name="input">Emitter to work with</param>
            <param name="effect"></param>
            <param name="cueIds">additional cues if effect mixes them (ie. crossfade)</param>
            <returns>effect output sound</returns>
        </member>
        <member name="M:VRage.Audio.IMyAudio.TryGetAudioFilter(VRage.Audio.MyTargetVoice,VRage.Data.Audio.MyFilterType@,System.Single@,System.Single@)">
            <summary>
            Tries to get the filter on the specified audio voice.
            </summary>
            <param name="targetVoice">Which voice(s) to affect.</param>
            <param name="filterType">Filter type to set.</param>
            <param name="frequency">Frequency of the filter.
            
                Filter radian frequency calculated as (2 * sin(pi * (desired filter cutoff frequency)
                / sampleRate)). The frequency must be greater than or equal to 0 and less than
                or equal to SharpDX.XAudio2.XAudio2.MaximumFilterFrequency. The maximum frequency
                allowable is equal to the source sound's sample rate divided by six which corresponds
                to the maximum filter radian frequency of 1. For example, if a sound's sample
                rate is 48000 and the desired cutoff frequency is the maximum allowable value
                for that sample rate, 8000, the value for Frequency will be 1. If XAUDIO2_HELPER_FUNCTIONS
                is defined, XAudio2.h will include the XAudio2RadiansToCutoffFrequency and XAudio2CutoffFrequencyToRadians
                helper functions for converting between hertz and radian frequencies. Defining
                XAUDIO2_HELPER_FUNCTIONS will also include XAudio2CutoffFrequencyToOnePoleCoefficient
                for converting between hertz and a one-pole coefficient suitable for use with
                the LowPassOnePoleFilter and HighPassOnePoleFilter.
            </param>
            <param name="oneOverQ">OneOverQ of the filter.
            
                Reciprocal of Q factor. Controls how quickly frequencies beyond Frequency are
                dampened. Larger values result in quicker dampening while smaller values cause
                dampening to occur more gradually. Must be greater than 0 and less than or equal
                to SharpDX.XAudio2.XAudio2.MaximumFilterOneOverQ.
            </param>
            <returns>True if successful, false otherwise.</returns>
        </member>
        <member name="M:VRage.Audio.IMyAudio.SetAudioFilter(VRage.Audio.MyTargetVoice,VRage.Data.Audio.MyFilterType,System.Single,System.Single)">
            <summary>
            Set a filter on the specified audio voice.
            </summary>
            <param name="targetVoice">Which voice(s) to affect.</param>
            <param name="filterType">Filter type to set.</param>
            <param name="frequency">Frequency of the filter.</param>
            <param name="oneOverQ">OneOverQ of the filter.
            
                Reciprocal of Q factor. Controls how quickly frequencies beyond Frequency are
                dampened. Larger values result in quicker dampening while smaller values cause
                dampening to occur more gradually. Must be greater than 0 and less than or equal
                to SharpDX.XAudio2.XAudio2.MaximumFilterOneOverQ.
            </param>
        </member>
        <member name="T:VRage.Audio.MyReverbParameters">
            <summary>
            Describes parameters for use in the reverb APO.
                All parameters related to sampling rate or time are relative to a 48kHz voice
                and must be scaled for use with other sampling rates. For example, setting ReflectionsDelay
                to 300ms gives a true 300ms delay when the reverb is hosted in a 48kHz voice,
                but becomes a 150ms delay when hosted in a 24kHz voice.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.WetDryMix">
            <summary>
                Percentage of the output that will be reverb. Allowable values are from 0 to 100.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.RoomSize">
            <summary>
                The apparent size of the acoustic space. Permitted range is from 1 to 100 feet.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.Density">
            <summary>
               Controls the modal density in the late field reverberation. For colorless spaces,
               Density should be set to the maximum value (100). As Density is decreased, the
               sound becomes hollow (comb filtered). This is an effect that can be useful if
               you are trying to model a silo. Permitted range as a percentage is from 0 to
               100.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.DecayTime">
            <summary>
               Reverberation decay time at 1 kHz. This is the time that a full scale input signal
               decays by 60 dB. Permitted range is from 0.1 to infinity seconds.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.ReverbGain">
            <summary>
               Adjusts the intensity of the reverberations. Permitted range is from -100 to
               20 dB.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.ReflectionsGain">
            <summary>
               Adjusts the intensity of the early reflections. Permitted range is from -100
               to 20 dB.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.RoomFilterHF">
            <summary>
               Sets the intensity of the low-pass filter for both the early reflections and
               the late field reverberation at the corner frequency (RoomFilterFreq). Permitted
               range is from -100 to 0 dB.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.RoomFilterMain">
            <summary>
               Sets the pass band intensity level of the low-pass filter for both the early
               reflections and the late field reverberation. Permitted range is from -100 to
               0 dB.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.RoomFilterFreq">
            <summary>
               Sets the corner frequency of the low pass filter for the room effect. Permitted
               range is from 20 to 20,000 Hz.
               <para>&#160;</para>
               Note: All parameters related to sampling rate
               or time are relative to a 48kHz sampling rate and must be scaled for use with
               other sampling rates. See remarks section below for additional information.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.HighEQCutoff">
            <summary>
               Sets the corner frequency of the high pass filter that is controlled by the HighEQGain
               parameter. The values correspond to frequency in kHz as follows: Value 01234567891011121314
               Frequency (kHz)11.522.533.544.555.566.577.58 ? Permitted range is from 0 to 14
               (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.HighEQGain">
            <summary>
               Adjusts the decay time of high frequencies relative to the decay time at 1 kHz.
               When set to zero, high frequencies decay at the same rate as 1 kHz. When set
               to maximum value, high frequencies decay at a much faster rate than 1 kHz. Value012345678
               Gain (dB)-8-7-6-5-4-3-2-10 ? Permitted range is from 0 to 8 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.DisableLateField">
            <summary>
               If set to TRUE, disables late field reflection calculations. Disabling late field
               reflection calculations results in a significant CPU time savings.
               <para>&#160;</para>
               Note: The DirectX SDK versions of XAUDIO2 don't support this member.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.LowEQCutoff">
            <summary>
               Sets the corner frequency of the low pass filter that is controlled by the LowEQGain
               parameter. The values correspond to frequency in Hz as follows: Value0123456789
               Frequency (Hz)50100150200250300350400450500 ? Permitted range is from 0 to 9
               (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.LateDiffusion">
            <summary>
               Controls the character of the individual wall reverberations. Set to minimum
               value to simulate a hard flat surface and to maximum value to simulate a diffuse
               surface. Permitted range is from 0 to 15 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.EarlyDiffusion">
            <summary>
               Controls the character of the individual wall reflections. Set to minimum value
               to simulate a hard flat surface and to maximum value to simulate a diffuse surface.
               Permitted range is from 0 to 15 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.PositionMatrixRight">
            <summary>
               Gives a greater or lesser impression of distance from the source to the listener.
               Permitted range is from 0 to 30 (no units).
               <para>&#160;</para>
               Note: PositionMatrixRight is ignored in mono-in/mono-out mode.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.PositionMatrixLeft">
            <summary>
               Gives a greater or lesser impression of distance from the source to the listener.
               Permitted range is from 0 to 30 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.PositionRight">
            <summary>
               Same as PositionLeft, but affecting only the right input. Permitted range is
               from 0 to 30 (no units).
               <para>&#160;</para>
               Note: PositionRight is ignored in mono-in/mono-out mode.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.PositionLeft">
            <summary>
               Position of the left input within the simulated space relative to the listener.
               With PositionLeft set to the minimum value, the left input is placed close to
               the listener. In this position, early reflections are dominant, and the reverb
               decay is set back in the sound field and reduced in amplitude. With PositionLeft
               set to the maximum value, the left input is placed at a maximum distance from
               the listener within the simulated room. PositionLeft does not affect the reverb
               decay time (liveness of the room), only the apparent position of the source relative
               to the listener. Permitted range is from 0 to 30 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.SideDelay">
            <summary>
               Position of the left input within the simulated space relative to the listener.
               With PositionLeft set to the minimum value, the left input is placed close to
               the listener. In this position, early reflections are dominant, and the reverb
               decay is set back in the sound field and reduced in amplitude. With PositionLeft
               set to the maximum value, the left input is placed at a maximum distance from
               the listener within the simulated room. PositionLeft does not affect the reverb
               decay time (liveness of the room), only the apparent position of the source relative
               to the listener. Permitted range is from 0 to 30 (no units).
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.RearDelay">
            <summary>
               Delay for the left rear output and right rear output. Permitted range is from
               0 to 5 milliseconds.
               <para>&#160;</para>
               Note: All parameters related to sampling rate or time are
               relative to a 48kHz sampling rate and must be scaled for use with other sampling
               rates. See remarks section below for additional information.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.ReverbDelay">
            <summary>
               Delay of reverb relative to the first reflection. Permitted range is from 0 to
               85 milliseconds. 
               <para>&#160;</para>
               Note: All parameters related to sampling rate or time are relative
               to a 48kHz sampling rate and must be scaled for use with other sampling rates.
               See remarks section below for additional information.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.ReflectionsDelay">
            <summary>
               The delay time of the first reflection relative to the direct path. Permitted
               range is from 0 to 300 milliseconds. 
               <para>&#160;</para>
               Note: All parameters related to sampling
               rate or time are relative to a 48kHz sampling rate and must be scaled for use
               with other sampling rates. See remarks section below for additional information.
            </summary>
        </member>
        <member name="F:VRage.Audio.MyReverbParameters.LowEQGain">
            <summary>
               Adjusts the decay time of low frequencies relative to the decay time at 1 kHz.
               The values correspond to dB of gain as follows: Value0123456789101112 Gain (dB)-8-7-6-5-4-3-2-10+1+2+3+4
               <para>&#160;</para>
               Note: A LowEQGain value of 8 results in the decay time of low frequencies being
               equal to the decay time at 1 kHz. Permitted range is from 0 to 12 (no units).
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.LowPass">
            <summary>
            Attenuates (reduces) frequencies above the cutoff frequency.
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.BandPass">
            <summary>
            Attenuates frequencies outside a given range.
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.HighPass">
            <summary>
            Attenuates frequencies below the cutoff frequency.
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.Notch">
            <summary>
            Attenuates frequencies inside a given range.
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.LowPassOnePoleFilter">
            <summary>
            Attenuates frequencies above the cutoff frequency. This is a one-pole filter,
            and FilterParameters.OneOverQ has no effect.
            </summary>
        </member>
        <member name="F:VRage.Data.Audio.MyFilterType.HighPassOnePoleFilter">
            <summary>
            Attenuates frequencies below the cutoff frequency. This is a one-pole filter,
            and FilterParameters.OneOverQ has no effect.
            </summary>
        </member>
        <member name="T:VRage.Data.Audio.MyCurveType">
            <summary>
            Enumerator of available curve types
            </summary>
        </member>
        <member name="T:VRage.Components.AutomaticAttribute">
            <summary>
            Marks a field as an automatic reference.
            </summary>
        </member>
        <member name="T:VRage.Components.ComponentDebug">
            <summary>
                Helper class for entity component debugging.
            </summary>
        </member>
        <member name="M:VRage.Components.ComponentDebug.GetAll``1(``0)">
            <summary>
                Get all instances of the given component type.
            </summary>
            <param name="self"></param>
            <typeparam name="TComponent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.ComponentDebug.GetAll``1">
            <summary>
                Get all instances of a given component type.
            </summary>
            <typeparam name="TComponent"></typeparam>
            <returns></returns>
        </member>
        <member name="T:VRage.Components.ComponentDebugger">
            <summary>
            Base helper class for component debugging.
            </summary>
        </member>
        <member name="P:VRage.Components.ComponentDebugger.Instances">
            <summary>
            The collection of all active component instances.
            </summary>
        </member>
        <member name="M:VRage.Components.ComponentDebugger.OfType``1">
            <summary>
            The collection of all active component instances of a given type.
            </summary>
        </member>
        <member name="T:VRage.Components.ComponentDebuggerAttribute">
            <summary>
            Attribute used to specify a debugger for a given component base class.
            </summary>
        </member>
        <member name="T:VRage.Components.ComponentDebuggerIndexer">
            <summary>
            Indexer of component debug helpers.
            </summary>
        </member>
        <member name="T:VRage.Components.ComponentDependencyMapper`1">
            <summary>
            Dependency mapper for generic component attributes.
            </summary>
        </member>
        <member name="M:VRage.Components.ComponentDependencyMapper`1.Index``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Index a set of types, collecting additional types from their dependencies.
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="componentTypes"></param>
        </member>
        <member name="M:VRage.Components.ComponentDependencyMapper`1.Index(System.Collections.Generic.IEnumerable{VRage.Components.IComponentAttribute})">
            <summary>
            Index from a fixed set of components.
            </summary>
            <param name="componentAttributes"></param>
        </member>
        <member name="F:VRage.Components.ComponentDependencyMapper`1.m_cachedResolvers">
            <summary>
            Cached component resolvers.
            </summary>
        </member>
        <member name="F:VRage.Components.ComponentDependencyMapper`1.m_comparer">
            <summary>
            Component instance comparer.
            </summary>
        </member>
        <member name="P:VRage.Components.ComponentDependencyMapper`1.InstanceComparer">
            <summary>
            Comparer for component instances.
            </summary>
        </member>
        <member name="M:VRage.Components.ComponentDependencyMapper`1.BorrowResolver">
            <summary>
            Borrow one of the cached depdendency resolvers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.ComponentDependencyMapper`1.ReturnResolver(VRage.Utils.DependencyResolve.TypeDependencyMapper.Resolver)">
            <summary>
            Resturn a borrowed resolver.
            </summary>
            <param name="resolver"></param>
        </member>
        <member name="T:VRage.Components.ComponentDependencyMapper`1.ComponentDependencyComparer">
            <summary>
            Component instance depdency comparer.
            </summary>
        </member>
        <member name="T:VRage.Components.DebugDraw">
            <summary>
            Typeless helper class for component debug draw.
            </summary>
        </member>
        <member name="T:VRage.Components.DebugDraw`1">
            <summary>
            Debug helper for entity components 
            </summary>
            <typeparam name="TComponent"></typeparam>
        </member>
        <member name="P:VRage.Components.DebugDraw`1.Enabled">
            <summary>
            Whether debug drawing is enabled for this component.
            </summary>
        </member>
        <member name="T:VRage.Components.FixedUpdateAttribute">
            <summary>
            Indicates a method used for fixed update.
            </summary>
        </member>
        <member name="F:VRage.Components.FixedUpdateAttribute.UpdatePriority">
            <summary>
            Override for this update's default update priority.
            
            This is used for AtStart updates.
            </summary>
        </member>
        <member name="M:VRage.Components.FixedUpdateAttribute.#ctor(System.Boolean,System.Int32)">
            <summary>
            Schedule this method for updating every frame.
            </summary>
            <param name="atStart">Weather to have this on at start.</param>
            <param name="priority">Optional priority override for this update.</param>
        </member>
        <member name="T:VRage.Components.IComponent">
            <summary>
            Simplest description of a component.
            </summary>
        </member>
        <member name="T:VRage.Components.IComponentAttribute">
            <summary>
            Interface for attributes that describe a component.
            </summary>
        </member>
        <member name="T:VRage.Components.IComponentContainer">
            <summary>
            Simplest description of a component container.
            </summary>
        </member>
        <member name="M:VRage.Components.IComponentContainer.Get(System.Type)">
            <summary>
            Get a component of a given type.
            </summary>
            <param name="componentType">The type of the component.</param>
            <returns>The component instance if any.</returns>
        </member>
        <member name="P:VRage.Components.IComponentContainer.Logger">
            <summary>
            Logger used for this container.
            </summary>
        </member>
        <member name="T:VRage.Components.IComponentDebugDraw">
            <summary>
            Describes a component that supports debug drawing.
            </summary>
        </member>
        <member name="P:VRage.Components.IComponentDebugger.Instances">
            <summary>
            The collection of all active component instances.
            </summary>
        </member>
        <member name="T:VRage.Components.InitializationException">
            <summary>
            Exception thrown by objects or components when they experience a non-fatal initialization failure. In these cases the caller should not abort but should ignore the object if it's not critical.
            </summary>
        </member>
        <member name="P:VRage.Components.InitializationException.Message">
            <inheritdoc />
        </member>
        <member name="T:VRage.Components.IUpdatableComponent">
            <summary>
            Interface describing a component that is liked with a given update scheduler.
            </summary>
        </member>
        <member name="T:VRage.Components.MyComponentBase">
            <summary>
            Base class for universal functions provided by components.
            </summary>
        </member>
        <member name="F:VRage.Components.MyComponentBase.m_scheduledUpdateMap">
            <summary>
            Index of which update methods have been scheduled.
            </summary>
        </member>
        <member name="M:VRage.Components.MyComponentBase.#ctor">
            <summary>
            Instantiate a new component.
            </summary>
        </member>
        <member name="P:VRage.Components.MyComponentBase.Scheduler">
            <summary>
            The update scheduler used for this component.
            </summary>
        </member>
        <member name="P:VRage.Components.MyComponentBase.VRage#Components#IComponent#Container">
            <inheritdoc />
        </member>
        <member name="P:VRage.Components.MyComponentBase.ContainerBase">
            <summary>
            Container.
            </summary>
        </member>
        <member name="M:VRage.Components.MyComponentBase.AddFixedUpdate(VRage.Engine.MyFixedUpdate,System.Nullable{System.Int32})">
            <summary>
            Add a method for fixed update.
            Fixed updates are invoked every frame, this method automatically chooses the update priority based on update
            after/before attributes.
            To manually manage the update order see <see cref="M:VRage.Components.MyUpdateScheduler.AddFixedUpdate(VRage.Engine.MyFixedUpdate,System.Int32)"/>.
            </summary>
            <seealso cref="M:VRage.Components.MyUpdatePriorityManager.GetPriority(System.Type)"/>
            <param name="updateMethod">Method to be invoked every update.</param>
            <param name="priorityOverride">Optional override to the default computed priority.</param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.RemoveFixedUpdate(VRage.Engine.MyFixedUpdate)">
            <summary>
            Remove a method from fixed update.
            </summary>
        </member>
        <member name="M:VRage.Components.MyComponentBase.AddScheduledUpdate(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Schedule a method for time based update.
            </summary>
            <param name="updateMethod"></param>
            <param name="intervalMs"></param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.AddScheduledUpdate(VRage.Engine.MyTimedUpdate,System.TimeSpan)">
            <summary>
            Schedule a method for time based update.
            </summary>
            <param name="updateMethod"></param>
            <param name="interval"></param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.RemoveScheduledUpdate(VRage.Engine.MyTimedUpdate)">
            <summary>
            Removes a scheduled update from the queue.
            </summary>
            <param name="updateMethod">The update method to remove.</param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.AddScheduledCallback(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Schedule a method to be invoked once after the provided delay.
            To cancel a scheduled callback use the <see cref="M:VRage.Components.MyComponentBase.RemoveScheduledUpdate(VRage.Engine.MyTimedUpdate)"/> method.
            </summary>
            <param name="callback">The method to be invoked after the delay.</param>
            <param name="delayMs">The amount of milliseconds (approximately) to wait before calling the callback.</param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.AddScheduledCallback(VRage.Engine.MyTimedUpdate,System.TimeSpan)">
            <summary>
            Schedule a method to be invoked once after the provided delay.
            To cancel a scheduled callback use the <see cref="M:VRage.Components.MyComponentBase.RemoveScheduledUpdate(VRage.Engine.MyTimedUpdate)"/> method.
            </summary>
            <param name="callback">The method to be invoked after the delay.</param>
            <param name="delay">The amount of time (approximately) to wait before calling the callback.</param>
        </member>
        <member name="M:VRage.Components.MyComponentBase.CheckScheduler(System.Delegate)">
            <summary>
            Check that we have an update scheduler.
            </summary>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Components.MyComponentBase`1">
            <inheritdoc cref="T:VRage.Components.MyComponentBase"/>
        </member>
        <member name="P:VRage.Components.MyComponentBase`1.ContainerBase">
            <inheritdoc />
        </member>
        <member name="P:VRage.Components.MyComponentBase`1.Container">
            <summary>
            Container for this component
            </summary>
        </member>
        <member name="P:VRage.Components.MyComponentBase`1.VRage#Components#IUpdatableComponent#Scheduler">
            <inheritdoc/>
        </member>
        <member name="M:VRage.Components.MyComponentExtensions.GetLogger(VRage.Components.IComponent)">
            <summary>
            Get a logger for the specified component.
            </summary>
            <param name="component">The component to fetch the log for.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.MyComponentExtensions.GetLogger(VRage.Components.IComponent,System.Object)">
            <summary>
            Get a logger for a component with the provided object as it's context.
            </summary>
            <param name="component">The component instance.</param>
            <param name="context">The context to set on the logger.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.GetAutomatic(System.Type)">
            <summary>
            Get information about the automatic members of a component type.
            </summary>
            <param name="componenType"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.Index(System.Type)">
            <summary>
            This should only be invoked by other metadata indexers.
            </summary>
            <param name="type">Type to index.</param>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.AddUpdates(VRage.Components.MyComponentBase)">
            <summary>
            Add all <emph>from start</emph> updates on a component.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.RemoveUpdates(VRage.Components.MyComponentBase)">
            <summary>
            Add all <emph>from start</emph> updates on a component.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.AssignAutomatic(VRage.Components.IComponent)">
            <summary>
            Assign all automatic members in a component.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:VRage.Components.MyComponentFactory.ClearAutomatic(VRage.Components.IComponent)">
            <summary>
            Clear all automatic members in a component.
            </summary>
            <param name="component"></param>
        </member>
        <member name="T:VRage.Components.MyComponentFactory.AutomaticInfo">
            <summary>
            Metadata about an automatic member in a component class.
            </summary>
        </member>
        <member name="F:VRage.Components.MyComponentFactory.AutomaticInfo.MemberType">
            <summary>
            Type of the automatic member.
            </summary>
        </member>
        <member name="F:VRage.Components.MyComponentFactory.AutomaticInfo.Setter">
            <summary>
            Delegate that can be used to set the value of the automatic member.
            </summary>
        </member>
        <member name="F:VRage.Components.MyComponentFactory.ComponentInfo.Empty">
            <summary>
            Cached empty automatic info array.
            </summary>
        </member>
        <member name="T:VRage.Components.MyUpdatePriorityManager">
            <summary>
            The update priority manager allows for easy and painless utilization
            of priorities in combination with MyUpdateScheduler.
            
            By simply annotating the target classes with the UpdateBefore and UpdateAfter attributes
            one can have fully runtime generated priorities.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdatePriorityManager.IntroduceUpdateable(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Introduce a new type to be considered in priority calculation, along with it's dependencies if any.
            
            It is *critical* to only call this *before* processing of the indexer.
            I.E.: Only another indexer should call this and only during index time, never at processing time.
            </summary>
            <param name="type">The type that contains an update.</param>
            <param name="dependencies">The type's dependencies.</param>
        </member>
        <member name="M:VRage.Components.MyUpdatePriorityManager.PrintPrioritiesToLog(System.Collections.Generic.List{System.Type},VRage.Library.Collections.MyListDictionary{System.Type,System.Type})">
            <summary>
            Print information to log about all fixed rate priorities.
            </summary>
            <param name="order">list of ordered types</param>
            <param name="dependencies"></param>
        </member>
        <member name="T:VRage.Components.MyUpdateScheduler">
             <summary>
             The update scheduler is a versatile update queue runner with support for fixed and time based updates.
             </summary>
             <remarks>
             The scheduler guarantees no starvation by making sure time based updates
             be scheduled always forward from their execution time, meaning that if they
             get delayed because of a surge in load that update will not be called again on
             a shorter interval but at the same expected delay.
            
             In addition to limiting the amount of frame time taken by the updates (in real time) we can have
             a guarantee that times updates do not introduce extra load, but simply have their execution delayed.
             </remarks>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_updateTimer">
            <summary>
            Timer used to make sure time based updates do not get over the frame budget.
            </summary>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_ticks">
            <summary>
            Current time in ticks.
            </summary>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_insideUpdate">
            <summary>
            Whether an update is currently under way.
            </summary>
        </member>
        <member name="P:VRage.Components.MyUpdateScheduler.ExtendedProfiling">
            <summary>
            If turned on, the individual methods will be logged in the profiler.
            </summary>
        </member>
        <member name="P:VRage.Components.MyUpdateScheduler.CurrentUpdateTime">
            <summary>
            Time the last update started.
            </summary>
        </member>
        <member name="P:VRage.Components.MyUpdateScheduler.CurrentUpdateTicks">
            <summary>
            Time in ticks the last update started.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.#ctor(System.TimeSpan)">
            <summary>
            Create a new update scheduler instance, with optional initial time.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.RunUpdates(System.TimeSpan)">
             <summary>
             Run all scheduled fixed and time based updates.
            
             Fixed updates are run every time this method is invoked.
             Time based updates will be updated depending on the current time.
             </summary>
             <param name="currentTime">Provided current update time. It's fine for this to differ from real time.</param>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.GetUpdatePriority``1">
            <summary>
            Get the update priority assigned to type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>The priority assigned to the type T, or zero if none was provided.</returns>
        </member>
        <member name="T:VRage.Components.MyUpdateScheduler.TimedUpdate">
             <summary>
            
             </summary>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_pendingUpdates">
            <summary>
            Priority queue of pending updates.
            </summary>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_timedUpdatesLock">
            <summary>
            Lock protecting timed update entries.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.AddScheduledCallback(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Similar to a timed update, the difference being that the callback will only be invoked once.
            </summary>
            <param name="timedUpdate">The callback.</param>
            <param name="interval">The delay in milliseconds for the callback, if set to zero the callback will be invoked as soon as possible.</param>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.AddScheduledUpdate(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Add a callback to be invoked at a fixed rate in milliseconds.
            </summary>
            <param name="timedUpdate">the callback.</param>
            <param name="intervalMilliseconds">The desired call rate.</param>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.RemoveScheduledUpdate(VRage.Engine.MyTimedUpdate)">
            <summary>
            Remove a time based update callback from the queue.
            </summary>
            <param name="timedUpdate">Updatable to remove.</param>
            <returns>Amount of ticks that passed from adding to the queue.</returns>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.RunTimedUpdates">
            <summary>
            Run scheduled time based updates.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.FixedUpdate.Equals(System.Object)">
            <summary>
            Custom equals: ignore update order.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.FixedUpdate.GetHashCode">
            <summary>
            Custom hash code: ignore update order.
            </summary>
        </member>
        <member name="F:VRage.Components.MyUpdateScheduler.m_fixedUpdate">
            <summary>
            List of updates to run every frame.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.ApplyChanges">
            <summary>
            Apply any additions or removals of updates that are scheduled.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.RunFixedUpdates">
            <summary>
            Execute all scheduled fixed rate updates.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.AddFixedUpdate(VRage.Engine.MyFixedUpdate,System.Int32)">
            <summary>
            Queue an update method to be invoked every simulation frame.
            </summary>
            <remarks>
            This method is Thread Safe.
            </remarks>
            <param name="update">Update callback.</param>
            <param name="updatePriority">Callbacks are invoked in ascending priority order.</param>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.RemoveFixedUpdate(VRage.Engine.MyFixedUpdate)">
             <summary>
             Remove a queued fixed update method.
            
             This method is Thread Safe.
             </summary>
             <param name="update">Update callback.</param>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.HidePriority(System.Int32)">
            <summary>
            Encode the priority such that execution is skipped (priority &lt; 0) but the value is still recoverable.
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.Clear">
            <summary>
            Clear all updates in queue.
            </summary>
        </member>
        <member name="M:VRage.Components.MyUpdateScheduler.PrintFixedUpdatesToLog">
            <summary>
            Print information to log about all scheduled fixed rate updates.
            </summary>
        </member>
        <member name="T:VRage.Components.UpdateAttribute">
            <summary>
            Marks a method used for update.
            
            This update is time based and unreliable, the method should have the signature of
            Action&lt;long&gt;
            </summary>
        </member>
        <member name="M:VRage.Components.UpdateAttribute.#ctor(System.Int32,System.Boolean)">
            <summary>
            Update attribute.
            </summary>
            <param name="frequencyMs"></param>
            <param name="atStart"></param>
        </member>
        <member name="M:VRage.Components.UpdateAttribute.#ctor(System.Boolean)">
            <summary>
            Update attribute.
            </summary>
            <param name="atStart"></param>
        </member>
        <member name="F:VRage.Components.MyDependencyAttribute.Recursive">
            <summary>
            Whether this dependency applies to children of the dependency.
            </summary>
        </member>
        <member name="F:VRage.Components.MyDependencyAttribute.Critical">
            <summary>
            Whether this dependency is a requirement.
            
            Sometimes the dependency only means ordering when the dependent is available.
            </summary>
        </member>
        <member name="T:VRage.Engine.AppInformation">
            <summary>
            Meta information about the application.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.Name">
            <summary>
            Human readable name of this app.
            
            This is used to decorate the log, and in many other internal places.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.SafeName">
            <summary>
            Cleaned up name string that is safe to use in most settings, spaces and any non-ASCII characters are all removed.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.Description">
            <summary>
            Short description of this app. Used internally.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.Developer">
            <summary>
            Name of the developer.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.Website">
            <summary>
            Website of the product or developer.
            </summary>
        </member>
        <member name="F:VRage.Engine.AppInformation.Version">
            <summary>
            Version of the app.
            </summary>
            <remarks>
            This is used by many places, including the save compatibility mechanism in the session.
            
            Therefore it's very important to integrate the updating of this number in your release process.
            </remarks>
        </member>
        <member name="F:VRage.Engine.AppInformation.VersionString">
            <summary>
            Printable string representation of the version number.
            </summary>
        </member>
        <member name="T:VRage.Engine.IApplicationPackage">
            <summary>
            Definition for a set of assemblies and content files that compose a module of an application.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.Name">
            <summary>
            Non-unique user friendly name for this package.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.Id">
            <summary>
            Unique id for this package.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.Version">
            <summary>
            Version for this package.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.Assemblies">
            <summary>
            Collection of assemblies in this package.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.ContentPath">
            <summary>
            Path where assets in this package are stored.
            </summary>
        </member>
        <member name="P:VRage.Engine.IApplicationPackage.IsMain">
            <summary>
            Whether this application package is the main package for the current app.
            </summary>
        </member>
        <member name="M:VRage.Engine.CommandLine.CliObjectMetadata.GetAttribute(System.String)">
            <summary>
            Get the option attribute for a given option.
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Engine.CommandLine.CommandLineOptionAttribute">
            <summary>
            Allows the user to control how a command line option field behaves.
            </summary>
        </member>
        <member name="F:VRage.Engine.CommandLine.CommandLineOptionAttribute.Name">
            <summary>
            Override the name of the field.
            </summary>
        </member>
        <member name="F:VRage.Engine.CommandLine.CommandLineOptionAttribute.Summary">
            <summary>
            A short description for this option.
            </summary>
        </member>
        <member name="F:VRage.Engine.CommandLine.CommandLineOptionAttribute.Description">
            <summary>
            Description for this option.
            </summary>
        </member>
        <member name="F:VRage.Engine.CommandLine.CommandLineOptionAttribute.ListAsMultiple">
            <summary>
            Interpret a list member as an option that can be read multiple times, alternatively
            the option must be specified without spaces and with commas by the user.
            With each value between commas taken as one entry.
            </summary>
        </member>
        <member name="T:VRage.Engine.CommandLine.CommandLineParser">
            <summary>
            Simple command line argument handler.
            </summary>
        </member>
        <member name="M:VRage.Engine.CommandLine.CommandLineParser.Prepare(VRage.Engine.CommandLineObject[])">
            <summary>
            Prepare this parser for handling options.
            </summary>
            <param name="argumentObjects">List of objects representing command line options.</param>
        </member>
        <member name="M:VRage.Engine.CommandLine.CommandLineParser.Prepare(System.Collections.Generic.IEnumerable{VRage.Engine.CommandLineObject})">
            <summary>
            Prepare this parser for handling options.
            </summary>
            <param name="argumentObjects">List of objects representing command line options.</param>
        </member>
        <member name="M:VRage.Engine.CommandLine.CommandLineParser.Parse(System.String[]@)">
            <summary>
            Parses a command line into the provided argument objects, each consumed argument is removed from the array.
            </summary>
            <param name="args">List of command line arguments provided.</param>
        </member>
        <member name="M:VRage.Engine.CommandLine.CommandLineParser.WriteSummary(System.IO.TextWriter,System.String)">
            <summary>
            Write the summary of available options using the provided writer. Optionally write information about the specified <paramref name="option"/>.
            </summary>
        </member>
        <member name="F:VRage.Engine.CommandLine.CommandLineParser.Errors">
            <summary>
            List of parsing errors.
            </summary>
        </member>
        <member name="T:VRage.Engine.CommandLine.IStringConverter">
            <summary>
            Represents an object capable of converting other objects to and from strings.
            </summary>
        </member>
        <member name="T:VRage.Engine.CommandLineObject">
            <summary>
            Base class for command line objects.
            
            These objects are used to represent command line options a system may accept.
            
            Any field or property of a primitive type is automatically available under the key '--{Prefix}-{prop name}'.
            The behavior of these properties can be controlled with special attributes.
            </summary>
        </member>
        <member name="P:VRage.Engine.CommandLineObject.Prefix">
            <summary>
            Prefix to all options supported by this object.
            </summary>
            <remarks>
            Systems in the core engine should use the common prefix pattern 'vrage-{short system name}'.
            </remarks>
        </member>
        <member name="P:VRage.Engine.CommandLineObject.Name">
            <summary>
            Name of this object, displayed when listing options.
            </summary>
        </member>
        <member name="T:VRage.Engine.CoreLog">
            <summary>
            Minimal logging mechanism for the core engine.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreLog.Instance">
            <summary>
            Singleton instance of the core log.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreLog.Logger">
            <summary>
            Logger of the core log <see cref="F:VRage.Engine.CoreLog.Instance"/>.
            </summary>
        </member>
        <member name="P:VRage.Engine.CoreLog.IsRedirected">
            <summary>
            Whether the CoreLog log MyHashUtils been redirected to a file.
            </summary>
        </member>
        <member name="M:VRage.Engine.CoreLog.RedirectTo(VRage.Logging.ILogger)">
            <summary>
            Redirect the output of this log to another logger.
            </summary>
            <param name="externalLog"></param>
        </member>
        <member name="F:VRage.Engine.CoreLog.m_logTranscript">
            <summary>
            Transcript of the log, kept wile the log is not redirected.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreLog.m_temporaryStorage">
            <summary>
            Temporary string builder used to construct the line prefix.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreLog.m_mainThreadId">
            <summary>
            Thread that first invoked the core log (assumed to be the main thread).
            </summary>
        </member>
        <member name="M:VRage.Engine.CoreLog.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="T:VRage.Engine.CoreConfiguration">
            <summary>
            Configuration parameters for the VRage Engine core.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreConfiguration.MetadataAssemblies">
            <summary>
            List of assemblies to include in metadata processing.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreConfiguration.Bootstrapper">
            <summary>
            System invoked to bootstrap the engine.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreConfiguration.Systems">
            <summary>
            List of systems to load.
            </summary>
        </member>
        <member name="F:VRage.Engine.CoreConfiguration.SystemConfiguration">
            <summary>
            Configuration parameters for the loaded systems.
            </summary>
        </member>
        <member name="T:VRage.Engine.CoreConfiguration.SystemReference">
            <summary>
            Reference to a system.
            </summary>
        </member>
        <member name="T:VRage.Engine.CorePreLoadCommandLineObject">
            <summary>
            Command line options for the engine core.
            </summary>
        </member>
        <member name="T:VRage.Engine.EngineSystem">
            <inheritdoc cref="T:VRage.Engine.IEngineSystem"/>
        </member>
        <member name="P:VRage.Engine.EngineSystem.Container">
            <inheritdoc/>
        </member>
        <member name="P:VRage.Engine.EngineSystem.Log">
            <summary>
            Logger the system may use to record events.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.SetContainer(VRage.Engine.VRageCore)">
            <summary>
            Set the container for this system.
            </summary>
            <param name="coreInstance">The VRageCore instance that contains this system.</param>
        </member>
        <member name="M:VRage.Engine.EngineSystem.RaiseInit">
            <summary>
            Initializer called by the engine core.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.RaiseStart">
            <summary>
            Invoked after all systems are initialized and the engine is starting.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.RaiseShutdown">
            <summary>
            Called when the engine is shutting down.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.Init">
            <summary>
            Initialize this system.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.Start">
            <summary>
            Invoked after all systems are initialized and the engine is starting.
            </summary>
        </member>
        <member name="M:VRage.Engine.EngineSystem.Shutdown">
            <summary>
            Called when the engine is shutting down.
            </summary>
        </member>
        <member name="P:VRage.Engine.EngineSystem.Scheduler">
            <inheritdoc />
        </member>
        <member name="T:VRage.Engine.EngineSystem`1">
            <inheritdoc cref="T:VRage.Engine.EngineSystem" />
        </member>
        <member name="M:VRage.Engine.EngineSystem`1.Init">
            <inheritdoc/>
        </member>
        <member name="M:VRage.Engine.EngineSystem`1.Init(`0)">
            <inheritdoc/>
        </member>
        <member name="T:VRage.Engine.IEngineBootstrapper">
            <summary>
            Interface describing a system that is invoked first, before all others to do any global initialization (creating log files, setting up common paths, etc).
            </summary>
            <remarks>
            The engine bootstrapper is always initialized before all other systems.
            </remarks>
        </member>
        <member name="M:VRage.Engine.IEngineBootstrapper.Bootstrap(VRage.Engine.VRageCore,VRage.Engine.CoreConfiguration,System.String[]@)">
            <summary>
            Bootstrap the engine. The method can modify the configuration and or command line arguments right before the engine processes them.
            </summary>
            <remarks>
            Bootstrapping is invoked before the engine even processes the parameters and command line, so it is invoked before this system is initialized and before any other systems are as well.
            
            Any changes to the core parameters or the command line array will affect initialization.
            
            This method usually should initialize the core log to point to a physical file path, as the default behavior is to just write the messages to the program output.
            </remarks>
            <param name="coreInstance">The engine instance to be initialized.</param>
            <param name="configuration">The parameters that will be utilized to initialize the engine.</param>
            <param name="commandline">The command line arguments provided to the program.</param>
        </member>
        <member name="M:VRage.Engine.IEngineBootstrapper.EngineShutDown">
            <summary>
            Invoked after all other systems are unloaded and the engine is about to return control to the caller.
            </summary>
        </member>
        <member name="T:VRage.Engine.IInitBeforeMetadata">
             <summary>
             Interface used to mark engine systems that should initialize before metadata is loaded.
             </summary>
             <remarks>
             <para>
             Systems implementing this interface have their <see cref="M:VRage.Engine.EngineSystem.Init"/>/<see cref="M:VRage.Engine.IConfigurableSystem`1.Init(`0)"/> methods invoked before metadata is loaded.
             </para>
            
             <para>
             Later when the regular initialization moment comes the <see cref="M:VRage.Engine.IInitBeforeMetadata.AfterMetadataInitialized"/> method is invoked instead.
             </para>
             
             <para>
             <b>Note:</b> Since metadata is not yet loaded any features that rely on it will not be available yet (such as members annotated with the <see cref="T:VRage.Components.AutomaticAttribute"/>).
             This is why the <see cref="M:VRage.Engine.IInitBeforeMetadata.AfterMetadataInitialized"/> method is provided.
             </para>
             </remarks>
        </member>
        <member name="M:VRage.Engine.IInitBeforeMetadata.AfterMetadataInitialized">
            <summary>
            Callback invoked after metadata has been loaded.
            </summary>
        </member>
        <member name="T:VRage.Engine.MainApplicationPackage">
            <summary>
            Application package for a main application executable
            </summary>
        </member>
        <member name="T:VRage.Engine.Util.CoreProgram">
            <summary>
            Simple shorthand for starting and running the VRage engine using an xml config file.
            </summary>
        </member>
        <member name="M:VRage.Engine.Util.CoreProgram.Run(VRage.Engine.AppInformation,System.String[]@,System.String)">
            <summary>
            Start the VRage engine with the provided parameters. This method does not return.
            </summary>
            <param name="appInfo">App info for the application being executed.</param>
            <param name="args">Command line arguments to be parsed by the engine.</param>
            <param name="configFile">The path to the configuration file to load.</param>
            <remarks>
            If the path to the configuration file is not absolute then this method will try
            to load it relative to the path of the entry point assembly for the current app domain. (see <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>).
            
            If for some reason that assembly's location cannot be determined
            (<c>Assembly.GetEntryAssembly().Location == null</c>) we fall back to the current working directory (<see cref="P:System.Environment.CurrentDirectory"/>).
            </remarks>
        </member>
        <member name="M:VRage.Engine.Util.CoreProgram.RunAndReturn(VRage.Engine.AppInformation,System.String[]@,System.String)">
            <summary>
            Start the VRage engine with the provided parameters. After the engine exits the exit code is returned to the caller.
            </summary>
            <param name="appInfo">App info for the application being executed.</param>
            <param name="args">Command line arguments to be parsed by the engine.</param>
            <param name="configFile">The path to the configuration file to load.</param>
            <remarks>
            If the path to the configuration file is not absolute then this method will try
            to load it relative to the path of the entry point assembly for the current app domain. (see <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>).
            
            If for some reason that assembly's location cannot be determined
            (<c>Assembly.GetEntryAssembly().Location == null</c>) we fall back to the current working directory (<see cref="P:System.Environment.CurrentDirectory"/>).
            </remarks>
        </member>
        <member name="M:VRage.Engine.Util.CoreProgram.Initialize(VRage.Engine.AppInformation,System.String[]@,System.String)">
            <summary>
            Initialize the VRage engine with the provided parameters..
            </summary>
            <param name="appInfo">App info for the application being executed.</param>
            <param name="args">Command line arguments to be parsed by the engine.</param>
            <param name="configFile">The path to the configuration file to load.</param>
            <remarks>
            If the path to the configuration file is not absolute then this method will try
            to load it relative to the path of the entry point assembly for the current app domain. (see <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>).
            
            If for some reason that assembly's location cannot be determined
            (<code>Assembly.GetEntryAssembly().Location == null</code>) we fall back to the current working directory (<see cref="P:System.Environment.CurrentDirectory"/>).
            </remarks>
        </member>
        <member name="M:VRage.Engine.Util.CoreProgram.LoadParameters(System.String)">
            <summary>
            Load the parameters for an engine instance from a config file.
            </summary>
            <param name="configFile">The path to the configuration file to load.</param>
            <remarks>
            If the path to the configuration file is not absolute then this method will try
            to load it relative to the path of the entry point assembly for the current app domain. (see <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>).
            
            If for some reason that assembly's location cannot be determined
            (<code>Assembly.GetEntryAssembly().Location == null</code>) we fall back to the current working directory (<see cref="P:System.Environment.CurrentDirectory"/>).
            </remarks>
        </member>
        <member name="T:VRage.Engine.DefaultImplementationAttribute">
            <summary>
            Describes which is the default implementation for an interface.
            
            This should be used to annotate any interfaces or abstract classes that may be dependencies of another type.
            </summary>
        </member>
        <member name="T:VRage.Engine.ISystemCommandLine`1">
            <summary>
            Interface describing a system that can handle command line options.
            </summary>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="M:VRage.Engine.ISystemCommandLine`1.HandleCommandLine(`0)">
             <summary>
             Called by the core to allow the system to get any command line arguments transferred to it.
            
             These arguments arrive in the form of a arguments object that specifies the arguments via it's members.
             </summary>
             <param name="args">The command line arguments holder.</param>
        </member>
        <member name="T:VRage.Engine.IConfigurableSystem`1">
             <summary>
             Interface used to mark engine systems that can be initialized with a parameter object.
            
             Systems that implement this interface can only implement it once.
             </summary>
             <typeparam name="TConfiguration">The type of the configuration object for this system.</typeparam>
        </member>
        <member name="M:VRage.Engine.IConfigurableSystem`1.Init(`0)">
             <summary>
             Initializer called by the engine core.
            
             Systems implementing this interface will have this method
             invoked <emph>instead</emph> of <seealso cref="M:VRage.Engine.EngineSystem.Init"/>.
             </summary>
             <param name="configuration">An object provided to the core by the caller to initialize this system.</param>
        </member>
        <member name="T:VRage.Engine.MyTimedUpdate">
            <summary>
            This delegate describes a method that handles a time based update.
            </summary>
            <param name="deltaFrames"></param>
        </member>
        <member name="T:VRage.Engine.MyFixedUpdate">
            <summary>
            This delegate describes a method that handles a fixed update.
            </summary>
        </member>
        <member name="T:VRage.Engine.IUpdateScheduler">
            <summary>
            Describes an object capable of scheduling and managing updates.
            </summary>
        </member>
        <member name="M:VRage.Engine.IUpdateScheduler.AddScheduledCallback(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Similar to a timed update, the difference being that the callback will only be invoked once.
            </summary>
            <param name="timedUpdate">The callback.</param>
            <param name="interval">The delay in milliseconds for the callback, if set to zero the callback will be invoked as soon as possible.</param>
        </member>
        <member name="M:VRage.Engine.IUpdateScheduler.AddScheduledUpdate(VRage.Engine.MyTimedUpdate,System.Int64)">
            <summary>
            Add a callback to be invoked at a fixed rate in milliseconds.
            </summary>
            <param name="timedUpdate">the callback.</param>
            <param name="intervalMilliseconds">The desired call rate.</param>
        </member>
        <member name="M:VRage.Engine.IUpdateScheduler.RemoveScheduledUpdate(VRage.Engine.MyTimedUpdate)">
            <summary>
            Remove a time based update callback from the queue.
            </summary>
            <param name="timedUpdate">Updatable to remove.</param>
            <returns>Amount of ticks that passed from adding to the queue.</returns>
        </member>
        <member name="M:VRage.Engine.IUpdateScheduler.AddFixedUpdate(VRage.Engine.MyFixedUpdate,System.Int32)">
            <summary>
            Queue an update method to be invoked every simulation frame.
            
            This method is Thread Safe.
            </summary>
            <param name="update">Update callback.</param>
            <param name="updatePriority">Callbacks are invoked in ascending priority order.</param>
        </member>
        <member name="M:VRage.Engine.IUpdateScheduler.RemoveFixedUpdate(VRage.Engine.MyFixedUpdate)">
            <summary>
            Remove a queued fixed update method.
            
            This method is Thread Safe.
            </summary>
            <param name="update">Update callback.</param>
        </member>
        <member name="T:VRage.Engine.IUpdateSystem">
            <summary>
            A system used to handle generic engine update.
            </summary>
        </member>
        <member name="P:VRage.Engine.IUpdateSystem.Scheduler">
            <summary>
            Object capable of scheduling updates in this loop.
            </summary>
        </member>
        <member name="P:VRage.Engine.IUpdateSystem.TicksPerSecond">
            <summary>
            Number of update frames per second.
            </summary>
        </member>
        <member name="P:VRage.Engine.IUpdateSystem.TickLength">
            <summary>
            Duration of a tick in seconds. Matches the number of ticks per second.
            </summary>
        </member>
        <member name="E:VRage.Engine.IUpdateSystem.ExceptionHandler">
            <summary>
            Event fired to allow handling of exceptions inside the update loop.
            </summary>
        </member>
        <member name="M:VRage.Engine.IUpdateSystem.RunLoop">
            <summary>
            Run the update loop until it is stopped.
            </summary>
            <returns>The exit code from the <see cref="M:VRage.Engine.IUpdateSystem.ExitLoop(System.Int32)"/> call.</returns>
        </member>
        <member name="M:VRage.Engine.IUpdateSystem.ExitLoop(System.Int32)">
            <summary>
            Exit the update loop with the provided status code.
            </summary>
            <param name="status">The exit code for the loop.</param>
            <remarks>
            This method is thread safe.
            </remarks>
        </member>
        <member name="T:VRage.Engine.IEngineSystem">
             <summary>
             Interface describing a VRage Engine system.
            
             Systems are components of the engine that have lifetime equal to that of the engine instance itself.
             </summary>
        </member>
        <member name="T:VRage.Engine.MissingAttributeException">
            <inheritdoc />
            <summary>
            Exception representing that an attribute was expected but was not found.
            </summary>
        </member>
        <member name="T:VRage.Engine.SimpleUpdate">
            <summary>
            Manager of the engine's main update loop.
            </summary>
        </member>
        <member name="E:VRage.Engine.SimpleUpdate.ExceptionHandler">
            <inheritdoc/>
        </member>
        <member name="T:VRage.Engine.SystemDescriptor">
            <summary>
            Descriptor of a VRage system.
            </summary>
        </member>
        <member name="F:VRage.Engine.SystemDescriptor.FriendlyName">
            <summary>
            A short user readable name used for debug and logging.
            </summary>
        </member>
        <member name="F:VRage.Engine.SystemDescriptor.Class">
            <summary>
            The actual class implementing the system.
            </summary>
        </member>
        <member name="F:VRage.Engine.SystemDescriptor.ParametersType">
             <summary>
             Type of the object used for the system's parameters.
            
             This object will be created and expected to be XML serializable if the engine is initialized with XmlCoreParams.
             </summary>
        </member>
        <member name="F:VRage.Engine.SystemDescriptor.CommandlineType">
            <summary>
            Type of the command line arguments object. This class must inherit from the abstract base <see cref="T:VRage.Engine.CommandLineObject"/>.
            </summary>
        </member>
        <member name="F:VRage.Engine.SystemDescriptor.Dependencies">
             <summary>
             Descriptors for other systems that this system depends on.
            
             When a system has a dependency, it is initialized before it, even if it was not specified through the core parameters.
             </summary>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.#ctor(VRage.Engine.SystemAttribute,System.Type)">
            <summary>
            Instantiate a new descriptor from an attribute.
            </summary>
            <param name="attribute">The attribute annotating the system.</param>
            <param name="systemType">The type of the system.</param>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.ReadConfigurationInfo">
            <summary>
            Read metadata about system parameters.
            </summary>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.FeedCommandLine(VRage.Engine.IEngineSystem,System.Object)">
            <summary>
            Feed the command line object to a system instance described by this object.
            </summary>
            <param name="system">The system instance.</param>
            <param name="cli">The command line args</param>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.InitWithConfiguration(VRage.Engine.IEngineSystem,System.Object)">
            <summary>
            Init the system with parameters.
            </summary>
            <param name="system">The system instance.</param>
            <param name="parameters">The command line args</param>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.Lookup(System.String,System.String)">
            <summary>
            Lookup the descriptor for the specified system. Optionally an assembly hint can be provided if the system is not in the main engine assembly.
            </summary>
            <param name="path">The path to a system class.</param>
            <param name="assemblyHint">Assembly to load and look into if needed.</param>
            <returns>The descriptor or null if not found.</returns>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.Get(VRage.Engine.IEngineSystem)">
            <summary>
            Get the system descriptor for a system instance.
            </summary>
            <param name="system"></param>
            <returns>A valid descriptor for that system or null in case the system does not have a descriptor.</returns>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.Get``1">
            <summary>
            Get the system descriptor for a system type.
            </summary>
            <typeparam name="TSystem">The type of the system.</typeparam>
            <returns>A valid descriptor for that system or null in case the system does not have a descriptor.</returns>
        </member>
        <member name="M:VRage.Engine.SystemDescriptor.Get(System.Type)">
            <summary>
            Get the system descriptor for a system type.
            </summary>
            <param name="type">The type of the system.</param>
            <returns>A valid descriptor for that system or null in case the system does not have a descriptor.</returns>
        </member>
        <member name="T:VRage.Engine.GenericInterfaceHierarchyHelper">
            <summary>
            Helper methods for generic interface hierarchies.
            </summary>
            <remarks>
            A generic interface hierarchy is a situation where a generic interface describes a set of type safe methods on an object.
            In order to preserve type safety child classes can re-implement the interface for a type that is a child of the parent's implemented type.
            
            Example:
            <code>
            interface IProcessor&lt;TObject&gt; {
                void Process(TObject obj);
            }
            
            class FooContainer : IProcessor&lt;Foo&gt; {
                void Process(Foo obj) {...}
            }
            
            class BarContainer : FooContainer, IProcessor&lt;Bar&gt; {
                void Process(Bar obj) {
                    base.Process(obj);
                    ...
                }
            }
            </code>
            
            In this case it might be important to the caller to:
            <ul>
            <li>Enforce that a class in this hierarchy does not implement the interface more than once.</li>
            <li>Enforce that a class in the hierarchy only implements the interface for a generic argument that is a child of it's parent's generic argument.</li>
            <li>To be able to get the leaf-most implementation of the interface.</li>
            </ul>
            
            </remarks>
        </member>
        <member name="M:VRage.Engine.GenericInterfaceHierarchyHelper.VerifyAndGetImplementation(System.Type,System.Type)">
            <summary>
            Verify that the hierarchy implements the generic interface correctly.
            
            Then return the mapping for the leaf-most implementation.
            </summary>
            <param name="iFaceType">The target generic interface.</param>
            <param name="targetType">The type to verify and extract the implementation from.</param>
            <returns>An interface mapping of the leaf-most interface implementation.</returns>
            <exception cref="T:System.Reflection.AmbiguousMatchException">Thrown if any member of type's hierarchy implements the interface more than once.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if any member of the type's hierarchy implements the generic interface to a type that is not compatible with the last parent's implementation.</exception>
        </member>
        <member name="T:VRage.Engine.SystemAttribute">
             <summary>
             Descriptor of a VRage system.
            
             Every system that can be loaded by the engine needs to be annotated by a descriptor.
             </summary>
        </member>
        <member name="F:VRage.Engine.SystemAttribute.FriendlyName">
            <summary>
            A short user readable name used for debug and logging.
            </summary>
        </member>
        <member name="M:VRage.Engine.SystemAttribute.#ctor(System.String)">
            <summary>
            Declare a new system descriptor.
            </summary>
            <param name="friendlyName"></param>
        </member>
        <member name="T:VRage.Engine.SystemDependencyHelper">
            <summary>
            Helper for system management, dependency resolution
            </summary>
        </member>
        <member name="M:VRage.Engine.SystemDependencyHelper.Resolve(System.Collections.Generic.List{VRage.Engine.SystemDescriptor},System.Collections.Generic.HashSet{System.Type})">
            <summary>
            Resolve the dependencies of the provided descriptors and order them accordingly.
            </summary>
            <param name="descriptors">List of system descriptor specified to load.</param>
            <param name="outCriticalSystems">Storage for the types of systems that are critical dependencies.</param>
        </member>
        <member name="T:VRage.Engine.VRageCore">
            <summary>
            Core engine class.
            </summary>
            <remarks>
            The VRage Core is a container for engine systems,
            which are the most basic component object of the VRage Engine.
            </remarks>
        </member>
        <member name="T:VRage.Engine.VRageCore.State">
            <summary>
            Describes th state of this object.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_state">
            <summary>
            Strict object state management since this is such a fundamental object.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_systems">
            <summary>
            List of systems in load order.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_systemsByType">
            <summary>
            Index of systems by type. Be it the system's type or some interface it implements.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_update">
            <summary>
            Update component shortcut.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_engineBootstrapper">
            <summary>
            Bootstrapper if any.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_unprocessedArguments">
            <summary>
            Array of unprocessed arguments.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.m_assemblies">
            <summary>
            Assemblies included in the main configuration.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.CoreVersion">
            <summary>
            Version of the core engine.
            </summary>
        </member>
        <member name="P:VRage.Engine.VRageCore.Instance">
            <summary>
            Global core instance.
            </summary>
            <remarks>This reference is set as required in the core's constructor.</remarks>
            <seealso cref="M:VRage.Engine.VRageCore.#ctor(VRage.Engine.AppInformation,System.Boolean)"/>
        </member>
        <member name="P:VRage.Engine.VRageCore.Info">
            <summary>
            Information about this app.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.Log">
            <summary>
            Core log object.
            </summary>
        </member>
        <member name="F:VRage.Engine.VRageCore.Verbose">
            <summary>
            Whether this engine instance is operating in verbose mode.
            </summary>
            <remarks>This is controlled by the <c>--verbose</c> command line option, but can also be directly switched at runtime.</remarks>
        </member>
        <member name="P:VRage.Engine.VRageCore.Systems">
            <summary>
            Get all the systems currently initialized.
            </summary>
        </member>
        <member name="P:VRage.Engine.VRageCore.Update">
            <summary>
            Get the system, responsible for the engine update loop.
            </summary>
        </member>
        <member name="P:VRage.Engine.VRageCore.UnprocessedArguments">
            <summary>
            Array containing any command line arguments that were not consumed during initialization.
            </summary>
        </member>
        <member name="P:VRage.Engine.VRageCore.Assemblies">
            <summary>
            Assemblies that are loaded by this engine core.
            </summary>
        </member>
        <member name="P:VRage.Engine.VRageCore.Package">
            <summary>
            Application package defining this engine core instance.
            </summary>
        </member>
        <member name="M:VRage.Engine.VRageCore.GetSystem``1">
            <summary>
            Get a system based on it's type.
            
            This method will cache the results, so it can be considered fast even though a single lookup is a linear search.
            </summary>
            <typeparam name="TSystem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VRage.Engine.VRageCore.GetSystem(System.Type)">
             <summary>
             Get a system based on it's type.
             </summary>
             <remarks>
             <para>This method performs a linear search through the loaded systems and finds the first instance that is assignable to the queried type.</para>
            
             <para>If multiple systems are valid results the one that is returned depends on the internal ordering of the systems list, and which specific system is returned can change between different versions of the program.</para>
             
             <para>This method will cache the results, so it's performance should be considered constant on average.</para>
             </remarks>
             <returns>The first system matching the queried type.</returns>
        </member>
        <member name="M:VRage.Engine.VRageCore.VRage#Components#IComponentContainer#Get(System.Type)">
            <inheritdoc/>
        </member>
        <member name="P:VRage.Engine.VRageCore.VRage#Components#IComponentContainer#Logger">
            <inheritdoc />
        </member>
        <member name="M:VRage.Engine.VRageCore.#ctor(VRage.Engine.AppInformation,System.Boolean)">
            <summary>
            Instantiate a new VRage Engine core instance.
            </summary>
            <param name="info">Information about this application.</param>
            <param name="setInstance">Whether to set the global <see cref="P:VRage.Engine.VRageCore.Instance"/> reference to point to this newly created instance.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.Init(VRage.Engine.CoreConfiguration)">
            <summary>
            Initialize this core instance with the provided parameters.
            </summary>
            <param name="configuration">Arguments for core initialization.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.Init(VRage.Engine.CoreConfiguration,System.String[]@)">
            <summary>
            Initialize this core instance with the provided parameters and command line arguments.
            </summary>
            <param name="configuration">Arguments for core initialization.</param>
            <param name="commandLineArgs">Command line args array, consumed arguments will be removed from it.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.Exit(System.Int32)">
            <summary>
            Shorthand to exit the main loop.
            </summary>
            <param name="returnCode">The return code provided to the caller or OS.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.Start">
            <summary>
            Invoke the start event on all systems
            </summary>
        </member>
        <member name="M:VRage.Engine.VRageCore.LoadMetadata(VRage.Engine.CoreConfiguration)">
            <summary>
            Load type metadata for all assemblies referenced in the config.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:VRage.Engine.VRageCore.LoadSystem(VRage.Engine.SystemDescriptor,System.Boolean)">
            <summary>
            Load a single system.
            </summary>
            <param name="systemDesc">Descriptor of the system to load.</param>
            <param name="critical">Whether the system is critical.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Engine.VRageCore.LoadBootstrapper(VRage.Engine.SystemDescriptor,VRage.Engine.CoreConfiguration,System.String[]@)">
            <summary>
            L:oad the bootstrapping system.
            </summary>
            <param name="bootstrapper"></param>
            <param name="configuration"></param>
            <param name="cliArgs"></param>
        </member>
        <member name="M:VRage.Engine.VRageCore.InitSystems(System.Collections.Generic.Dictionary{System.Type,System.Object},System.Boolean)">
             <summary>
             Initialize all systems.
             </summary>
             <remarks>
             There are two different steps in which systems are initialized:
             <ul>
             <li><b>Init Before Metadata:</b> For systems that implement the <see cref="T:VRage.Engine.IInitBeforeMetadata"/> interface. These systems have their <c>Init</c> methods called at this point.</li>
             <li><b>Init After Metadata:</b> A.k.a. the regular <c>init</c>. Systems not implementing the aforementioned interface are initialized here. Any systems initialized in the previous step now have their <see cref="M:VRage.Engine.IInitBeforeMetadata.AfterMetadataInitialized"/> methods invoked instead.</li>
             </ul>
            
             Which step the current invocation is on is indicated by the <paramref name="beforeMetadata"/> parameter.
             </remarks>
             <param name="paramMap">Dictionary containing per system parameters objects.</param>
             <param name="beforeMetadata">Whether the current initialization step is the 'before metadata' initialization step.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.TryInitSystems(System.Collections.Generic.Dictionary{System.Type,System.Object},System.Boolean)">
            <summary>
            Attempt to init all systems, throws exception if initialization fails.
            </summary>
            <param name="paramMap"></param>
            /// <param name="beforeMetadata">Whether the current initialization step is the 'before metadata' initialization step.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.ProcessCommandLineBeforeSystems(System.String[]@,VRage.Engine.CoreConfiguration)">
            <summary>
            Process any command line options that affect the engine configuration.
            </summary>
            <param name="args">Application arguments.</param>
            <param name="config">Engine configuration.</param>
        </member>
        <member name="M:VRage.Engine.VRageCore.HandleCommandLine(System.String[]@)">
            <summary>
            Handle command line arguments.
            </summary>
            <param name="commandLineArgs"></param>
        </member>
        <member name="M:VRage.Engine.VRageCoreExtensions.InitAndRun(VRage.Engine.VRageCore,VRage.Engine.CoreConfiguration)">
            <summary>
            Initialize a vrage core instance and start running the update loop.
            
            This method only returns when the update loop finishes, and then calls shutdown on core.
            </summary>
            <param name="core">The already existing VRageCore instance.</param>
            <param name="configuration">Initialization parameters.</param>
            <returns>The exit code from the update loop.</returns>
        </member>
        <member name="M:VRage.Engine.VRageCoreExtensions.InitAndRun(VRage.Engine.VRageCore,VRage.Engine.CoreConfiguration,System.String[]@)">
            <summary>
            Initialize a vrage core instance and start running the update loop.
            
            This method only returns when the update loop finishes, and then calls shutdown on core.
            </summary>
            <param name="core">The already existing VRageCore instance.</param>
            <param name="configuration">Initialization parameters.</param>
            <param name="commandLineArgs">Command line arguments available to the program.</param>
            <returns>The exit code from the update loop.</returns>
        </member>
        <member name="T:VRage.Engine.XmlCoreConfiguration">
            <summary>
            Xml serializable representation of the core params.
            </summary>
        </member>
        <member name="M:VRage.Engine.XmlCoreConfiguration.GetSchema">
            <summary>
            Schema:
            <code><![CDATA[
            <Root>
                <Reference>name</Reference>*
                <Bootstrapper Path="Qualified.System.Name">system args</Bootstrapper> <!-- only once -->
                <System Path="Qualified.System.Name">system args</System>*
                <Include>path/to/extra/config.config</Include>*
            </Root>
            ]]></code>
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.Engine.XmlCoreConfiguration.SystemEntry">
            <summary>
            Handles specification of systems and their parameters.
            </summary>
        </member>
        <member name="M:VRage.Engine.XmlCoreConfiguration.op_Implicit(VRage.Engine.XmlCoreConfiguration)~VRage.Engine.CoreConfiguration">
            <summary>
            Convert this XML core parameters instance into a regular (runtime) core parameters object
            </summary>
            <param name="serialized"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.GameServices.MyGameService">
            <summary>
            Game Service helper class
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.ModId">
            <summary>
            A short string to uniquely identify the mod.
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.WorkshopId">
            <summary>
            An id assigned by the game service when the mod is published.
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.ModVersion">
            <summary>
            Version of the mod
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.MinGameVersion">
            <summary>
            Minimum supported version of the game
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.MaxGameVersion">
            <summary>
            Maximum supported version of the game
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.Tags">
            <summary>
            List of selected tags.
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyModMetadata.Dependencies">
            <summary>
            List of selected tags.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItemPublisher.Publish(System.String)">
            <summary>
            Publish the item to workshop.
            If 'id' is filled in, it will try to update the existing item.
            If no 'id is filled in, it will create a new item instead.
            </summary>
            <param name="changeNotes">User written message what changed. Can be empty.</param>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopItem.IsFavorite">
            <summary>
            Is the workshop item in the local user's favorites list?
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopItem.IsSubscribed">
            <summary>
            Is the local user subscribed to this workshop item?
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopItem.Compatibility">
            <summary>
            Whether this mod is compatible with the current game version.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.GetPublisher">
            <summary>
            Returns a publisher instance that is initialized with properties of this workshop item.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.Download">
            <summary>
            Download the newest version of this workshop item.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.UpdateState">
            <summary>
            Updates the workshop item with available information.
            First tries local storage.
            Then tries remote.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.Subscribe">
            <summary>
            Subscribes to the workshop item.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.Unsubscribe">
            <summary>
            Unsubscribes from the workshop item.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.AddToFavorites">
            <summary>
            Adds the workshop item to favorites.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.RemoveFromFavorites">
            <summary>
            Removes the workshop item from favorites.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopItem.IsUpToDate">
            <summary>
            Checks whether the mod is up-to-date.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.GameServices.WorkshopItemType">
            <summary>
            Types of workshop items.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopItemType.All">
            <summary>
            All type of supported items.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopItemType.Mod">
            <summary>
            Came content item.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopItemType.Collection">
            <summary>
            Collection of workshop items.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopItemType.Guide">
            <summary>
            Developer or user provided guide for the game.
            </summary>
        </member>
        <member name="T:VRage.GameServices.WorkshopListType">
            <summary>
            Represents a type of item list to be queried.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopListType.Subscribed">
            <summary>
            Default list type, used of item content the user wants to have.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopListType.Favourited">
            <summary>
            Items the user wants to remember about.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopListType.None">
            <summary>
            All items.
            </summary>
        </member>
        <member name="F:VRage.GameServices.WorkshopListType.Published">
            <summary>
            Items the user has published.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.Items">
            <summary>
            Returned workshop items.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.TotalResults">
            <summary>
            Total results returned.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.ItemsPerPage">
            <summary>
            How many items can be queried per page.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.IsRunning">
            <summary>
            Whether or not the query is currently running.
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyWorkshopQuery.ItemType">
            <summary>
            Type of item to query.
            </summary>
        </member>
        <member name="F:VRage.GameServices.MyWorkshopQuery.ListType">
            <summary>
            Type of item list to query from.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.RequiredTags">
            <summary>
            Tags to match
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.RequireAllTags">
            <summary>
            Do all required tags needs to be present, or just any?
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.ExcludedTags">
            <summary>
            Don't match if any of these tags are included
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.UserId">
            <summary>
            Search only items subscribed by the user specified.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.ItemIds">
            <summary>
            Query only item ids specified here.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.ReturnOnlyIDs">
            <summary>
            Set if the query should only return item IDs, rather than all details.
            Useful for getting lists of favorites, etc.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.CacheExpirationTime">
            <summary>
            Set if the query should use cache, and if so, for how long the cache is considered valid.
            </summary>
        </member>
        <member name="P:VRage.GameServices.MyWorkshopQuery.ReturnLongDescription">
            <summary>
            Set the query to return full descriptions.
            </summary>
        </member>
        <member name="M:VRage.GameServices.MyWorkshopQuery.Run">
            <summary>
            Runs the query with specified parameters.
            Does nothing if the query is already running.
            </summary>
        </member>
        <member name="T:VRage.Generics.IMyCondition">
            <summary>
            Interface of totally generic condition.
            </summary>
        </member>
        <member name="M:VRage.Generics.IMyCondition.Evaluate">
            <summary>
            Evaluate the condition, it can be true/false.
            </summary>
        </member>
        <member name="T:VRage.Generics.IMyVariableStorage`1">
            <summary>
            Interface of variable storage (key-value principle).
            </summary>
        </member>
        <member name="T:VRage.Generics.MyCachingDynamicObjectsPool`2">
            This class provides similar functionality to MyDynamicObjectsPool with the addition of caching facilities.
            
            The cache is intended to be used for objects that once allocated either perform expensive computations
            or allocate a lot of memory *and* that may be needed again after disposed in the same state.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.Deallocate(`1)">
            Deallocate object without key.
            
            Object is disposed be callee.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.Deallocate(`0,`1)">
            Deallocate object with key.
            
            Object is cached and disposed if necessary.
        </member>
        <member name="M:VRage.Generics.MyCachingDynamicObjectsPool`2.TryAllocateCached(`0,`1@)">
            Allocate an object that may be cached.
            
            Returns true if the object was found in the cache and false otherwise.
        </member>
        <member name="T:VRage.Generics.MyStateMachine">
            <summary>
            Implementation of generic state machine. Inherit from this class to create your own state machine.
            Transitions are performed automatically on each update (if conditions of transition are fulfilled).
            </summary>
        </member>
        <member name="M:VRage.Generics.MyStateMachine.SetState(System.String)">
            <summary>
            Set the current state. Warning - this is not a thing that you would like to normally do, 
            state machine should live its own life (based on transition condition).
            Returns true on success.
            </summary>
        </member>
        <member name="M:VRage.Generics.MyStateMachine.TriggerAction(VRage.Utils.MyStringId)">
            <summary>
            Trigger an action in this layer. 
            If there is a transition having given (non-null) name, it is followed immediatelly.
            Conditions of transition are ignored.
            </summary>
        </member>
        <member name="M:VRage.Generics.MyStateMachine.SortTransitions">
            <summary>
            Sort the transitions between states according to their priorities.
            </summary>
        </member>
        <member name="T:VRage.Generics.StateMachine.MyCondition`1">
            <summary>
            Implementation of generic condition. Immutable class, once set, its parameters cant be changed.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineNode">
            <summary>
            Node of the state machine.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineTransition">
            <summary>
            Definition of transition to some node.
            </summary>
        </member>
        <member name="T:VRage.Generics.MyStateMachineTransitionWithStart">
            <summary>
            Pair holding transition and its starting node.
            </summary>
        </member>
        <member name="M:VRage.Generics.MyStateMachineTransitionWithStart.#ctor(VRage.Generics.MyStateMachineNode,VRage.Generics.MyStateMachineTransition)">
            <summary>
            Full constructor.
            </summary>
        </member>
        <member name="M:VRage.Generics.MySparseGrid`2.ClearCells">
            <summary>
            Clears cells, but keep them preallocated
            </summary>
        </member>
        <member name="T:VRage.Generics.MyDynamicObjectPool`1">
            <summary>
            Dynamic object pool. It allocates a new instance when necessary.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Generics.MyDynamicObjectPool`1.SuppressFinalize">
            <summary>
            Suppress finalization of all items buffered in the pool.
            
            This should only be called if the elements of the pool have some form of leak detecting finalizer.
            </summary>
        </member>
        <member name="M:VRage.Generics.MyObjectsPool`1.AllocateOrCreate(`0@)">
            <summary>
            Returns true when new item was allocated
            </summary>
        </member>
        <member name="M:VRage.Generics.MyRuntimeObjectsPool`1.AllocateOrCreate(`0@)">
            <summary>
            Returns true when new item was allocated
            </summary>
        </member>
        <member name="T:VRage.Generics.MyWeightDictionary`1">
            <summary>
            Contains items of any type. Each item has weight (float value).
            Allows to get item based on weight.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.#ctor(System.Collections.Generic.Dictionary{`0,System.Single})">
            <summary>
            Initializes a new instance of the MyWeightDictionary class.
            </summary>
            <param name="data">Dictionary with items and weights.</param>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetSum">
            <summary>
            Gets sum of weights.
            </summary>
            <returns>The sum of all weights.</returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetItemByWeightNormalized(System.Single)">
            <summary>
            Gets item based on weight.
            </summary>
            <param name="weightNormalized">Weight, value from 0 to 1.</param>
            <returns>The item.</returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetItemByWeight(System.Single)">
            <summary>
            Gets item based on weight.
            </summary>
            <param name="weight">Weight, value from 0 to sum.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Generics.MyWeightDictionary`1.GetRandomItem(System.Random)">
            <summary>
            Gets random item based on weight.
            </summary>
            <returns>The item.</returns>
        </member>
        <member name="T:VRage.Meta.MetadataIndexerExtensions">
            <summary>
            Extension methods for all metadata indexers.
            </summary>
        </member>
        <member name="M:VRage.Meta.MetadataIndexerExtensions.GetLogger(VRage.Meta.IMyMetadataIndexer,System.Reflection.MemberInfo)">
            <summary>
            Get the logger instance associated with this metadata indexer.
            </summary>
            <param name="self"></param>
            <param name="provokingElement">Reflection object that triggered the message.</param>
            <returns></returns>
        </member>
        <member name="T:VRage.Meta.IMyAttributeIndexer">
            <summary>
            Indexer for metadata related to types that are annotated with a specific attribute.
            </summary>
        </member>
        <member name="M:VRage.Meta.IMyAttributeIndexer.Observe(System.Attribute,System.Type)">
            <summary>
            Observe the given type which is annotated with a relevant attribute.
            </summary>
            <param name="attribute">Instance of the attribute that maps to this indexer.</param>
            <param name="type">Annotated type.</param>
        </member>
        <member name="T:VRage.Meta.IMyKeyAttribute`1">
            <summary>
            Interface used by the attribute indexer base.
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:VRage.Meta.IMyMetadataIndexer">
            <summary>
            Base interface for objects that handle metadata indexing in the metadata system.
            </summary>
        </member>
        <member name="M:VRage.Meta.IMyMetadataIndexer.SetParent(VRage.Meta.IMyMetadataIndexer)">
            <summary>
            Set the parent indexer, the parent indexer will always be an instance of the same type.
            </summary>
            <remarks>
            For the majority of indexer types the metadata for the parent can be used directly.
            Still some might need to flatten the whole information hierarchy on a per indexer basis.
            </remarks>
            <param name="indexer">The parent indexer.</param>
        </member>
        <member name="M:VRage.Meta.IMyMetadataIndexer.Activate">
            <summary>
            Called when the context that contains this indexer becomes the active one.
            
            Any global references to this indexer need to be update then.
            </summary>
        </member>
        <member name="M:VRage.Meta.IMyMetadataIndexer.Close">
            <summary>
            Called when the context that contains this indexer is disposed.
            
            All references to this indexer must be invalidated and all held data released.
            </summary>
        </member>
        <member name="M:VRage.Meta.IMyMetadataIndexer.Process">
            <summary>
            Invoked when a batch of assemblies are loaded and indexers are then given a chance to build any additional structures over the data.
            
            This is useful for indexers where there are nontrivial relations between the types that need to be rebuild every time new types are added.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyAttributeIndexerBase`2">
            <summary>
            Base class for a sample implementation of an attribute observer.
            
            Sufficient for most usages.
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="F:VRage.Meta.MyAttributeIndexerBase`2.Static">
            <summary>
            Static reference to the topmost indexer.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyAttributeMetadataIndexerAttribute">
            <summary>
            Simple identification of a metadata indexer class.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyAttributeMetadataIndexerAttributeBase">
            <summary>
            Base class for attributes that provide information about type indexers.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyAttributeMetadataIndexerAttributeBase.AttributeType">
            <summary>
            The type of the attribute that is indexed.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyAttributeMetadataIndexerAttributeBase.TargetType">
            <summary>
            The type of the indexer.
            
            When this is null the type is inferred from the annotated type.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyMetadataContext">
            <summary>
            Base class for a metadata context.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.m_attributeIndexerTypes">
            <summary>
            Mapping of attribute indexer types.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.m_typeIndexerTypes">
            <summary>
            List of type indexer types.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.m_passiveIndexerTypes">
            <summary>
            List of simple indexer types.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.PassiveIndexerTypes">
            <summary>
            Get all type indexer types known by this context and it's parents.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.TypeIndexerTypes">
            <summary>
            Get all type indexer types known by this context and it's parents.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.AttributeIndexerTypes">
            <summary>
            Get all type indexer types known by this context and it's parents.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.Parent">
            <summary>
            Parent metadata context.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.Log">
            <summary>
            Log used to report errors and info about the metadata system.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataContext.Assemblies">
            <summary>
            Set of know assemblies.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.RegisterIndexers">
            <summary>
            Whether this context should look for indexers while exploring the assembly.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.Activate">
            <summary>
            Invoked when this context becomes the top of the stack.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.Close">
            <summary>
            Invoked when this context is popped and it's data must be disposed.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.PackageMapping">
            <summary>
            Mapping of loaded assemblies to the application packages that provide them.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.KnownAssemblies">
            <summary>
            Set of assemblies known to this context.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.GetPackage(System.Reflection.Assembly)">
            <summary>
            Get the package that provided <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The queried assembly.</param>
            <returns>The package that provides the assembly if any, otherwise <c>null</c>.</returns>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.IndexersByType">
             <summary>
             Indexers per indexer type.
            
             Each context keeps only a single indexer per type.
             </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.AttributeIndexers">
            <summary>
            Indexers per attribute.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.TypeIndexers">
            <summary>
            Type indexers (indexers that process all types).
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.Index(System.Reflection.Assembly,System.Boolean,VRage.Engine.IApplicationPackage)">
            <summary>
            Index the given assembly.
            </summary>
            <param name="assembly">The assembly to index.</param>
            <param name="batch">Whether to process this addition as a part of a batch.</param>
            <param name="package"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.FinishBatch">
             <summary>
             Finish batch indexing of assemblies.
            
             Batching is recommended when many assemblies are indexed at once.
             It significantly improves the performance of indexers that need to post-process the full set of types.
             </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.RegisterAttributeIndexer(System.Type,System.Type)">
            <summary>
            Register an indexer for a given attribute type.
            
            The provide indexer will be registered to all current and future metadata contexts.
            </summary>
            <param name="attributeType"></param>
            <param name="indexerType"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.RegisterTypeIndexer(System.Type)">
            <summary>
            Register a type indexer.
            
            The provide indexer will be registered to all current and future metadata contexts.
            </summary>
            <param name="indexerType"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.RegisterPassiveIndexer(System.Type)">
            <summary>
            Register a simple indexer.
            
            The provide indexer will be registered to all current and future metadata contexts.
            </summary>
            <param name="type">The type of the indexer.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.TryGetIndexer(System.Type,VRage.Meta.IMyMetadataIndexer@)">
            <summary>
            Tries to get indexer for the given type.
            </summary>
            <param name="type">The type of the indexer.</param>
            <param name="indexer">The indexer instance if any.</param>
            <returns>Whether an indexer was found.</returns>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddAttributeIndexers(System.Collections.Generic.IEnumerable{VRage.MyTuple{System.Type,System.Type}})">
            <summary>
            Add several attribute indexers.
            </summary>
            <param name="indexerTypes">collection of attribute to indexer type mappings</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddTypeIndexers(System.Collections.Generic.IEnumerable{System.Type})">
             <summary>
             Add several type indexers.
            
             This may throw exception if one of the provided types is not valid.
             </summary>
             <param name="typeIndexers"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddSimpleIndexers(System.Collections.Generic.IEnumerable{System.Type})">
             <summary>
             Add several type indexers.
            
             This may throw exception if one of the provided types is not valid.
             </summary>
             <param name="typeIndexers"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddAttributeIndexer(System.Type,System.Type)">
            <summary>
            Add a single indexer for the provided attribute type.
            </summary>
            <param name="attributeType">The type of the attribute to index.</param>
            <param name="indexerType">The type of the indexer to create.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddTypeIndexer(System.Type)">
             <summary>
             Add a type indexer.
            
             This may throw exception if the provided type is not valid.
             </summary>
             <param name="typeIndexer"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.AddPassiveIndexer(System.Type)">
             <summary>
             Add a simple indexer.
            
             This may throw exception if the provided type is not valid.
             </summary>
             <param name="typeIndexer"></param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.GetOrCreateMetaIndexer(System.Type)">
            <summary>
            Get or create a metadata indexer of a given type.
            </summary>
            <param name="indexerType"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.PushTop(VRage.Meta.MyMetadataContext)">
            <summary>
            Hook indexers from parent to child.
            </summary>
            <param name="parent">Parent metadata context.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.PreProcess(System.Reflection.Assembly)">
             <summary>
             Pre-process an assembly.
            
             This will discover indexers and run any static constructors that are needed.
             </summary>
             <param name="assembly"></param>
        </member>
        <member name="T:VRage.Meta.MyMetadataContext.IndexerKind">
            <summary>
            Indexer types.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.IndexerKind.PassiveIndexer">
            <summary>
            An indexer that is iun the system but does not index any data on it's own.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.IndexerKind.TypeIndexer">
            <summary>
            An indexer tht scans types.
            </summary>
        </member>
        <member name="F:VRage.Meta.MyMetadataContext.IndexerKind.AttributeIndexer">
            <summary>
            An indexer that scans type attributes.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataContext.ShouldAddIndexer(System.Type,VRage.Meta.MyMetadataContext.IndexerKind,VRage.Meta.MyMetadataIndexerAttribute)">
            <summary>
            Filter method used to identify which indexers should be added automatically (when RegisterIndexers is true).
            </summary>
            <param name="indexerType">The type of the indexer class.</param>
            <param name="kind">The kind this indexer seeks to be registered as.</param>
            <param name="attribute">The attribute indicating that the provided indexer type should be added.</param>
            <returns></returns>
        </member>
        <member name="T:VRage.Meta.MyMetadataIndexerAttribute">
            <summary>
            Base class for metadata indexer attributes.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyPassiveMetadataIndexerAttribute">
            <summary>
            Attribute indicating a simple metadata indexer.
            
            This can be used for indexer that need to be handled along with the system, but do not do any active indexing on their own.
            </summary>
        </member>
        <member name="T:VRage.Meta.IMyTypeIndexer">
             <summary>
             Interface that specifies objects which index types based on non trivial properties they might have.
            
             This may include having a specific parent class or implementing some interface.
             These properties are not trivial to compute (computing them for a single indexer
             does not help determining if they are meaningful for another indexer).
             Which means they must be computed for all inspected types.
             </summary>
        </member>
        <member name="M:VRage.Meta.IMyTypeIndexer.Observe(System.Type)">
            <summary>
            Observe a type.
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:VRage.Meta.MyTypeMetadataIndexerAttribute">
            <summary>
            Attribute indicating a type metadata indexer.
            
            Valid type indexers marked with this attribute are automatically discovered and used.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyMetadataSystem">
            <summary>
            The metadata system is responsible for indexing types and information about those types.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.LoadAssembly(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Load metadata from an assembly, if the assembly has already been indexed it will be ignored.
            </summary>
            <param name="assembly">Assembly to index.</param>
            <param name="batch">Whether to treat this load as part of a batch.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.LoadAssemblies(System.Reflection.Assembly[])">
            <summary>
            Load metadata from an assembly, if the assembly has already been indexed it will be ignored.
            </summary>
            <param name="assemblies">Assemblies to index.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.LoadAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Load metadata from an assembly, if the assembly has already been indexed it will be ignored.
            </summary>
            <param name="assemblies">Assemblies to index.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.LoadAssemblies(VRage.Engine.IApplicationPackage,System.Boolean)">
            <summary>
            Load metadata from all assemblies in the 
            </summary>
            <param name="package">Assembly to index.</param>
            <param name="batch">Whether to treat this load as part of a batch.</param>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.FinishBatch">
            <summary>
            Finish batch indexing of assemblies.
            
            Batching is recommended when many assemblies are indexed at once.
            It significantly improves the performance of indexers that need to post-process the full set of types.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.GetPackage(System.Reflection.Assembly)">
            <summary>
            Get the application package that defines the target assembly if any.
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.GetType(System.String,System.Boolean)">
            <summary>
            Find a type amongst known assemblies.
            </summary>
            <param name="fullName">The full name of the type (i.e.: namespace + name).</param>
            <param name="throwOnError">Whether to throw exception or to return null if the type cannot be found.</param>
            <returns>The fount type or null.</returns>
        </member>
        <member name="F:VRage.Meta.MyMetadataSystem.Stack">
            <summary>
            Metadata context stack.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataSystem.ActiveContext">
            <summary>
            Active metadata context.
            
            If there is no context set this will be null.
            </summary>
        </member>
        <member name="P:VRage.Meta.MyMetadataSystem.Log">
            <summary>
            Metadata log.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.PushMetadataContext(VRage.Meta.MyMetadataContext)">
            <summary>
            Push the provided metadata context to the top of the metadata text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.PushMetadataContext">
            <summary>
            Create a new metadata context and set push it atop the metadata stack.
            </summary>
            <returns>The newly created context.</returns>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.PopContext">
            <summary>
            Pop the current metadata context, this will cause the context to be disposed.
            
            This should update all global indexer references to the new context on the top of the stack.
            </summary>
        </member>
        <member name="M:VRage.Meta.MyMetadataSystem.TryGetIndexer``1(``0@)">
            <summary>
            Try to get an indexer based on it's type.
            </summary>
            <typeparam name="TIndexer">The type of the indexer.</typeparam>
            <param name="indexer">The indexer instance if found.</param>
            <returns>Whether an indexer of the requested type is registered.</returns>
        </member>
        <member name="T:VRage.Meta.MyMetadataSystem.ContextualLogger">
            <summary>
            Filter that introduces extra context around metadata messages.
            </summary>
        </member>
        <member name="T:VRage.Meta.MyMetadataSystem.LogMessage">
            <summary>
            Format for messages the metadata system writes to the log.
            </summary>
        </member>
        <member name="M:VRage.MyCompilationSymbols.IsProfilerAttached">
            <summary>
            This is reliable, enforced by .NET documentation.
            Without this environment variable, CLR won't attach profiler.
            </summary>
        </member>
        <member name="T:VRage.MyDeltaTransform">
            <summary>
            Transform structure for delta-transforms.
            </summary>
        </member>
        <member name="T:VRage.MySimpleProfiler">
            <summary>
            A simple performance profiler intended to show players information about which area of the game is slowing it down
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.Init">
            <summary>
            Special settings for profiling blocks should be set here
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.Begin(System.String)">
            <summary>
            Begin new profiling block
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.End(System.String)">
            <summary>
            End profiling block
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.BeginGPUBlock(System.String)">
            <summary>
            Set which GPU profiling block is going to receive timing next
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.EndGPUBlock(VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Log timing of currently set GPU block
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.Commit">
            <summary>
            Check performance and reset time
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.SetBlockSettings(System.String,System.Int32,System.Int32,System.Boolean,VRage.MySimpleProfiler.MySimpleProfilingBlock.ProfilingBlockType)">
            <summary>
            Set special settings for a profiling block
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.CheckPerformance">
            <summary>
            Checks performance of each profiling block and sends notifications if above threshold
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.ShowServerPerformanceWarning(System.String)">
            <summary>
            Show performance warning received from server
            </summary>
        </member>
        <member name="M:VRage.MySimpleProfiler.FindWorstPerformanceBlock">
            <summary>
            Unused, but returns the area which is the most above threshold, null if none is
            </summary>
        </member>
        <member name="P:VRage.Network.MyMultiplayer.IsServer">
            <summary>
            Whether the local session is a server or not.
            </summary>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent(System.Func{VRage.Network.IMyEventOwner,System.Action},VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction);
            </summary>
            <param name="action"></param>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``1(System.Func{VRage.Network.IMyEventOwner,System.Action{``0}},``0,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg);
            </summary>
            <param name="arg2"></param>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
            <param name="action"></param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``2(System.Func{VRage.Network.IMyEventOwner,System.Action{``0,``1}},``0,``1,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg2, arg3);
            </summary>
            <param name="arg3"></param>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
            <param name="action"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``3(System.Func{VRage.Network.IMyEventOwner,System.Action{``0,``1,``2}},``0,``1,``2,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg2, arg3, arg4);
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``4(System.Func{VRage.Network.IMyEventOwner,System.Action{``0,``1,``2,``3}},``0,``1,``2,``3,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg2, arg3, arg4, arg5);
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``5(System.Func{VRage.Network.IMyEventOwner,System.Action{``0,``1,``2,``3,``4}},``0,``1,``2,``3,``4,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg2, arg3, arg4, arg5, arg6);
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseStaticEvent``6(System.Func{VRage.Network.IMyEventOwner,System.Action{``0,``1,``2,``3,``4,``5}},``0,``1,``2,``3,``4,``5,VRage.Network.EndpointId)">
            <summary>
            Raises static multiplayer event.
            Usage: MyMultiplayer.RaiseStaticEvent(s => MyClass.MyStaticFunction, arg2, arg3, arg4, arg5, arg6);
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``1(``0,System.Func{``0,System.Action},VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``2(``0,``1,System.Func{``0,System.Action},VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``2(``0,System.Func{``0,System.Action{``1}},``1,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``3(``0,``2,System.Func{``0,System.Action{``1}},``1,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``3(``0,System.Func{``0,System.Action{``1,``2}},``1,``2,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``4(``0,``3,System.Func{``0,System.Action{``1,``2}},``1,``2,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``4(``0,System.Func{``0,System.Action{``1,``2,``3}},``1,``2,``3,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``5(``0,``4,System.Func{``0,System.Action{``1,``2,``3}},``1,``2,``3,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``5(``0,System.Func{``0,System.Action{``1,``2,``3,``4}},``1,``2,``3,``4,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``6(``0,``5,System.Func{``0,System.Action{``1,``2,``3,``4}},``1,``2,``3,``4,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``6(``0,System.Func{``0,System.Action{``1,``2,``3,``4,``5}},``1,``2,``3,``4,``5,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseBlockingEvent``7(``0,``6,System.Func{``0,System.Action{``1,``2,``3,``4,``5}},``1,``2,``3,``4,``5,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``7(``0,System.Func{``0,System.Action{``1,``2,``3,``4,``5,``6}},``1,``2,``3,``4,``5,``6,VRage.Network.EndpointId)">
            <summary>
            Raises multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.RaiseEvent``8(``0,``7,System.Func{``0,System.Action{``1,``2,``3,``4,``5,``6}},``1,``2,``3,``4,``5,``6,VRage.Network.EndpointId)">
            <summary>
            Raises blocking multiplayer event.
            </summary>
            <param name="targetEndpoint">Target of the event. When broadcasting, it's exclude endpoint.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.ReplicateImmediately(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            This is hack for immediate replication, it's necessary because of logic dependency.
            E.g. Character is created on server, sent to client and respawn message sent immediatelly.
            Should be called only on server.
            </summary>
            <param name="replicable">Replicable to replicate to clients</param>
            <param name="dependency">Replicable will be replicated only to clients who has dependency.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.ReplicateImmediately(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            This is hack for immediate replication, it's necessary because of logic dependency.
            E.g. Character is created on server, sent to client and respawn message sent immediately.
            Should be called only on server.
            </summary>
            <param name="replicable">Replicable to replicate.</param>
            <param name="clientEndpoint">Client who will receive the replicable immediately.</param>
        </member>
        <member name="M:VRage.Network.MyMultiplayer.GetMultiplayerStatsLocal">
            <summary>
            Gets multiplayer statistics in formatted string. Use only for Debugging.
            </summary>
            <returns>Formatted multiplayer statistics.</returns>
        </member>
        <member name="P:VRage.Network.MyMultiplayerBase.ReplicationLog">
            <summary>
            Log used to record information about the replication layer.
            </summary>
        </member>
        <member name="T:VRage.Network.BlockingAttribute">
            <summary>
            Indicates that event will be blocking all other events.
            </summary>
        </member>
        <member name="M:VRage.Network.BlockingAttribute.#ctor">
            <summary>
            Creates attribute that indicates that event will be blocking all other events until this is resolved.
            </summary>
        </member>
        <member name="T:VRage.Network.BroadcastExceptAttribute">
            <summary>
            <para>This decorates a method to be called by the server on all clients.</para>
            <para>&#160;</para>
            <para>If the server is not a dedicated server it is also considered a client.</para>
            <para>So, if endpoint is not specified, this message is not sent to the sender.</para>
            <para>However, if endpoint is specified, this message is sent to every client (possibly including the server) except for the one specified in the endpoint.</para>
            <para>&#160;</para>
            <para>Clients should always trust the server and shouldn't perform any validation.</para>
            <para>When used together with the Server attribute, server validates data, invokes the method on server and then sends it to all clients except the client who invoked it on server.</para>
            </summary>
        </member>
        <member name="T:VRage.Network.BroadcastAttribute">
            <summary>
            Client method. Decorated method is be called by server on all clients.
            Clients always trust server and does not perform any validation.
            When used together with Server attribute, server (optionally) validates data, invokes the method on server and then sends it to all clients.
            If the data is found invalid, it can be marked so by calling MyEventContext.ValidationFailed() on the server. The broadcasts will then not be performed.
            </summary>
        </member>
        <member name="T:VRage.Network.CallSiteCreator">
            <summary>
            Manager and scheduler of asynchronous call site generation.
            </summary>
        </member>
        <member name="F:VRage.Network.CallSiteCreator.CreateCallSiteMethod">
            <summary>
            Generic create call site method.
            </summary>
        </member>
        <member name="F:VRage.Network.CallSiteCreator.CallSiteCreators">
            <summary>
            Cached creator delegates for each call site creation method.
            </summary>
            <remarks>
            We expect a low hit-rate for this cache, but it should use little memory.
            </remarks>
        </member>
        <member name="M:VRage.Network.CallSiteCreator.GetCreator(System.Type[])">
            <summary>
            Get a call site creator delegate from it's generic argument types.
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Network.ClientAttribute">
            <summary>
            Client method. Decorated method is be called by server on client.
            Clients always trust server and does not perform any validation.
            When used together with Server attribute, server validates data, invokes the method on server and then sends it to client who invoked it on server.
            </summary>
        </member>
        <member name="T:VRage.Network.EndpointId">
            <summary>
            Id of network endpoint, opaque struct, internal value should not be accessed outside VRage.Network.
            EndpointId is not guid and can change when client reconnects to server.
            Internally it's SteamId or RakNetGUID.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyChildStateGroup">
             <summary>
             Interface describing a state group that can work as a child of another group.
            
             Children should always return a null time schedule, as they are synchronized by their parent.
             </summary>
        </member>
        <member name="M:VRage.Network.IMyChildStateGroup.GetChildSyncTimeSchedule(VRage.Network.IMyStateGroup,VRage.Network.MyClientInfo,System.Boolean)">
            <summary>
              This function provides relative time of next sync from server to clients.
              It can be understood as a soft time limit for next sync.
            </summary>
            <remarks>
             This overload should return a valid value, and is used by the parent to decide it's own schedule.
            </remarks>
            <param name="parent">The parent state group.</param>
            <param name="forClient">
            The client who will receive that state synchronization.
            </param>
            <param name="firstTime">
            Indicates that the group is going to be scheduled for the first time.
            Change the scheduling time accordingly to get quicker response.  
            </param>
            <returns>
              Returns scheduling time in frames, the value is relative to current time. 
              If function returns null, state group does not require synchronization 
              and can be put to sleep.
              Valid value range: [null, 0+]. 
            </returns>
        </member>
        <member name="M:VRage.Network.IMyChildStateGroup.OnAddedToParent(VRage.Network.IMyStateGroup)">
            <summary>
            Invoked by the parent state group as this object becomes it's child.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:VRage.Network.IMyChildStateGroup.OnRemovedFromParent">
            <summary>
            Invoked when this object is no longer a child.
            </summary>
        </member>
        <member name="T:VRage.Network.MyReplicationServer.MyReplicableDestroyBlocker">
            <summary>
            Class containing necessary information for blocking of replicable destruction in case that the replication already started.
            Once the server receives that the replicable is ready and is not blocked, the replicable can be destroyed.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.MyReplicableBlockedGroup.MergeFrom(VRage.Network.MyReplicationServer.MyReplicableBlockedGroup)">
            <summary>
            Merge items from another group of blocked replicables.
            </summary>
            <param name="mergeFrom">reference to another group to merge from</param>
            <returns>return true on successful merge, false if merging from the same group</returns>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.ClientData.AwakeGroupsQueue">
            <summary>
            State groups that have signaled themselves as active and should be sent to client.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ClientData.GetReplicableState(VRage.Network.IMyReplicable)">
            <summary>
            Get the replication state for a given object.
            </summary>
            <param name="replicable"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ClientData.BlockHierarchies(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Add mutual blocking between r1 and r2 and their dependencies.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ClientData.ToString">
            <inheritdoc />
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_replicableDeferredRemoval">
            <summary>
            Set of replicables which are marked for destruction immediately after being ready on all clients.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.Replicables">
            <summary>
            All replicables on server.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_clientStates">
            <summary>
            Network objects and states which are actively replicating to clients.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_timeFunc">
            <summary>
            Function which provides current update time
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationServer.m_serverSimSpeed">
            <summary>
            Last known server simspeed.
            </summary>
        </member>
        <member name="P:VRage.Network.MyReplicationServer.ClientCount">
            <summary>
            Number of connected clients.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.PushChildren(VRage.Network.IMyReplicable)">
            <summary>
            Push children to clients if parent replicable exits.
            </summary>
            <param name="parent">Parent replicable</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ForceReplicable(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Hack to allow thing like: CreateCharacter, Respawn sent from server
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ForceReplicable(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            Hack to allow thing like: CreateCharacter, Respawn sent from server
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.IsPreceding(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns true when current packet is closely preceding last packet (is within threshold)
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ScheduleStateGroupSync(VRage.Network.MyReplicationServer.ClientData,VRage.Network.MyStateDataEntry,System.Int64,System.Boolean)">
            <summary>
            Schedule the state group for synchronization.
            </summary>
            <param name="clientData"></param>
            <param name="groupEntry"></param>
            <param name="currentTime"></param>
            <param name="firstTime">Indicates that the group is scheduled for the first time.</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.WriteStateSyncHeader(VRage.Network.MyReplicationServer.ClientData)">
            <summary>
            
            </summary>
            <param name="clientData"></param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.IsReplicated(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            Whether the provided replicable has been replicated to the target endpoint already.
            </summary>
            <param name="replicable">The replicable object.</param>
            <param name="clientEndpoint">The endpoint identifying the client.</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.IsPending(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            Whether the provided replicable has been queued to be replicated to the target endpoint already.
            </summary>
            <remarks>
            By 'queued' we mean that the replicable is already stored on that endpoint's client data is marked as pending.
            </remarks>
            <param name="replicable">The replicable object.</param>
            <param name="clientEndpoint">The endpoint identifying the client.</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.GetReplicationState(VRage.Network.IMyReplicable,VRage.Network.EndpointId)">
            <summary>
            Get the replication state for the provided replicable and a target endpoint.
            </summary>
            <param name="replicable">The replicable object.</param>
            <param name="clientEndpoint">The endpoint identifying the client.</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.IsReady(VRage.Network.IMyStateGroup,VRage.Network.EndpointId)">
            <summary>
            Whether the provided replicable is queued or already replicated to the target endpoint.
            </summary>
            <remarks>
            By 'queued' we mean that the replicable is already stored on that endpoint's client data is marked as pending.
            </remarks>
            <param name="stateGroup">The replicable object.</param>
            <param name="clientEndpoint">The endpoint identifying the client.</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ReadReplicableReady(VRage.MyPacket)">
            <summary>
            Read the packet which confirms that the replicable is ready. 
            </summary>
            <param name="packet">incoming packet</param>
        </member>
        <member name="M:VRage.Network.MyReplicationServer.ProcessReplicableReady(VRage.Network.EndpointId,VRage.Network.NetworkId,System.Boolean)">
            <summary>
            Process the message "replicable ready" that came from the client.
            </summary>
            <param name="sender">client endpoint id</param>
            <param name="networkId">network id of the replicable</param>
            <param name="loaded"></param>
        </member>
        <member name="T:VRage.Network.RpcSerializableAttribute">
            <summary>
            Attribute that marks objects as serializable for use in RPCs.
            </summary>
        </member>
        <member name="M:VRage.Network.MyClientInfo.GetPriority(VRage.Network.IMyReplicable)">
            <summary>
            Gets priority of different replicable.
            E.g. can be used to get priority of grid when calling GetPriority on cube block.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReliableEventPacketQueue.Clear">
            <summary>
            Clears whole queue.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReliableEventPacketQueue.Enqueue(VRage.Network.IMyNetObject,VRage.Network.CallSite,VRage.Library.Collections.BitStream,VRage.Network.EndpointId)">
            <summary>
            Sends message, when broadcasting, recipient is peer who won't receive the message.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReliableEventPacketQueue.Send(VRage.Network.MyReplicationServer,VRage.Network.MyReplicationServer.ClientData,System.Int32)">
            <summary>
            Sends packets in queue, sends no more than maxBytesToSend.
            Returns number of bytes sent.
            </summary>
            TODO: nicer design, i do not really like referencing back to replication server and client data...
        </member>
        <member name="T:VRage.Network.IMyEventProxy">
            <summary>
            Interface which only marks class as event owner.
            Object itself must be replicated in network to allow raising events.
            If you considering to add this to object, it's probably wrong and you should use static events in most cases.
            This is commonly implemented only by entities which has it's external replicable.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyNetObject">
            <summary>
            Base interface for networked object.
            Derived interfaces are so far IMyReplicable and IMyStateGroup.
            </summary>
        </member>
        <member name="T:VRage.Network.IMyEventOwner">
            <summary>
            Common interface for IMyNetObject and IMyEventProxy used to raise events.
            Base interface for classes passed as event instance.
            Custom implementations not supported.
            </summary>
        </member>
        <member name="P:VRage.Network.IMyProxyTarget.Target">
            <summary>
            Gets target object.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetDependency">
            <summary>
            Gets dependency which must be replicated first.
            When parent is replicated, children are replicated, priority is never checked for children.
            Dependency can change during replicable runtime
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetPriority(VRage.Network.MyClientInfo)">
            <summary>
            Gets priority related to client.
            When priority is lower than zero, it means the object is not relevant for client.
            Default priority is 1.0f.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.CreateSerializationData">
            <summary>
            Create empty serialization container of this replicable.
            </summary>
            <returns>Instance of implementation specific data.</returns>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnLoadDone(System.Object)">
            <summary>
            Called on client once the loading of the replicable is complete.
            </summary>
            <param name="instance">Instance connected to the replicable (entity, scene, component...)</param>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnDestroyedClient">
            <summary>
            Called on client when server destroyed this replicable.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.OnDestroyedServer">
            <summary>
            Called on server when this replicable is destroyed.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyReplicable.GetStateGroups">
            <summary>
            Returns state groups for replicable in a list.
            This method has to return objects in same order every time (e.g. first terminal, second physics etc).
            It does not have to return same instances every time.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.CreateClientData(VRage.Network.MyClientStateBase)">
            <summary>
            Called on server new clients starts replicating this group.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.DestroyClientData(VRage.Network.MyClientStateBase)">
            <summary>
            Called on server when client stops replicating this group.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.Destroy">
            <summary>
            Called when state group is being destroyed.
            </summary>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.GetSyncTimeSchedule(VRage.Network.MyClientInfo,System.Boolean)">
            <summary>
              This function provides relative time of next sync from server to clients.
              It can be understood as a soft time limit for next sync.
            </summary>
            <param name="forClient">
              The client who will receive that state synchronization.
            </param>
            <param name="firstTime">
              Indicates that the group is going to be scheduled for the first time.
              Change the scheduling time accordingly to get quicker response.  
            </param>
            <returns>
              Returns scheduling time in frames, the value is relative to current time. 
              If function returns null, state group does not require synchronization 
              and can be put to sleep.
              Valid value range: [null, 0+]. 
            </returns>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.Serialize(VRage.Library.Collections.BitStream,VRage.Network.EndpointId,System.Int64,System.Byte,System.Int32)">
            <summary>
            (De)serializes group state or it's diff for client.
            When writing, you can write beyond maxBitPosition, but message won't be sent and ACKs won't be received for it.
            ReplicationServer will detect, that state group written beyond packet size and revert it.
            When nothing written, ReplicationServer will detect that and state group won't receive ACK for that packet id.
            </summary>
            <param name="stream">Stream to write to or read from.</param>
            <param name="forClient">When writing the client which will receive the data. When reading, it's null.</param>
            <param name="timestamp"></param>
            <param name="packetId">Id of packet in which the data will be sent or from which the data is received.</param>
            <param name="maxBitPosition">Maximum position in bit stream where you can write data, it's inclusive.</param>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.OnAck(VRage.Network.MyClientStateBase,System.Byte,System.Boolean)">
            <summary>
            Called for each packet id sent to client from this state group.
            When ACK received, called immediately.
            When several other packets received from client, but some were missing, called for each missing packet.
            </summary>
            <param name="forClient">The client.</param>
            <param name="packetId">Id of the delivered or lost packet.</param>
            <param name="delivered">True when packet was delivered, false when packet is considered lost.</param>
        </member>
        <member name="M:VRage.Network.IMyStateGroup.TimestampReset(System.Int64)">
            <summary>
            Notify the state group that the timestamp was reset.
            </summary>
        </member>
        <member name="T:VRage.Network.RefreshReplicableAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:VRage.Network.MyClientStateBase">
            <summary>
            Base class for game-defined client state.
            It's set of data required by server, sent from client.
            E.g. current client area of interest, context (game, terminal, inventory etc...)
            Abstract class for performance reasons (often casting)
            </summary>
        </member>
        <member name="P:VRage.Network.MyClientStateBase.EndpointId">
            <summary>
            Client endpoint, don't serialize it in Serialize()
            </summary>
        </member>
        <member name="P:VRage.Network.MyClientStateBase.Position">
            <summary>
            Client point of interest, used on server to replicate nearby entities
            </summary>
        </member>
        <member name="M:VRage.Network.MyClientStateBase.Serialize(VRage.Library.Collections.BitStream,System.Int64)">
            <summary>
            Serializes state into/from bit stream.
            EndpointId should be ignored.
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.Sender">
            <summary>
            Event sender, default(EndpointId) when invoked locally.
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.ClientState">
            <summary>
            Event sender client data, valid only when invoked remotely on server, otherwise null.
            </summary>
        </member>
        <member name="F:VRage.Network.MyEventContext.IsValidationRequired">
            <summary>
            True if validation is required.
            </summary>
        </member>
        <member name="T:VRage.Network.MyEventTable">
            <summary>
            Storage for event metadata.
            </summary>
        </member>
        <member name="M:VRage.Network.MyEventTable.FeedCallSite(System.UInt32,VRage.Network.CallSite)">
            <summary>
            Store a call site after asynchronous generation.
            </summary>
            <param name="id"></param>
            <param name="callSite"></param>
        </member>
        <member name="M:VRage.Network.MyUnreliableEventPacketQueue.Clear">
            <summary>
            Clears whole queue.
            </summary>
        </member>
        <member name="M:VRage.Network.MyUnreliableEventPacketQueue.Enqueue(VRage.Library.Collections.BitStream,System.Single,VRage.Network.EndpointId)">
            <summary>
            Sends message, when broadcasting, recipient is peer who won't receive the message.
            </summary>
        </member>
        <member name="M:VRage.Network.MyUnreliableEventPacketQueue.Send(System.Int32)">
            <summary>
            Sends packets in queue, sends no more than maxBytesToSend.
            Returns number of bytes sent.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationClient.m_pendingReplicableId">
            <summary>
            Mapping of pending replicable to network id.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.SetReplicableReady(VRage.Network.NetworkId,System.Boolean)">
            <summary>
            Marks replicable as successfully created, ready to receive events and state groups data.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.TrySetPendingReplicableReady(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Boolean)">
            <summary>
            Set the pending replicable ready or report error in loading, according to parameter "loaded".
            </summary>
            <param name="networkId">network id of pending replicable</param>
            <param name="replicable">instance of pending replicable</param>
            <param name="loaded">true if the initialization went ok - false will signalize to server to resend the replicable</param>
            <returns>Returns true on success, false when there was no pending replicable with network id equal to argument "networkId"</returns>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.ProcessReplicationCreateStreamed(VRage.MyPacket)">
            <summary>
            Process the start of streamed replication of entity. This will create pending replicable and streaming state group.
            </summary>
            <param name="packet">incoming packet</param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.ProcessReplicationDestroy(VRage.MyPacket)">
            <summary>
            Process the destruction of replicated entity.
            </summary>
            <param name="packet">incoming packet</param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.TryAddPendingReplicableDependency(VRage.Network.IMyReplicable,VRage.Network.NetworkId)">
            <summary>
            Attempt to enqueue the provided replicable as a dependency of the given network id.
            </summary>
            <param name="replicable">The replicable that depends on another network object.</param>
            <param name="dependencyId">The id of the network object depended on.</param>
            <returns>
            True if the replicable identified by <paramref name="dependencyId"/> is known to this client and is pending. False otherwise.
            </returns>
            <exception cref="T:System.ArgumentException">When the provided replicable is not pending, or when the dependency is not known to the client.</exception>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.SetPendingReplicableCallback(VRage.Network.IMyReplicable,System.Action)">
            <summary>
            Set the callback to be invoked when the provided replicable has all dependencies met.
            </summary>
            <param name="replicable"></param>
            <param name="callback"></param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.DispatchDependents(System.Collections.Generic.HashSet{VRage.Network.NetworkId})">
            <summary>
            Decrement the dependency count for all replicables in the set.
            </summary>
            <param name="dependencies"></param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.RemoveDependencies(VRage.Network.NetworkId,System.Collections.Generic.HashSet{VRage.Network.NetworkId})">
            <summary>
            Unhook all dependencies for the pending replicable.
            </summary>
            <param name="source"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.GetPendingReplicable(VRage.Network.NetworkId)">
            <summary>
            Get pending replicable from the given network id. Returns null if pending replicable does not exist.
            Thread-sage.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.TryRemovePendingReplicable(VRage.Network.NetworkId)">
            <summary>
            Try to remove pending replicable. If there is no replicable with given network id, or if the replicable 
            is not pending anymore, function does nothing and returns false.
            </summary>
            <param name="networkId">network id of the pending replicable</param>
            <returns>returns true when pending replicable has been removed</returns>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.RemoveReplicable(VRage.Network.IMyReplicable)">
            <summary>
            Remove the active replicable.
            </summary>
            <param name="replicable">instance of replicable</param>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.IsBlocked(VRage.Network.NetworkId,VRage.Network.NetworkId)">
            <summary>
            Checks if network id is blocked by other network id.
            </summary>
            <param name="networkId">Target network id.</param>
            <param name="blockedNetId">Blocking network id.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Network.MyReplicationClient.ProcessStateSync(VRage.MyPacket)">
            <summary>
            Processes state sync sent by server.
            </summary>
        </member>
        <member name="F:VRage.Network.MyReplicationLayer.SyncFrameCounter">
            <summary>
            Synchronized time. Server frame number. It is increased by one every frame tick.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.AdvanceSyncTime">
            <summary>
            Advance local synchronized time.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.GetMultiplayerStatLocal">
            <summary>
            Returns string with current multiplayer status. Use only for debugging.
            </summary>
            <returns>Already formatted string with current multiplayer status.</returns>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.DispatchEvent(VRage.Library.Collections.BitStream,VRage.Network.CallSite,VRage.Network.EndpointId,VRage.Network.IMyNetObject,System.Single)">
            <summary>
            Called when event is raised locally to send it to other peer(s).
            Return true to invoke event locally.
            </summary>
            <remarks>
            Invoking event locally is important to be done AFTER event is sent to other peers, 
            because invocation can raise another event and order must be preserved.
            Local event invocation is done in optimized way without unnecessary deserialization.
            </remarks>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.ProcessEvent(VRage.Library.Collections.BitStream,VRage.Network.CallSite,System.Object,VRage.Network.IMyNetObject,VRage.Network.EndpointId)">
            <summary>
            Called when event is received over network.
            Event can be validated, invoked and/or transferred to other peers.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayer.Invoke(VRage.Network.CallSite,VRage.Library.Collections.BitStream,System.Object,VRage.Network.EndpointId,VRage.Network.MyClientStateBase,System.Boolean)">
            <summary>
            Reads arguments from stream and invokes event. Returns false when validation failed, otherwise true.
            </summary>
        </member>
        <member name="T:VRage.Network.MyStateDataEntry">
            <summary>
            State group descriptor (instantiated per state group per client).
            </summary>
        </member>
        <member name="F:VRage.Network.MyStateDataEntry.Group">
            <summary>
            Link to the state group.
            </summary>
        </member>
        <member name="T:VRage.Network.MySynchronizedTypeInfo">
            <summary>
            Type descriptor for synchronized type.
            </summary>
        </member>
        <member name="T:VRage.Network.MyTypeTable">
            <summary>
            Container for type RPC metadadata.
            
            This is used by the VRage Multiplayer Replication layer to index RPC calls available to servers and clients.
            
            There is no need to instantiate this class, it is automatically hooked to the VRage Type Metadata System.
            </summary>
        </member>
        <member name="F:VRage.Network.MyTypeTable.m_staticEventTable">
            <summary>
            Know static events.
            
            For simplicity we accumulate all events from all parent indexers as well.
            </summary>
        </member>
        <member name="F:VRage.Network.MyTypeTable.m_queuedTypes">
            <summary>
            Types added to list but not yet indexed.
            </summary>
        </member>
        <member name="F:VRage.Network.MyTypeTable.m_idToType">
            <summary>
            Linear index of types.
            </summary>
        </member>
        <member name="F:VRage.Network.MyTypeTable.m_typeLookup">
            <summary>
            Lookup of metadata by type.
            </summary>
        </member>
        <member name="F:VRage.Network.MyTypeTable.m_hashLookup">
            <summary>
            Lookup of metadata by type hash.
            </summary>
        </member>
        <member name="P:VRage.Network.MyTypeTable.Static">
            <summary>
            Reference to the top level type table that should be used for the whole application.
            </summary>
        </member>
        <member name="P:VRage.Network.MyTypeTable.TypeCount">
            <summary>
            Count of types indexed by this table.
            </summary>
        </member>
        <member name="P:VRage.Network.MyTypeTable.StaticEventTable">
            <summary>
            Event table containing all know static events.
            </summary>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Contains(System.Type)">
            <summary>
            Whether a given type is indexed.
            </summary>
            <param name="type">The type to lookup</param>
            <returns>Whether the type is know by this type table.</returns>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Get(VRage.Network.TypeId)">
            <summary>
            Get a type base on it's runtime serial id.
            </summary>
            <param name="id">The runtime id of the type.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Get(System.Type)">
            <summary>
            Get RPC metadata for a given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Network.MyTypeTable.TryGet(System.Type,VRage.Network.MySynchronizedTypeInfo@)">
            <summary>
            Try to get RPC metadata for a given type.
            </summary>
            <param name="type"></param>
            <param name="typeInfo">Type RPC metadata if found.</param>
            <returns>Whether any metadata was found.</returns>
        </member>
        <member name="M:VRage.Network.MyTypeTable.QueueForRegistration(System.Type,System.Boolean)">
            <summary>
            Enqueue a type for registration within the type table.
            </summary>
            <remarks>This method should only be invoked by other metadata indexers during indexing.</remarks>
            <param name="type"></param>
            <param name="serializable"></param>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Register(System.Type,System.Boolean)">
            <summary>
            Call this only on manually managed type tables.
            
            The top level table registers automatically, and runtime modification can lead to undefined behavior.
            </summary>
            <param name="type">Type to be indexed.</param>
            <param name="forceSerializable">When true the type is registered as if it was marked with the <see cref="T:System.SerializableAttribute"/> attribute.</param>
            <returns>Resulting RPC metadata.</returns>
        </member>
        <member name="M:VRage.Network.MyTypeTable.Serialize(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes id to hash list.
            Client and server both check if the type hashes match.
            The order of types is determined by their names, so 
            </summary>
        </member>
        <member name="M:VRage.Network.MyTypeTable.RegisterTypeHierarchy(System.Type)">
            <summary>
            Types are not indexed according to their type hierarchy, so it is important to complete the chains.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Network.NetworkId">
            <summary>
            Network object identifier.
            </summary>
            <remarks>
            Network objects (replicables, state groups, etc) use the NetworkId as a consistent identifier, chosen by the server and
            propagated to clients with those objects.
            </remarks>
        </member>
        <member name="M:VRage.Network.NetworkId.Serialize(VRage.Library.Collections.BitStream)">
            <summary>
            Serialize this network id to a stream.
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:VRage.Network.NetworkId.Deserialize(VRage.Library.Collections.BitStream)">
            <summary>
            Deserialize a network id from a stream.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Network.ReliableAttribute">
            <summary>
            Event which is sent reliably, use with caution and only when necessary!
            </summary>
        </member>
        <member name="P:VRage.Network.MyReplicationLayerBase.Log">
            <summary>
            Log used for replication.
            </summary>
        </member>
        <member name="M:VRage.Network.MyReplicationLayerBase.InvokeLocally``7(VRage.Network.CallSite{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Invokes event locally without validation and with empty Sender and ClientData.
            </summary>
        </member>
        <member name="T:VRage.Network.ServerAttribute">
            <summary>
            Server method. Decorated method is be called by client on server or by server locally.
            Server performs validation. Pass null as validation method to perform no validation (not recommended)
            </summary>
        </member>
        <member name="T:VRage.Network.StateGroupEnum">
            <summary>
            State groups, used to limit bandwidth by group.
            </summary>
        </member>
        <member name="T:VRage.Network.TypeId">
             <summary>
             Network safe identifier for a type.
             </summary>
             <remarks>
             This id is guaranteed to be the same among connected clients with the same application version.
            
             It is not safe to be used for persistent storage as it might change between application versions.
             </remarks>
        </member>
        <member name="T:VRage.Network.TrustedAttribute">
            <summary>
            Mark method as untrusted. This will result in some additional safety checks on server side.
            </summary>
        </member>
        <member name="T:VRage.Noise.Models.MyCylinder">
            <summary>
            Maps the output of a module onto a cylinder.
            </summary>
        </member>
        <member name="T:VRage.Noise.Models.MySphere">
            <summary>
            Maps the output of a module onto a sphere.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyAbs">
            <summary>
            Outputs the absolute value of the output value from a source module.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyClamp">
            <summary>
            Clamps the output value from a source module to a range of values.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyCurve">
            <summary>
            Maps the output value from a source module onto an arbitrary function curve.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyExponent">
            <summary>
            Maps the output value from a source module onto an exponential curve.
            </summary>
        </member>
        <member name="T:VRage.Noise.Modifiers.MyInvert">
            <summary>
            Inverts the output value from a source module.
            </summary>
        </member>
        <member name="T:VRage.Noise.MyModule">
            <summary>
            High quality noise module that combines properties of Value noise and gradient noise.
            Value noise is used as input for gradient function. This leads to no artifacts or zero values at integer points.
            It's so called Value-Gradient noise.
            </summary>
        </member>
        <member name="T:VRage.Noise.MyModuleFast">
            <summary>
            Faster version of MyModule.
            This time we do not compute the gradient position directly but we're using gradient table lookup via permutation table.
            This leads to more 'grid' result as the local min and max (like in Value noise) are always appearing at integer points.
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MyCylinders">
            <summary>
            Noise that outputs concentric cylinders.
            Each cylinder extends infinitely along the y axis.
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MyRing">
            <summary>
            Noise that outputs dounut-like ring
            </summary>
        </member>
        <member name="T:VRage.Noise.Patterns.MySpheres">
            <summary>
            Noise that outputs concentric spheres.
            </summary>
        </member>
        <member name="F:VRage.Profiler.MyDrawArea.m_index">
            <summary>
            Index 0, 1, 2, 3, 4, 5...
            Makes range 1, 1.5, 2, 3, 4, 6, 8, 12, 24, 32, 48, 64...
            Negative index is supported as well.
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyDrawArea.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes draw area.
            </summary>
            <param name="yRange">Range of y axis, will be rounded to 2^n or 2^n * 1.5</param>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.Enable">
            <summary>
            Only enables the profiler, used by the developer debug window
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.ToggleEnabled">
            <summary>
            Toggles profiler enabled/disabled state, doesn't reset profiler level
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.JumpToRoot">
            <summary>
            Jumps all the way to the root element
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.DisableFrameSelection">
            <summary>
            Disables the current selection again
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.ChangeSortingOrder">
            <summary>
            Changes the profiler's sorting order, see ProfilerSortingOptions for the possible sorting options
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.CopyPathToClipboard">
            <summary>
            Copies the current path to clipboard
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerCommand.TryGoToPathInClipboard">
            <summary>
            Tries to navigate to the path in the clipboard
            </summary>
        </member>
        <member name="T:VRage.Profiler.RenderProfilerSortingOrder">
            <summary>
            Profiler sorting order types
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerSortingOrder.Id">
            <summary>
            Order in which the elements are logged
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerSortingOrder.MillisecondsLastFrame">
            <summary>
            Milliseconds spent in the previous frame, sorted from slowest to fastest
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerSortingOrder.MillisecondsAverage">
            <summary>
            Milliseconds spent on average, sorted from slowest to fastest
            </summary>
        </member>
        <member name="F:VRage.Profiler.RenderProfilerSortingOrder.NumSortingTypes">
            <summary>
            Total number of sorting types
            </summary>
        </member>
        <member name="T:VRage.Profiler.MyRenderProfiler">
            <summary>
            Provides profiling capability
            </summary>
            <remarks>
            Non-locking way of render profiler is used. Each thread has it's own profiler is ThreadStatic variable.
            Data for each profiling block are of two kinds: Immediate (current frame being profiled) and History (previous finished frames)
            Start/End locking is not necessary, because Start/Stop uses only immediate data and nothing else uses it at the moment.
            Commit is only other place which uses Immediate data, but it must be called from same thead, no racing condition.
            Draw and Commit both uses History data, and both can be called from different thread, so there's lock.
            This way everything runs with no waiting, unless Draw obtains lock in which case Commit wait for Draw to finish (Start/End is still exact).
            
            For threads which does not call commit (background workers, parallel tasks), mechanism which calls commit automatically after each top level End should be added.
            This way each task will be one "frame" on display
            </remarks>
        </member>
        <member name="F:VRage.Profiler.MyRenderProfiler.m_sortingOrder">
            <summary>
            Sorting order will sort the listed elements in the profiler by the specified ProfilerSortingOrder
            </summary>
        </member>
        <member name="P:VRage.Profiler.MyRenderProfiler.ProfilerVisible">
            <summary>
            Returns true when profiler is visible.
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyRenderProfiler.CreateProfiler(System.String,System.String,System.Boolean)">
            <summary>
            Creates new profiler which can be used to profile anything (e.g. network stats).
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyRenderProfiler.ComputeStats(System.Single[],System.Int32,System.Int32,System.Int32,VRage.Profiler.MyRenderProfiler.Stats@)">
            <summary>
            Compute the min/max/avg stats over the provided range and excluding the embedded update window.
            </summary>
            <param name="data"></param>
            <param name="lower"></param>
            <param name="upper"></param>
            <param name="lastValidFrame"></param>
            <param name="stats"></param>
        </member>
        <member name="T:VRage.Profiler.NetProfiler">
            <summary>
            Shortcut class for network profiler.
            </summary>
        </member>
        <member name="M:VRage.Profiler.NetProfiler.Begin(System.String,System.Int32,System.String,System.Int32,System.String)">
            <summary>
            Starts net profiling block.
            </summary>
        </member>
        <member name="M:VRage.Profiler.NetProfiler.End(System.Nullable{System.Single},System.Single,System.String,System.String,System.String,System.String,System.Int32,System.String)">
            <summary>
            End net profiling block.
            </summary>
            <param name="bytesTransfered">Specify number of bytes transferred or null to automatically calculate number of bytes from inner blocks.</param>
            <param name="customValue">You can put any number here.</param>
            <param name="customValueFormat">This is formatting string how the number will be written on screen, use something like: 'MyNumber: {0} foos/s'</param>
            <param name="byteFormat"></param>
            <param name="callFormat"></param>
            <param name="member"></param>
            <param name="line"></param>
            <param name="file"></param>
        </member>
        <member name="T:VRage.Profiler.ProfilerShort">
            <summary>
            Helper class, "shortcuts" to profiler
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicationState">
            <summary>
            Represents the possible replication states for a network object.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketDeserializationJob.HEADER_CHAR">
            <summary>
            Introduction mark in the serialization stream. For sanity checking.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketDeserializationJob.FOOTER_CHAR">
            <summary>
            Finalizing mark in the serialization stream. For sanity checking.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicablePacketDeserializationJob.MyReplicableData">
            <summary>
            Decompressed data of one replicable.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicablePacketDeserializationJob.MyDeserializedReplicables">
            <summary>
            Resulting collection of replicables that were deserialized from the stream.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicablePacketDeserializationJob.MyParallelJobDesc">
            <summary>
            Descriptor for the parallel job.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketDeserializationJob.MyParallelJobDesc.Client">
            <summary>
            Link back to the replication client. Since we are on parallel thread, avoid thread-unsafe methods.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketDeserializationJob.Start(VRage.Network.MyReplicationClient,System.Byte[],System.Boolean,System.Action{VRage.Replication.MyReplicablePacketDeserializationJob.MyDeserializedReplicables},System.Action{System.Int32},System.Int32)">
            <summary>
            Start the parallel decompression of packet data.
            </summary>
            <param name="client">Link to the replication client.</param>
            <param name="packetData">Byte array with incoming data.</param>
            <param name="isCompressed">true if incoming data are compressed</param>
            <param name="onCompletion">Completion callback that will process the decompressed data. Will be run on parallel thread.</param>
            <param name="onFailure">Callback to be called when error happens.</param>
            <param name="jobId">Parallel job identifier to keep the order of operations</param>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketDeserializationJob.Decompress(VRage.Replication.MyReplicablePacketDeserializationJob.MyParallelJobDesc)">
            <summary>
            Decompress the streamed data, intended to be run on parallel worked thread.
            </summary>
            <param name="jobDesc">parallel job data</param>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketDeserializationJob.Deserialize(VRage.Replication.MyReplicablePacketDeserializationJob.MyParallelJobDesc)">
            <summary>
            Deserialize decompressed data into replicable serialization objects. This method is intended to be run on parallel worker thread.
            </summary>
            <param name="jobDesc">parallel job data</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddGroupObjectBuilder(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Object)">
            <summary>
            Add group object builder for the synchronous load.
            </summary>
            <param name="sourceReplicableId">id of replicable where the entity object builder comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="groupObjBuilder">instance of the group object builder</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddEntityObjectBuilder(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Object)">
            <summary>
            Add entity object builder for the synchronous load.
            </summary>
            <param name="sourceReplicableId">id of replicable where the entity object builder comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="entityObjBuilder">instance of the entity object builder</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddEntity(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Int64)">
            <summary>
            Add entity to verify if it exists after scene pasting.
            </summary>
            <param name="sourceReplicableId">id of replicable the entity is connected to</param>
            <param name="sourceReplicable">replicable the entity is connected to</param>
            <param name="entityId">entity id</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddEntityComponent(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Int64,System.Type)">
            <summary>
            Add entity component to verify if it exists after pasting.
            </summary>
            <param name="sourceReplicableId">id of replicable where the verified component comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="entityId">parent entity id</param>
            <param name="type">entity component type</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddEntityComponent(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Int64,System.Type,VRage.Utils.MyStringHash)">
            <summary>
            Add entity component to verify if it exists after pasting.
            </summary>
            <param name="sourceReplicableId">id of replicable where the verified component comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="entityId">parent entity id</param>
            <param name="type">entity component type</param>
            <param name="subtypeId">entity component subtype identifier</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddCustom(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Object)">
            <summary>
            Add custom instance to set to be ready after loading the scene. Hook the instance to replicable after loading the scene.
            </summary>
            <param name="sourceReplicableId">id of replicable where the entity object builder comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="customInstance">custom instance to be hooked</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.AddCustomLoader(VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Func{VRage.Network.NetworkId,VRage.Network.IMyReplicable,System.Object})">
            <summary>
            Add custom replicable loader to set to be invoked after loading the scene. Loader should Hook the instance to replicable after loading the scene.
            The loader should NOT call IMyReplicable.OnLoadDone itself.
            </summary>
            <param name="sourceReplicableId">id of replicable where the entity object builder comes from</param>
            <param name="sourceReplicable">replicable where the entity object builder comes from</param>
            <param name="customLoader">custom loader if needed, can be null if the loading of replicable already succeeded - returns the instance that should be hooked to replicable</param>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSceneLoader.Load(System.Collections.Generic.Dictionary{VRage.Network.NetworkId,System.Boolean},System.Action{VRage.Collections.DictionaryReader{VRage.Network.NetworkId,System.Boolean}})">
            <summary>
            Perform asynchronous loading of the scene.
            </summary>
            <param name="loadResults">structure where to store results of loading of replicable, can contain values already</param>
            <param name="onFinish">callback after the pasting into scene is finished, argument maps replicable network ids to successes</param>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingReceiver.m_generatedJobId">
            <summary>
            Identifier for the next created parallel job. Sequence number. 
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingReceiver.m_expectedJobId">
            <summary>
            Expected identifier of finished parallel job. Sequence number. 
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingReceiver.Read(VRage.Library.Collections.BitStream)">
            <summary>
            Read the replication stream, process deserialized content.
            </summary>
            <param name="stream">input stream</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingReceiver.PerformLoading">
            <summary>
            Perform loading of deserialized replicables which were already processed on the parallel stream.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingReceiver.ProcessReceivedPacket(System.Byte[],System.Boolean)">
            <summary>
            Process received data on parallel - decompress and deserialize.
            </summary>
            <param name="readerReceivedBuffer">received data buffer</param>
            <param name="isCompressed">received data are compressed</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingReceiver.FinishLoading(System.Collections.Generic.List{VRage.Replication.MyReplicablePacketDeserializationJob.MyDeserializedReplicables})">
            <summary>
            Finish loading of the replicables.
            Data is already decompressed and deserialized, this loads the data directly into replicables.
            </summary>
            <param name="deserializedList">list of structures carrying links to replicables and their deserialized data.</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingReceiver.OnReplicablesAddedToScene(VRage.Collections.DictionaryReader{VRage.Network.NetworkId,System.Boolean})">
            <summary>
            Set the replicables ready after all the loading.
            </summary>
        </member>
        <member name="T:VRage.Replication.IMyReplicableSerializationData">
             <summary>
             Interface which provides thread-safe serialization and deserialization of replicable data.
             Serves as a container - embeds serialized state of the replicable.
            
             Serialization process:
               1/ synchronous part, when the replicable is serialized into internal structures (for example, into an object builder)
               2/ asynchronous part, when the internal data is serialized into stream (for example, from object builder into stream)
            
             Deserialization process:
               1/ asynchronous part, when the internal data is deserialized from stream (for example, from stream to object builder)
               2/ synchronous part, when the replicable is deserialized from internal structures (for example, from an object builder)
             </summary>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSerializationData.Store(VRage.Network.IMyReplicable)">
            <summary>
            Serialize given replicable to the internal structure.
            Needs to be called on update thread.
            Resulting internal serialization data must all necessary information and can be processed further asynchronously.
            </summary>
            <param name="replicable">Target replicable where to serialize from.</param>
            <returns>Returns true if the serialization into internal structures was successful.</returns>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSerializationData.LoadInto(VRage.Network.NetworkId,VRage.Network.IMyReplicable,VRage.Replication.IMyReplicableSceneLoader)">
            <summary>
            Deserialize into replicable from the implementation-specific data.
            Needs to be called on update thread.
            </summary>
            <param name="replicableId">Id of the replicable</param>
            <param name="replicable">Target replicable where to deserialize internally stored data.</param>
            <param name="sceneLoader">Instance of synchronous scene loader.</param>
            <returns>Returns if the deserialization was successful, if the load is still pending or if it failed</returns>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSerializationData.Serialize(VRage.Library.Collections.BitStream)">
            <summary>
            Serialize the internal data to the stream. Implementation must be thread-safe and then it can be called from any worker thread.
            </summary>
            <param name="stream">Target stream.</param>
            <returns>Return false if the serialization to stream failed</returns>
        </member>
        <member name="M:VRage.Replication.IMyReplicableSerializationData.Deserialize(VRage.Library.Collections.BitStream)">
            <summary>
            Deserialize the internal data from the stream. Implementation must be thread-safe and then it can be called from any worker thread.
            </summary>
            <param name="stream">Source stream.</param>
            <returns>Return false if the deserialization from stream failed</returns>
        </member>
        <member name="F:VRage.Replication.MyClientTimeCorrection.m_linkToFrameLoop">
            <summary>
            Link to the frame loop. This can be used to slow down the client when the server cannot keep up.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyClientTimeCorrection.m_lastSyncRealTime">
            <summary>
            Last time we performed a synchronization.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyClientTimeCorrection.m_correctionSmoothMs">
            <summary>
            Smoothed correction delta in milliseconds.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyClientTimeCorrection.LastServerSyncFrameCounter">
            <summary>
            Last known server value of frame counter.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyExternalReplicable.StateGroups">
            <summary>
            This is a collection of all state groups in this replicable. You must register your state groups in subclasses (constructor/onhook).
            </summary>
        </member>
        <member name="M:VRage.Replication.MyExternalReplicable.ToString">
            <summary>
            Implementation of conversion to string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.Replication.MyNetworkPing">
            <summary>
            Class used for storing and smoothing "ping", network latency between from client to server and back.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyNetworkPing.PingMs">
            <summary>
            Smoothed ping value.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyNetworkPing.ImmediatePingMs">
            <summary>
            Returns ping value without any smoothing.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyNetworkPing.ClientWrite(VRage.Library.Collections.BitStream)">
            <summary>
            Serialization on the client side. Writes local time to the stream so the ping can be measured later.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyNetworkPing.ServerRead(VRage.Library.Collections.BitStream)">
            <summary>
            Deserialization on the server side. Stores time sent from the client to the temporary storage.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyNetworkPing.ServerWrite(VRage.Library.Collections.BitStream)">
            <summary>
            Serialization on the server side. Writes last received client time to the stream.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyNetworkPing.ClientRead(VRage.Library.Collections.BitStream,VRage.MyPacket@)">
            <summary>
            Deserialization on the client side. Reads from bitstream and computes the new ping value.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyNetworkPing.UpdatePing(System.Double)">
            <summary>
            Update the measured ping value (latency between from client to server and back).
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicableFactory">
             <summary>
             Factory responsible for indexing game types that are replicated across multi-player.
            
             These types are replicated by virtue of special annotations, namely ReplicableAttribute and ReplicatedComponentAttribute.
             </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableFactory.FindTypeFor(System.Object)">
            <summary>
            Find the replicable type for an object instance.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Replication.MyReplicableFactory.TryGetReplicable(System.Type,System.Type@)">
            <summary>
            Attempt to find the replicable type for the provided object type.
            </summary>
            <param name="objectType">Type of the object top look up.</param>
            <param name="replicableType">Found replicable type if any.</param>
            <returns>Whether the replicable type could be found</returns>
        </member>
        <member name="M:VRage.Replication.MyReplicableFactory.IsLazy(System.Type)">
            <summary>
            Whether an entity is marked with the lazy replication attribute.
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="F:VRage.Replication.MyReplicables.m_empty">
            <summary>
            Helper empty collection. Used for returning empty enumerations or lists.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicables.RootCount">
            <summary>
            Number of root replicables.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.GetChildren(VRage.Network.IMyReplicable)">
            <summary>
            Get the children of the replicable.
            </summary>
            <param name="replicable">replicable instance</param>
            <returns>read-only collection of child replicables</returns>
        </member>
        <member name="M:VRage.Replication.MyReplicables.GetAllChildren(VRage.Network.IMyReplicable,System.Collections.Generic.List{VRage.Network.IMyReplicable})">
            <summary>
            Get all child replicables of the given replicable. Returns whole child subtree (children of children).
            </summary>
            <param name="replicable">replicable instance</param>
            <param name="resultList">target list to receive all child replicables</param>
        </member>
        <member name="M:VRage.Replication.MyReplicables.GetNextForUpdate">
            <summary>
            Obtain next root replicable. Rotates replicables in the internal queue and refreshes their hierarchy links.
            </summary>
            <returns>next root replicable</returns>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RefreshChildren(VRage.Network.IMyReplicable)">
            <summary>
            Refreshes all children of given replicable.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Refresh(VRage.Network.IMyReplicable)">
            <summary>
            Refreshes replicable, updates its links to parent.
            Returns true if replicable is a root (has no parent).
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Add(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable@)">
            <summary>
            Sets or resets replicable (updates child status and parent).
            Returns true if replicable is root, otherwise false.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.Remove(VRage.Network.IMyReplicable)">
            <summary>
            Removes replicable, children should be already removed
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RemoveHierarchy(VRage.Network.IMyReplicable)">
            <summary>
            Removes replicable with all children, children of children, etc.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicables.AddChild(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Add child replicable to the hierarchy.
            </summary>
            <param name="addReplicable">replicable to be added</param>
            <param name="parent">link to the parent replicable</param>
        </member>
        <member name="M:VRage.Replication.MyReplicables.RemoveChild(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Remove the child from the hierarchy.
            </summary>
            <param name="remReplicable">replicable to be deleted</param>
            <param name="parent">link to the parent replicable of remReplicable</param>
        </member>
        <member name="T:VRage.Replication.ReplicableAttribute">
            <summary>
            This annotation allows a replicated object to declare it's replicable type.
            
            If the type of the replicable is generic to one argument then the type of the replicated object
            is used as said generic argument and the replicable type shall be that of the resulting concrete class.
            </summary>
        </member>
        <member name="M:VRage.Replication.ReplicableAttribute.#ctor(System.Type)">
            <summary>
            Declare a replicable type for a given object.
            </summary>
            <param name="replicableType">The type of the replicable to use for this class.</param>
        </member>
        <member name="T:VRage.Replication.ReplicableForAttribute">
            <summary>
            This annotation allows a replicable type to declare what object it replicates.
            
            If the replicable is a generic class we generate the correct concrete class at runtime.
            </summary>
        </member>
        <member name="M:VRage.Replication.ReplicableForAttribute.#ctor(System.Type)">
            <summary>
            Declare a replicable type for a given object.
            </summary>
            <param name="replicableType">The type of the replicable to use for this class.</param>
        </member>
        <member name="M:VRage.Replication.IReplicationClientCallback.GetFrameTimeInSeconds">
            <summary>
            Get the real length of frame time in seconds.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.Stream">
            <summary>
            Stream with the event
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.TargetObjectId">
            <summary>
            Target object net id of the event.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.BlockingObjectId">
            <summary>
            Object network id that is blocking this event. If 'NetworkId.Invalid' than no blocking object.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.EventId">
            <summary>
            Id of the invoked method.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.OrderNumber">
            <summary>
            Number of the event to keep the correct order.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyBufferedEvent.IsBarrier">
            <summary>
            Indicates if this event is a barrier.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyObjectEventsBuffer.Events">
            <summary>
            Events to be processed for network object.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyEventsBuffer.MyObjectEventsBuffer.IsProcessing">
            <summary>
            Indicates if events are currently processed.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.EnqueueEvent(VRage.Library.Collections.BitStream,VRage.Network.NetworkId,VRage.Network.NetworkId,System.UInt32,VRage.Network.EndpointId)">
            <summary>
            Enqueues event that have to be done on target object.
            </summary>
            <param name="stream">Stream with event data.</param>
            <param name="targetObjectId">Object id that is a target of the event.</param>
            <param name="blockingObjectId">Object id that is blocking target to be processed. 'NetworkId.Invalid' if none.</param>
            <param name="eventId">Event id.</param>
            <param name="sender">Endpoint.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.EnqueueBarrier(VRage.Network.NetworkId,VRage.Network.NetworkId)">
            <summary>
            Enqueues barrier for an entity that is targeting network object with blocking event. WARNING: Have to be in
            pair with blocking event!
            </summary>
            <param name="targetObjectId">Network object id that will get barrier event.</param>
            <param name="blockingObjectId">Network object that have blocking event.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.RemoveEvents(VRage.Network.NetworkId)">
            <summary>
            Removes all events from target id.
            </summary>
            <param name="objectInstance">Target object network id.</param>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessEvents(System.Collections.Generic.HashSet{VRage.Network.NetworkId},VRage.Network.NetworkId)">
            <summary>
            Tries to process events for prarticular object id (network id).
            </summary>
            <param name="targetObjectIds">List of all target object network ids.</param>
            <param name="eventHandler">Handler for processing events.</param>
            <param name="isBlockedHandler">Handler for checking if processing of events should be canceled.</param>
            <param name="caller">Parent Network id from which this is called. Set NetworkId.Invalid if no parent.</param>
            <returns>True if all sucessful.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessBarrierEvent(System.Collections.Generic.HashSet{VRage.Network.NetworkId},VRage.Replication.MyEventsBuffer.MyBufferedEvent)">
            <summary>
            Process barrier event.
            </summary>
            <param name="targetObjectIds">Target objects to be resolved.</param>
            <param name="eventToProcess">Event to process.</param>
            <returns>True if success.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.ProcessBlockingEvent(System.Collections.Generic.HashSet{VRage.Network.NetworkId},VRage.Replication.MyEventsBuffer.MyBufferedEvent,VRage.Network.NetworkId)">
            <summary>
            Process blocking event.
            </summary>
            <param name="targetObjectIds">Target object ids to process.</param>
            <param name="eventToProcess">Event to be processed.</param>
            <param name="caller">Parent Network id from which this is called. Set NetworkId.Invalid if no parent.</param>
            <returns>True if was success.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.TryLiftBarrier(VRage.Network.NetworkId)">
            <summary>
            Tries to lift barrier from target network object. If successful, removes this barrier from
            target object events queue. Also barrier must be aiming target object id.
            </summary>
            <param name="targetObjectId">Target network object id.</param>
            <returns>True if barrier found on the top of target object events queue. Otherwise false.</returns>
        </member>
        <member name="M:VRage.Replication.MyEventsBuffer.GetEventsBufferStat">
            <summary>
            Gets events buffer statistics.
            </summary>
            <returns>Formatted events buffer statistics.</returns>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.StateGroupIds">
            <summary>
            The network id's of each state group on the replicable.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.IsStreaming">
            <summary>
            Whether this replicable is still streaming to client.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.IsReady">
            <summary>
            Whether this replicable is in pending list but already loaded.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.MarkedForDestroy">
            <summary>
            Whether this replicables was destroyed by the server.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.PendingDependencyCount">
            <summary>
            Number of pending replicables that are preventing this from finishing loading.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.Dependents">
            <summary>
            Set of all replicables that are waiting for this before they can load.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.Dependencies">
            <summary>
            Set of all replicables this one is waiting on.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.Replicable">
            <summary>
            Replicable instance that waits for it's dependencies.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyPendingReplicable.Callback">
            <summary>
            Callback to be invoked when the dependency count reaches zero.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyPendingReplicable.HasDependents">
            <summary>
            Whether there are any replicables waiting for this to finish loading before they can.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyPendingReplicable.HasDependencies">
            <summary>
            Whether this replicable has registered any dependencies.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyPendingReplicable.AddDependency(VRage.Network.NetworkId,System.Boolean)">
            <summary>
            Add a dependency to our tracking. If that replicable is still pending we increment our pending count.
            </summary>
            <param name="id">The network id of the dependency.</param>
            <param name="dependencyReady">Whether this dependency is not pending and should not increment the pending count.</param>
            <returns></returns>
        </member>
        <member name="P:VRage.Replication.MyReplicableClientData.IsSleeping">
            <summary>
            When replicable is sleeping, it should not receive state updates. But it has to receive events.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicableClientData.HasActiveStateSync">
            <summary>
            Returns true when replicable is not pending and is not sleeping.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicablePacketStreamReader">
            <summary>
            Reads compressed data from the stream, concatenates them until whole packet is received.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicablePacketStreamReader.ReadResult">
            <summary>
            Enumeration of possible results of reading from stream.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamReader.ReadResult.Ok">
            <summary>
            Reading succeeded, packet data are ready under property ReceivedBuffer.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamReader.ReadResult.Pending">
            <summary>
            Whole packet has not been read yet.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamReader.ReadResult.Failure">
            <summary>
            Reading failed due to size mismatch, details are logged.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamReader.m_receivedBuffer">
            <summary>
            Buffer which holds parts of received compressed data.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamReader.m_cursor">
            <summary>
            Number of bytes received from stream so far.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicablePacketStreamReader.ReceivedBuffer">
            <summary>
            Received data, compressed. Returns null until all data is read. Needs to be decompressed and deserialized.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicablePacketStreamReader.IsCompressed">
            <summary>
            Indicates if the received buffer contains compressed data.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketStreamReader.Read(VRage.Library.Collections.BitStream)">
            <summary>
            Read compressed data from the stream. 
            </summary>
            <param name="stream"></param>
            <returns>Returns ReadResult indicating if the reading succeeded, if it is still pending or if it failed.</returns>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamWriter.STREAM_SAFETY_PADDING">
            <summary>
            Magic safety padding value.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamWriter.m_packet">
            <summary>
            Serialized packet.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicablePacketStreamWriter.m_cursor">
            <summary>
            Current position in the stream.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketStreamWriter.#ctor(VRage.Replication.MyReplicableSerializationPacketDesc)">
            <summary>
            Constructor, pass the packet with serialized replicables to be streamed to client.
            </summary>
        </member>
        <member name="P:VRage.Replication.MyReplicablePacketStreamWriter.Replicables">
            <summary>
            Returns all replicables which are part of this stream.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicablePacketStreamWriter.WriteBlock(VRage.Library.Collections.BitStream,VRage.Network.EndpointId,System.Int32)">
            <summary>
            Write block of replicable packet to the stream.
            </summary>
            <param name="stream">target stream</param>
            <param name="targetEndpointId">target endpoint id (client's address)</param>
            <param name="maxBitPosition">maximum valid bit position in the stream</param>
            <returns>returns true when whole packet was written to the stream</returns>
        </member>
        <member name="T:VRage.Replication.MyReplicableSerializationJob">
            <summary>
            Static class which provides parallel serialization of group of replicables into the target serialization queue.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc">
            <summary>
            Descriptor holding data for parallel job.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.Replicables">
            <summary>
            List of replicables which will be serialized.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.ReplicableDescs">
            <summary>
            List of replicable descriptors which will be serialized.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.TargetQueue">
            <summary>
            Target serialization queue.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.Immediate">
            <summary>
            After serialization and compression, enqueue to high-priority queue.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.JobId">
            <summary>
            Job identification number.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc.#ctor(System.Collections.Generic.List{VRage.Network.IMyReplicable},System.Collections.Generic.List{VRage.Replication.MyReplicableSerializationJob.MyReplicableDesc},VRage.Replication.MyReplicableStreamingPreparation,System.Boolean,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="replicables"></param>
            <param name="replicableDescs">List of replicable descriptors which will be serialized.</param>
            <param name="targetQueue">Target serialization queue.</param>
            <param name="immediate">After serialization and compression, enqueue to high-priority queue.</param>
            <param name="jobId">Job identification number</param>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.HEADER_CHAR">
            <summary>
            Introduction mark in the serialization stream. For sanity checking.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationJob.FOOTER_CHAR">
            <summary>
            Finalizing mark in the serialization stream. For sanity checking.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableSerializationJob.Start(VRage.Replication.MyReplicableStreamingPreparation,System.Collections.Generic.List{VRage.Network.IMyReplicable},VRage.Network.EndpointId,System.Boolean,System.Int32)">
            <summary>
            Generates serialization data from passed replicables and starts the serialization to stream. Once the serialization (and compression)
            is done, replicableStreaming instance is notified.
            </summary>
            <param name="targetQueue">Link to queue which will accept the packet with serialized replicables to be streamed later.</param>
            <param name="replicables">List of replicables to be serialized, compressed into the packet which will be passed to the queue.</param>
            <param name="targetEndpointId"></param>
            <param name="blocking">Process as a blocking operation and enqueue to high-priority queue.</param>
            <param name="jobId">identifier of the serialization job</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableSerializationJob.SerializeToBitstream(VRage.Replication.MyReplicableSerializationJob.SerializationJobDesc)">
            <summary>
            Serialize replicable descriptors - write them to stream and compress using gzip.
            </summary>
            <param name="jobDesc">job descriptor, contains list of replicable descriptors and link to the target queue</param>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_server">
            <summary>
            Link to the replication server.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_targetEndpointId">
            <summary>
            Target network endpoint id. (Id of the client).
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_preparation">
            <summary>
            Instance responsible for preparing the replicables for streaming.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_currentPacket">
            <summary>
            Currently streamed packet.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_currentPacketValid">
            <summary>
            Flag marking if the currently streamed packet is valid.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_currentlyStreamedReplicables">
            <summary>
            Hashset of currently streamed replicables.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreaming.m_newReplicables">
            <summary>
            New replicables added for streaming.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.#ctor(VRage.Network.MyReplicationServer,VRage.Network.EndpointId)">
            <summary>
            Constructor.
            </summary>
            <param name="server">Pass reference to the instance of replication server.</param>
            <param name="targetEndpointId">Target (client's) endpoint id.</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.Add(VRage.Network.IMyReplicable)">
            <summary>
            Add the replicable for streaming to client.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.Contains(VRage.Network.IMyReplicable)">
            <summary>
            Returns true for given replicable if it is enqueued for streaming to client or is already being serialized or streamed to the client.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.IsProcessed(VRage.Network.IMyReplicable)">
            <summary>
            Returns true for given replicable if it is already being serialized or streamed to the client.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.ProcessNewReplicables">
            <summary>
            Process the new replicables - enqueue them for serialization and streaming.
            Replicables are aggregated by dependencies and sent to client together.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.CompareReplicablePriorities(VRage.Network.IMyReplicable,VRage.Network.IMyReplicable)">
            <summary>
            Compare two replicables by their priorities. Higher priority goes first.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.Write(VRage.Library.Collections.BitStream,VRage.Network.EndpointId,System.Int32)">
            <summary>
            Write replicable packets to given stream.
            </summary>
            <param name="stream">target stream</param>
            <param name="targetEndpointId">target client id</param>
            <param name="maxBitPosition">maximum valid bit position in the stream</param>
            <returns>returns true when anything was written to the stream</returns>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.TryGeneratingReplicationGroup(VRage.Network.IMyReplicable,System.Collections.Generic.List{VRage.Network.IMyReplicable}@)">
            <summary>
            Try to prepare the replicable and its dependents - create replication group for serialization and streaming. 
            </summary>
            <param name="replicable">seed replicable from which the group is created</param>
            <param name="outReplicableGroup">
                    When function returns true, this list will contain group of replicables to be replicated together as one logical packet.
                    The list is empty if function returns false (no group was generated).
            </param>
            <returns>
                    Returns true if the replication group was created, read group entries from replicationGroup argument.
                    Return false when no group content was generated.
            </returns>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreaming.TryDequeueNextPacket">
            <summary>
            Try to dequeue next packet from preparation queue and assign it to m_currentPacket.
            </summary>
            <returns>returns true if the packet was successfully dequeued</returns>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationPacketDesc.Replicables">
            <summary>
            List of serialized replicables.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationPacketDesc.ReplicableDescs">
            <summary>
            List of replicable descriptors - contains information of serialized objects.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationPacketDesc.PacketData">
            <summary>
            Final compressed data prepared for sending.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationPacketDesc.JobId">
            <summary>
            Helper number of the job to keep the order of packets.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableSerializationPacketDesc.IsCompressed">
            <summary>
            Indicates if the packet data are compressed.
            </summary>
        </member>
        <member name="T:VRage.Replication.MyReplicableStreamingPreparation">
            <summary>
            Preparation queue for replicable streaming. 
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.TargetEndpointId">
            <summary>
            Target client endpoint id.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.m_readyForSending">
            <summary>
            Collection of packets which are ready to be streamed to client. Every packet contains serialized replicables.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.m_readyForImmediateSending">
            <summary>
            Collection of packets which are ready to be streamed to client and need to be streamed immediately. Every packet contains serialized replicables.
            </summary>
            TODO: reconsider.
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.m_processingSet">
            <summary>
            Set of replicables which are being process by this instance. That means either 
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.m_jobGeneratedId">
            <summary>
            Job id counter, required to keep the order of replications to the client.
            </summary>
        </member>
        <member name="F:VRage.Replication.MyReplicableStreamingPreparation.m_jobExpectedId">
            <summary>
            Expected id of finished async job, required to keep the order of replications to the client.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.#ctor(VRage.Network.MyReplicationServer,VRage.Network.EndpointId)">
            <summary>
            Constructor. Pass links to replication server and endpoint identifier of target client.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.Contains(VRage.Network.IMyReplicable)">
            <summary>
            Returns true if the replicable is already being prepared.
            </summary>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.SubmitReplicables(System.Collections.Generic.List{VRage.Network.IMyReplicable},System.Boolean)">
            <summary>
            Submit group replicables to be streamed together in one packet to the client.
            At first, the serialization data is generated, then serialized to stream, then compressed and then enqueued for sending.
            By default, serialized to stream and compression are asynchronous operations.
            </summary>
            <param name="replicables">list of replicables to be streamed together to the client</param>
            <param name="blocking">When set to true, this operation is blocking and the replicable is serialized to stream on the calling thread.</param>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.SubmitPacket(VRage.Replication.MyReplicableSerializationPacketDesc)">
            <summary>
            Submit packet of serialized replicables that is ready for sending to client.
            </summary>
            This method is used by MyReplicableSerializationJob when the compression of replicable group is done.
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.TryDequeuePacket(VRage.Replication.MyReplicableSerializationPacketDesc@)">
            <summary>
            Try dequeue packet to be streamed to client.
            </summary>
            <param name="packetDesc">dequeued packet</param>
            <returns>Returns true if there is a packet ready to be streamed to client</returns>
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.SubmitImmediatePacket(VRage.Replication.MyReplicableSerializationPacketDesc)">
            <summary>
            Submit packet of serialized replicables that is ready and needs to be sent to client immediately.
            </summary>
            This method is used by MyReplicableSerializationJob when the compression of replicable group is done.
        </member>
        <member name="M:VRage.Replication.MyReplicableStreamingPreparation.TryDequeueImmediatePacket(VRage.Replication.MyReplicableSerializationPacketDesc@)">
            <summary>
            Try dequeue packet to be immediately streamed to client. These are replicables which demand being streamed at once.
            </summary>
            <param name="packetDesc">dequeued packet</param>
            <returns>Returns true if there is a packet ready to be streamed to client.</returns>
            TODO: reconsider.
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="T:VRage.Serialization.BitStreamExtensions">
            <summary>
            Extension methods for common bit stream serialization operations.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MySerializerIndexer.TryGetSerializer(System.Type,System.Type@)">
            <summary>
            Try to find a serializer for the given type.
            </summary>
            <param name="serializableType">The type to serialize.</param>
            <param name="serializer">The serializer for the type.</param>
            <returns>Whether a serializer was found.</returns>
        </member>
        <member name="T:VRage.Serialization.Xml.CustomRootReader">
            <summary>
            Custom XmlReader that allows to read xml fragments
            </summary>
        </member>
        <member name="T:VRage.Serialization.Xml.MyXmlSerializerBase`1">
            <summary>
            Xml serializer base class with custom root element reader/writer caching
            </summary>
            <typeparam name="TAbstractBase"></typeparam>
        </member>
        <member name="T:VRage.Serialization.Xml.MyAbstractXmlSerializer`1">
            <summary>
            Custom xml serializer that allows object instantiation on elements with xsi:type attribute
            </summary>
            <typeparam name="TAbstractBase"></typeparam>
        </member>
        <member name="T:VRage.Serialization.Xml.CustomRootWriter">
            <summary>
            Custom XmlWriter that allows to write xml fragments
            </summary>
        </member>
        <member name="T:VRage.Serialization.Xml.MyStructXmlSerializer`1">
            <summary>
            Deserializes structs using a specified default value (see StructDefaultAttribute).
            </summary>
        </member>
        <member name="T:VRage.Serialization.Xml.MyStructXmlSerializer`1.Accessor">
            <summary>
            Abstract accessor for both fields and properties
            </summary>
        </member>
        <member name="T:VRage.Serialization.Xml.MyXmlSerializableAttribute">
            <summary>
            Indicates that a class should be indexed for use with MyAbstractXmlSerializer.
            </summary>
        </member>
        <member name="F:VRage.Serialization.Xml.MyXmlSerializerManager.m_serializersByType">
            <summary>
            Serializers by type.
            </summary>
        </member>
        <member name="F:VRage.Serialization.Xml.MyXmlSerializerManager.m_serializedNameToType">
            <summary>
            Serializer by their serialized name.
            </summary>
        </member>
        <member name="F:VRage.Serialization.Xml.MyXmlSerializerManager.m_serializedNameByType">
            <summary>
            Serialized name indexed by deserialized type.
            </summary>
        </member>
        <member name="F:VRage.Serialization.Xml.MyXmlSerializerManager.m_parent">
            <summary>
            Parent indexer.
            </summary>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.GetSerializer(System.Type)">
            <summary>
            Find a serializer by it's type.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">When the type was not known.</exception>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.GetOrCreateSerializer(System.Type)">
            <summary>
            Get a serializer or if one is not available then create it.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.GetSerializedName(System.Type)">
            <summary>
            Get the name for serialization for a given type.
            </summary>
            <param name="type">The type</param>
            <returns>The name</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">When the type was not indexed.</exception>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.TryGetSerializer(System.String,System.Xml.Serialization.XmlSerializer@)">
            <summary>
            Try to get a serializer for a serialized name.
            </summary>
            <param name="serializedName">Serialized name of the </param>
            <param name="serializer"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.GetSerializer(System.String)">
            <summary>
            Get serializer for a serialized name.
            </summary>
            <param name="serializedName"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Serialization.Xml.MyXmlSerializerManager.RegisterType(System.Type)">
            <summary>
            Register serializer for the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Serialization.Xml.MyXmlSerializerManager.ActiveFile">
            <summary>
            File being read from or written to.
            </summary>
            TODO: This should ideally be placed in a different class.
        </member>
        <member name="T:VRage.Serialization.Xml.MyXmlTextReader">
            <summary>
            Custom XML Reader with user data attached
            </summary>
        </member>
        <member name="P:VRage.Serialization.Xml.MyXmlTextReader.DefinitionTypeOverrideMap">
            <summary>
            Map to override definitions types
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer.Clone(System.Object,System.Object)">
            <summary>
            Makes clone of object member.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer.Equals(System.Object,System.Object)">
            <summary>
            Tests equality of object members.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MySerializeInfo.KeyInfo">
            <summary>
            Serialization settings for dictionar key.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MySerializeInfo.ItemInfo">
            <summary>
            Serialization settings for dictionary value or collection / array elements
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer`1.Clone(`0@,`0@)">
            <summary>
            Makes clone of object member.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MyMemberSerializer`1.Equals(`0@,`0@)">
            <summary>
            Tests equality of object members.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MySerializer`1.Clone(`0@)">
            <summary>
            In-place clone.
            Primitive and immutable types can implements this as empty method.
            Reference types must create new instance a fill it's members.
            </summary>
        </member>
        <member name="M:VRage.Serialization.MySerializer`1.Equals(`0@,`0@)">
            <summary>
            Tests equality.
            </summary>
        </member>
        <member name="M:VRage.MyPositionAndOrientation.ShouldSerializeOrientation">
            <summary>
            Prevent XML serialization. Always returns false.
            </summary>
        </member>
        <member name="M:VRage.Sync.SyncExtensions.ValidateNever``1(VRage.Sync.Sync{``0})">
            <summary>
            Sets validation handler to always return false.
            </summary>
        </member>
        <member name="M:VRage.Sync.SyncExtensions.ValidateRange(VRage.Sync.Sync{System.Single},System.Single,System.Single)">
            <summary>
            Sets validate handler to validate that value is in range.
            </summary>
        </member>
        <member name="M:VRage.Sync.SyncExtensions.ValidateRange(VRage.Sync.Sync{System.Single},System.Func{System.Single},System.Func{System.Single})">
            <summary>
            Sets validate handler to validate that value is in range.
            </summary>
        </member>
        <member name="M:VRage.Sync.SyncExtensions.ValidateRange(VRage.Sync.Sync{System.Single},System.Func{VRageMath.MyBounds})">
            <summary>
            Sets validate handler to validate that value is withing bounds.
            </summary>
        </member>
        <member name="M:VRage.Sync.SyncHelpers.Compose(System.Object,System.Int32,System.Collections.Generic.List{VRage.Sync.SyncBase})">
            <summary>
            Takes objects and creates instances of Sync fields.
            </summary>
        </member>
        <member name="E:VRage.Sync.SyncBase.ValueChanged">
            <summary>
            ValueChanged event is raised when value is set locally (settings Value property) or remotely (through deserialization).
            When validation fails, value is not changed and ValueChanged is not raised.
            </summary>
        </member>
        <member name="F:VRage.Sync.SyncBase.UpdateFrameTime">
            <summary>
            Last update time (synchronized frame number).
            </summary>
        </member>
        <member name="F:VRage.Sync.Sync`1.Validate">
            <summary>
            Validate handler is raised on server after deserialization.
            </summary>
        </member>
        <member name="M:VRage.Sync.Sync`1.ValidateAndSet(`0)">
            <summary>
            Validates the value and sets it (when valid).
            </summary>
        </member>
        <member name="T:VRage.Utils.MyDiscreteSampler`1">
            <summary>
            A templated class for sampling from a set of objects with given probabilities. Uses MyDiscreteSampler.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyDiscreteSampler">
            <summary>
            Provides a simple and efficient way of sampling a discrete probability distribution as described in http://www.jstatsoft.org/v11/i03/paper
            Instances can be reused by calling the Prepare method every time you want to change the distribution.
            Sampling a value is O(1), while the storage requirements are O(N), where N is number of possible values
            </summary>
        </member>
        <member name="M:VRage.Utils.MyDiscreteSampler.Prepare(System.Collections.Generic.IEnumerable{System.Single})">
            The list supplied to the method does not have to add up to 1.0f, that's why it's called "densities" instead of "probabilities"
        </member>
        <member name="M:VRage.Utils.MyDiscreteSampler.Sample(System.Single)">
            Beware that Cestmir thinks this can be less precise if you have a billiard numbers.
            
            He is probably right. So only use this version if you don't care.
        </member>
        <member name="M:VRage.Utils.MyDiscreteSampler.ReadBins">
            <summary>
            Get a copy of the internal bins.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.Utils.MyAverageFiltering">
            <summary>
            Mean (average) filtering.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyAverageFiltering.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="sampleCount">Number of samples used in this mean filter.</param>
        </member>
        <member name="M:VRage.Utils.MyAverageFiltering.Add(System.Double)">
            <summary>
            Add raw value to be filtered.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyAverageFiltering.Get">
            <summary>
            Get filtered value.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyMaxFiltering">
            <summary>
            Nonlinear maximum filtering.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyMaxFiltering.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="sampleCount">Number of samples used in this mean filter.</param>
        </member>
        <member name="M:VRage.Utils.MyMaxFiltering.Add(System.Double)">
            <summary>
            Add raw value to be filtered.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyMaxFiltering.Get">
            <summary>
            Get filtered value.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyMergeHelper">
            <summary>
            Helper class for merge funcionality. Performs comparison between
            source and other values and set on self if value is different
            </summary>
        </member>
        <member name="T:VRage.Utils.MyMinFiltering">
            <summary>
            Nonlinear minimum filtering.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyMinFiltering.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="sampleCount">Number of samples used in this mean filter.</param>
        </member>
        <member name="M:VRage.Utils.MyMinFiltering.Add(System.Double)">
            <summary>
            Add raw value to be filtered.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyMinFiltering.Get">
            <summary>
            Get filtered value.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyUtils">
            <summary>
            MyFileSystemUtils
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetEdgeSphereCollision(VRageMath.Vector3D@,System.Single,VRage.MyTriangle_Vertices@)">
            <summary>
            Returns intersection point between sphere and its edges. But only if there is intersection between sphere and one of the edges.
            If sphere intersects somewhere inside the triangle, this method will not detect it.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetInsidePolygonForSphereCollision(VRageMath.Vector3D@,VRage.MyTriangle_Vertices@)">
            <summary>
            Return true if point is inside the triangle.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetInsidePolygonForSphereCollision(VRageMath.Vector3@,VRage.MyTriangle_Vertices@)">
            <summary>
            Return true if point is inside the triangle.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLineTriangleIntersection(VRageMath.Line@,VRage.MyTriangle_Vertices@)">
             <summary>
             Checks whether a ray intersects a triangleVertexes. This uses the algorithm
             developed by Tomas Moller and Ben Trumbore, which was published in the
             Journal of Graphics Tools, pitch 2, "Fast, Minimum Storage Ray-Triangle
             Intersection".
            
             This method is implemented using the pass-by-reference versions of the
             XNA math functions. Using these overloads is generally not recommended,
             because they make the code less readable than the normal pass-by-value
             versions. This method can be called very frequently in a tight inner loop,
             however, so in this particular case the performance benefits from passing
             everything by reference outweigh the loss of readability.
             </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSphereTriangleIntersection(VRageMath.BoundingSphereD@,VRage.Utils.MyPlane@,VRage.MyTriangle_Vertices@)">
            <summary>
            Method returns intersection point between sphere and triangle (which is defined by vertexes and plane).
            If no intersection found, method returns null.
            See below how intersection point can be calculated, because it's not so easy - for example sphere vs. triangle will 
            hardly generate just intersection point... more like intersection area or something.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSphereTriangleIntersection(VRageMath.BoundingSphereD@,VRageMath.PlaneD@,VRage.MyTriangle_Vertices@)">
            <summary>
            Method returns intersection point between sphere and triangle (which is defined by vertexes and plane).
            If no intersection found, method returns null.
            See below how intersection point can be calculated, because it's not so easy - for example sphere vs. triangle will 
            hardly generate just intersection point... more like intersection area or something.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.CreateFolder(System.String)">
            <summary>
            Vytvori zadany adresar. Automaticky povytvara celu adresarovu strukturu, teda ak chcem vytvorit c:\volaco\opica
            a c:\volaco zatial neexistuje, tak tato metoda ho vytvori.
            </summary>
            <param name="folderPath"></param>
        </member>
        <member name="M:VRage.Utils.MyUtils.CopyDirectory(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            if subDirs = true than also subdirectories will be copied. Otherwise shallow copy.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="subDirs"></param>
            <param name="ignoredFolderNames"></param>
        </member>
        <member name="M:VRage.Utils.MyUtils.GenerateQuad(VRageMath.MyQuadD@,VRageMath.Vector3D@,System.Single,System.Single,VRageMath.MatrixD@)">
            <summary>
            Generate oriented quad by matrix
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetAngleBetweenVectors(VRageMath.Vector3,VRageMath.Vector3)">
            <summary>
            Calculating the Angle between two Vectors (return in radians).
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetBillboardQuadOriented(VRageMath.MyQuadD@,VRageMath.Vector3D@,System.Single,System.Single,VRageMath.Vector3@,VRageMath.Vector3@)">
            <summary>
            This billboard isn't facing the camera. It's always oriented in specified direction. May be used as thrusts, or inner light of reflector.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLargestDistanceToSphere(VRageMath.Vector3D@,VRageMath.BoundingSphereD@)">
            <summary>
            Distance between "from" and opposite side of the "sphere". Always positive.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetLineBoundingBoxIntersection(VRageMath.Line@,VRageMath.BoundingBox@)">
            <summary>
            Calculates intersection between line and bounding box and if found, distance is returned. Otherwise null is returned.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSmallestDistanceToSphere(VRageMath.Vector3D@,VRageMath.BoundingSphereD@)">
            <summary>
            Calculates distance from point 'from' to boundary of 'sphere'. If point is inside the sphere, distance will be negative.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSpherePlaneIntersection(VRageMath.BoundingSphereD@,VRageMath.PlaneD@,System.Double@)">
            <summary>
            This tells if a sphere is BEHIND, in FRONT, or INTERSECTS a plane, also it's distance
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetSpherePlaneIntersection(VRageMath.BoundingSphereD@,VRage.Utils.MyPlane@,System.Single@)">
            <summary>
            This tells if a sphere is BEHIND, in FRONT, or INTERSECTS a plane, also it's distance
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.IsLineIntersectingBoundingSphere(VRageMath.LineD@,VRageMath.BoundingSphereD@)">
            <summary>
            Check intersection between line and bounding sphere
            We don't use BoundingSphere.Contains(Ray ...) because ray doesn't have an end, but line does, so we need
            to check if line really intersects the sphere.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Vector3)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Vector3@,VRageMath.Vector3@)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Normalize(VRageMath.Matrix@,VRageMath.Matrix@)">
            <summary>
            Protected normalize with assert
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.Init``1(``0@)">
            <summary>
            When location is null, creates new instance, stores it in location and returns it.
            When location is not null, returns it.
            </summary>
        </member>
        <member name="F:VRage.Utils.MyUtils.DefaultNumberSuffix">
            <summary>
            Default number suffix, k = thousand, m = million, g/b = billion
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Aligns rectangle, works in screen/texture/pixel coordinates, not normalized coordinates.
            </summary>
            <returns>Pixel coordinates for texture.</returns>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAlignedFromCenter(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Modifies input coordinate (in center) using alignment and
            size of the rectangle. Result is at position inside rectangle
            specified by alignment.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordTopLeftFromAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute top-left corner coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordTopLeftFromAligned(VRageMath.Vector2I,VRageMath.Vector2I,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute top-left corner coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordCenterFromAligned(VRageMath.Vector2,VRageMath.Vector2,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Reverses effect of alignment to compute center coordinate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetCoordAlignedFromRectangle(VRageMath.RectangleF@,VRage.Utils.MyGuiDrawAlignEnum)">
            <summary>
            Returns coordinate within given rectangle specified by draw align. Rectangle position should be
            upper left corner. Conversion assumes that Y coordinates increase downwards.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomVector3">
            <summary>
            Returns a uniformly-distributed random vector from inside of a box (-1,-1,-1), (1, 1, 1)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomVector3D">
            <summary>
            Returns a uniformly-distributed random vector from inside of a box (-1,-1,-1), (1, 1, 1)
            </summary>
        </member>
        <member name="M:VRage.Utils.MyUtils.GetRandomTimeSpan(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a random TimeSpan between begin (inclusive) and end (exclusive).
            </summary>
        </member>
        <member name="T:VRage.Utils.MyStringHash">
            <summary>
            Generates string hashes deterministically and crashes on collisions. When used as key for hash tables (Dictionary or HashSet)
            always pass in MyStringHash.Comparer, otherwise lookups will allocate memory! Can be safely used in network but never serialize to disk!
            
            IDs are computed as hash from string so there is a risk of collisions. Use only when MyStringId is
            not sufficient (eg. sending over network). Because the odds of collision get higher the more hashes are in use, do not use this for
            generated strings and make sure hashes are computed deterministically (eg. at startup) and don't require lengthy gameplay. This way
            we know about any collision early and not from rare and random crash reports.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyStringHash.TryGet(System.Int32)">
            <summary>
            Think HARD before using this. Usually you should be able to use MyStringHash as it is without conversion to int.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyExternalDebugStructures.ReadMessageFromPtr``1(VRage.Utils.MyExternalDebugStructures.CommonMsgHeader@,System.IntPtr,``0@)">
            <summary>
            Convert from raw data to message.
            Message must be struct with sequential layout having first field "Header" of type "CommonMsg".
            </summary>
        </member>
        <member name="T:VRage.Utils.MyStringId">
            <summary>
            Generates unique IDs for strings. When used as key for hash tables (Dictionary or HashSet)
            always pass in MyStringId.Comparer, otherwise lookups will allocate memory! Never serialize to network or disk!
            
            IDs are created sequentially as they get requested so two IDs might be different between sessions or clients and
            server. You can safely use ToString() as it will not allocate.
            </summary>
        </member>
        <member name="T:VRage.Utils.MyVector3ISet">
            <summary>
            A data structure for a set of Vector3I coordinates optimized for sets with high spatial coherence (hence the name)
            </summary>
        </member>
        <member name="P:VRage.Utils.MyVector3ISet.Timestamp">
            <summary>
            For detection of modification of the set during iteration. Every modifying operation on the set should increase the timestamp
            </summary>
        </member>
        <member name="M:VRage.Utils.MyVector3ISet.Union(VRage.Utils.MyVector3ISet)">
            <summary>
            Makes a union of this set and the other set and saves it in this set
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.#ctor">
            <summary>
            Initializes a new instance of the Encoding5Bit class.
            Uses characters 0-9 and A-Z except (0,O,1,I).
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.#ctor(System.Char[])">
            <summary>
            Initializes a new instance of the Encoding5Bit class.
            </summary>
            <param name="characters">32 characters which will be used when encoding bytes to string.</param>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.Encode(System.Byte[])">
            <summary>
            Encodes data as 5bit string.
            </summary>
        </member>
        <member name="M:VRage.Utils.My5BitEncoding.Decode(System.Char[])">
            <summary>
            Decodes 5bit string as bytes, not alligned characters may be lost.
            Only decode strings encoded with Encode.
            </summary>
            <param name="encoded5BitText"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertRelease(System.Boolean)">
            <summary>
            This "assert" is executed in DEBUG and RELEASE modes. Use it in code that that won't suffer from more work (e.g. loading), not in frequently used loops
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertRelease(System.Boolean,System.String)">
            <summary>
            This "assert" is executed in DEBUG and RELEASE modes. Use it in code that that won't suffer from more work (e.g. loading), not in frequently used loops
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.FailRelease(System.String)">
            <summary>
            Logs the message on release and also displays a message on DEBUG.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertDebug(System.Boolean)">
            <summary>
            This "assert" is executed in DEBUG mode. Because people dont know how to use AssertRelease!
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertDebug(System.Boolean,System.String)">
            <summary>
            This "assert" is executed in DEBUG mode. Because people dont know how to use AssertRelease!
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(System.Double)">
            <summary>
            Returns true if double is valid
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(System.Single)">
            <summary>
            Returns true if float is valid
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(VRageMath.Vector3D)">
            <summary>
            Returns true if Vector3D is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(VRageMath.Vector3)">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(VRageMath.Vector2)">
            <summary>
            Returns true if Vector2 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.IsValid(System.Nullable{VRageMath.Vector3})">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(VRageMath.Vector3D)">
            <summary>
            Returns true if Vector3D is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(VRageMath.Vector3)">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(System.Nullable{VRageMath.Vector3})">
            <summary>
            Returns true if Vector3 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(VRageMath.Vector2)">
            <summary>
            Returns true if Vector2 is valid
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyDebug.AssertIsValid(System.Single)">
            <summary>
            Returns true if float is valid
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Utils.MyEventSet">
            <summary>
            From http://www.wintellect.com/Resources CLR Via C# by Jeffrey Richter
            </summary>
        </member>
        <member name="T:VRage.Utils.MyBBSetSampler">
            <summary>
            This class allows for uniform generation of points from a set of bounding boxes.
            
            You start by constructing a bounding box from where the points will be sampled.
            Then you can incrementally subtract bounding boxes and the resulting structure will allow you
            to generate uniformly distributed points using the Sample() function.
            </summary>
        </member>
        <member name="T:VRage.MyVertexFormatVoxelSingleData">
             <summary>
             Format for vertices of renderable voxel meshes
            
             Before changing this format check how it is used in the renderer
             and be sure to change both places to match.
             </summary>
        </member>
        <member name="F:VRage.MyVertexFormatVoxelSingleData.Material">
            <summary>
            For multimaterial vertex only
            0, 1 or 2, indicates what material is on this vertex
            </summary>
        </member>
        <member name="P:VRage.MyCubeInstanceData.Translation">
            <summary>
            Gets translation, faster than getting local matrix
            </summary>
        </member>
        <member name="M:VRage.MyCubeInstanceData.ResetBones">
            <summary>
            Resets bones to zero and disables skinning
            </summary>
        </member>
        <member name="M:VRage.MyCubeInstanceData.GetNormalizedBone(System.Int32)">
            <returns>Vector in range [0,1]</returns>
        </member>
        <member name="M:VRage.MyCubeInstanceData.Denormalize(VRageMath.Vector4,System.Single)">
            <param name="position">Scaled in range [0,1]</param>
            <param name="range">Unscaled</param>
            <returns>Unscaled position</returns>
        </member>
        <member name="T:VRage.StructDefaultAttribute">
            <summary>
            Specifies a static read-only default value field for structs
            </summary>
        </member>
        <member name="M:VRage.Import.VF_Packer.PackAmbientAndMaterial(System.Single,System.Byte)">
            <summary>
            Pack abient and material indes to a single float.
            </summary>
            <param name="ambient"></param>
            <param name="materialIndex"></param>
            <returns>The packed value.</returns>
        </member>
        <member name="F:VRage.Voxels.MyCellCoord.Lod">
            <summary>
            0 is the most detailed.
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyStorageData.Resize(VRageMath.Vector3I,VRageMath.Vector3I)">
            <param name="start">Inclusive.</param>
            <param name="end">Inclusive.</param>
        </member>
        <member name="M:VRage.Voxels.MyStorageData.Resize(VRageMath.Vector3I)">
            <summary>
            Resize this data buffer to fit a cube of data the provided size.
            </summary>
            <param name="size3D"></param>
            <exception cref="T:System.OverflowException">If the total number of cells overflows a 32-bit integer.</exception>
        </member>
        <member name="T:VRage.Voxels.MyStorageDataPool">
            <summary>
            Manager for a pool of storage data holders.
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyStorageDataPool.PoolHandle.Dispose">
            <inheritdoc />
        </member>
        <member name="T:VRage.Voxels.MyVoxelCoordSystems">
            <summary>
            Functions for transforming to and from various coordinate systems in voxel maps and for computing bounding boxes of various types of cells.
            Note that local and world positions are (and should be) always in the min-corner!
            </summary>
            
            TODO: Review this whole class
            These are half wrong/ don't consider world matrix, beware
        </member>
        <member name="T:VRage.Voxels.MyVoxelDataConstants">
            <summary>
            Container for miscellaneous voxel data constants.
            </summary>
            
            Voxels represent a signed distance field, each cells stores how far it is from the implicit surface.
            
            This distance is clamped to a [-1,1] interval and represented by a [255,0] integer range.
            The encoded distance is inverted, so a negative sign is encoded by values from 128 onwards, while negative sign is encoded as values &lt;= 127.
            
        </member>
        <member name="F:VRage.Voxels.MyVoxelDataConstants.IsoLevel">
            <summary>
            Largest content value where this signed distance is still positive.
            </summary>
        </member>
        <member name="F:VRage.Voxels.MyVoxelDataConstants.NullMaterial">
            <summary>
            The byte describing the absence of material.
            
            This byte should never occur in areas where content is non-zero.
            </summary>
        </member>
        <member name="F:VRage.Voxels.MyVoxelDataConstants.Defaults">
            <summary>
            Array of default values for voxel data, this array can be indexed by the integer value of MyStorageDataTypeEnum.
            </summary>
        </member>
        <member name="F:VRage.Voxels.MyVoxelDataConstants.LodCount">
            <summary>
            There are 16 lods, 0 through 15.
            </summary>
        </member>
        <member name="M:VRage.Voxels.MyVoxelDataConstants.DefaultValue(VRage.Voxels.MyStorageDataTypeEnum)">
            <summary>
            Lookup the default value for a given storage data type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitCompressionExtensions.ReadQuaternionNormCompressed(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.WriteQuaternionNormCompressed(VRage.Library.Collections.BitStream,VRageMath.Quaternion)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.SerializeNormCompressed(VRage.Library.Collections.BitStream,VRageMath.Quaternion@)">
            <summary>
            Serializes normalized quaternion into 29 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.ReadQuaternionNormCompressedIdentity(VRage.Library.Collections.BitStream)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.WriteQuaternionNormCompressedIdentity(VRage.Library.Collections.BitStream,VRageMath.Quaternion)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="M:System.BitCompressionExtensions.SerializeNormCompressedIdentity(VRage.Library.Collections.BitStream,VRageMath.Quaternion@)">
            <summary>
            Serializes normalized quaternion into 1 or 30 bits
            </summary>
        </member>
        <member name="M:System.Extensions.FindStateGroup``1(VRage.Network.IMyReplicable)">
            <summary>
            Finds state group of specified type.
            Returns null when group of specified type not found.
            </summary>
        </member>
    </members>
</doc>
